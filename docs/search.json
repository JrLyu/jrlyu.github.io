[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jiuru Lyu",
    "section": "",
    "text": "Hi! My name is Jiuru Lyu, and I am a junior at Emory University studying Applied Mathematics. In my leisure time, I enjoy coffee brewing, traveling, photograph, and commercial aviation.\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\nIB Math AA HL Notes\n\n\nCollege Level Math\n\nMath Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\n\n\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\n\n\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\n\n\n\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\n\n\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "about.html#high-school-level-math",
    "href": "about.html#high-school-level-math",
    "title": "Class Notes",
    "section": "",
    "text": "IB Math AA HL Notes\nCollege Level Math Math Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\n\nIB Math AA HL Notes\n\n\n\nCollege Level Math\n\nMath Fundamentals\n\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\n\n\n\nApplied Mathematics\n\nOrdinary Differential Equations\nNonlinear Optimization\nUndergraduate-Level Numerical Analysis\n\n\n\nData Science, Statistics, and Causal Inference\n\nIntroduction to Causal Inference\nMathematical Statistics\nGoogle Data Analytics Learning Notes\n\n\n\n\nComputer Science\n\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nDatabase Systems\n\n\n\nOther Fields\n\nIntroduction to Sociology\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/MathStats.html#statistical-inference",
    "href": "notes/MathStats.html#statistical-inference",
    "title": "Mathematical Statistics",
    "section": "Statistical Inference",
    "text": "Statistical Inference"
  },
  {
    "objectID": "notes/Proofs.html#proof-practice",
    "href": "notes/Proofs.html#proof-practice",
    "title": "IB Math AA HL Notes",
    "section": "Proof Practice",
    "text": "Proof Practice"
  },
  {
    "objectID": "notes/LA.html#linear-algebra-done-right",
    "href": "notes/LA.html#linear-algebra-done-right",
    "title": "Linear Algebra",
    "section": "Linear Algebra Done Right",
    "text": "Linear Algebra Done Right"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "My Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nblog post title\n\n\n\nQuarto\n\n\nTest\n\n\nBlog\n\n\n\nblog post description (appears underneath the title in smaller text) which is included on the listing page\n\n\n\nJiuru Lyu\n\n\nOct 26, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html",
    "href": "blogs/2024-10-26-test-blog/index.html",
    "title": "blog post title",
    "section": "",
    "text": "This is my test-blog to show case how to generate a blog post in Quarto.\n\n\nIt is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "href": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "title": "blog post title",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAlso see other useful blogs as reference!↩︎"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "href": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "title": "blog post title",
    "section": "",
    "text": "It is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "notes/cs171.html",
    "href": "notes/cs171.html",
    "title": "CS 171 Introduction to Computer Science II",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nLecture 1 Introduction & Review\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithm\n\n\nOOP\n\n\nData Structure\n\n\n\nThis lecture introduces the purpose of studying algorithms and data structures. It also does some review on Java and its code basics.\n\n\n\n\n\nAug 29, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 2 Objects and Classes\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nObjects\n\n\nClass\n\n\n\nThis lecture introduces the concepts of OOP in Java.\n\n\n\n\n\nSep 7, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 3 Packages\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nPakcage\n\n\n\nBased on Objects and Classes, this lecture extends the idea and introduces Packages and how it works in Java.\n\n\n\n\n\nSep 16, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 4 Inheritance and Polymorphism\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInhertiance\n\n\nPolymorphism\n\n\n\nThis lecture is a more detailed lecture on inheritance and polymorphism, two very essential concepts in OOP.\n\n\n\n\n\nSep 19, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 5 Abstract Classes and Interfaces\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInterface\n\n\nAbstract Class\n\n\n\nThis lecture touches on abstract classes and extends it to interfaces. It also introduces Iterator and Iterable interfaces in Java and how to use them in practice. \n\n\n\n\n\nOct 4, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 6 Generic Classes and Generic Methods\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nGenerics\n\n\n\nThis lecture discusses the use of generic class and generic methods in Java. It also touches on the use of generic classes in practice.\n\n\n\n\n\nOct 10, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 7 Array Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nArray\n\n\n\nStarting from this lecture, we discuss some data structures. The very basic data structure of discussion is the array data structure.\n\n\n\n\n\nOct 14, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 8 Stack\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nStack\n\n\n\nThis lecture discusses the stack data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 9 Queue Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nQueue\n\n\n\nThis lecture discusses the queue data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 10 Linked List\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nLinked List\n\n\n\nThis lecture discusses the linked list data structure and its implementation in Java.\n\n\n\n\n\nNov 2, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 11 Complexity Analysis\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithms\n\n\nComplexity Analysis\n\n\n\nStarting from this lecture, we will discuss some sorting algorithms and their complexity analysis. This lecture offers an overview of running time analysis.\n\n\n\n\n\nNov 11, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 12 Sorting Algorithms\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithms\n\n\nSorting\n\n\n\nThis lecture discusses various sorting algorithms and their implementation in Java. It also touches on the runtime analysis of them.\n\n\n\n\n\nDec 4, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 13 Hashing (Hash Table): Implementation and Runtime Analysis\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nAlgorithms\n\n\nHash Table\n\n\nHashing\n\n\n\nThis lecture discusses the hashing algorithm and the hash table data structure. It also covers the implementation of the hash table and the runtime analysis of the hash table operations.\n\n\n\n\n\nDec 6, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "title": "Lecture 8 Stack",
    "section": "The Stack Interface",
    "text": "The Stack Interface\n\nThe stack interface definition:\n\nThe stack only defines a behavior on the access of the data stored in a stack: pop() must return the last item that was pushed\nThe stack does not specify how the data must be stored.\nThere are different ways to implement the same behavior\n\npublic interface MyStackInterface&lt;E&gt; {\n  boolean isEmpty(); // returns true if stack is empty\n  boolean isFull(); // returns true if stack is full\n  void push(E e); // pushes element e on the stack\n  E pop(); // Remove the element at the top of the stack and return it\n  E peek(); // Return the element at the top without removing it\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "title": "Lecture 8 Stack",
    "section": "Implementing the Stack with a fixed size array",
    "text": "Implementing the Stack with a fixed size array\n\nThe basic implementation of a Stack is using:\n\nA fixed size array to store the data items\nA stackTop index variable to record the first open position in the array\n\nThe initial state of the stack when it is instantiated (=created): stackTop = 0 (can also use stackTop = -1)\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return; // Or: throw an exception\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        return item[stackTop]; // (2) return item\n    }\n}\n\nSee IntegerStack.java and TestIntegerStack.java."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "title": "Lecture 8 Stack",
    "section": "Implement the stack with a dynamic array",
    "text": "Implement the stack with a dynamic array\n\nThe stack can be implemented using a dynamic array\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    private final double DELTA = 0.25;\n    \n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            // Double the array size\n            Integer[] temp = new int[2 * item.length];\n            for (int i = 0; i &lt; item.length; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        Integer retVal = item[stackTop];\n        if (stackTop &lt; DELTA * item.length && item.length &gt;= 2) {\n            // Reduce the array by half\n            temp = new int[item.length / 2];\n            for (int i = 0; i &lt;= stackTop; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        return retVal; // (2) return item\n    }\n}\n\nThe value DELTA determines when we will reduce the size of the array: DELTA is a wastage threshold:\n\nWhen only the fraction of DELTA of the array is being used, we will reduce the wastage.\nSince we will reduce the array by half, DELTA must be at most 0.5. Otherwise, we will discard some valid entries in the stack.\nDELTA = 0.25 is actually better than 0.5\n\nRunning Time Analysis: Consider the push() algorithm using a dynamic array. On average, how many “store” statements are executed for each push() invocation?\n\nWhen the stack is not full, the push() invocation will execute 1 store statement.\nWhen the stack if full, the push() invocation will execute (1 + item.length) store statement.\nSuppose we execute \\(N\\) push() operations:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# times exec push()\n1\n2\n3\n4\n5\n6\n7\n8\n\\(\\cdots\\)\n\\(N\\)\n\n\n\n\n# store statements to store item pushed\n1\n1\n1\n1\n1\n1\n1\n1\n\\(\\cdots\\)\n1\n\n\n# store statements to double array\n1\n2\n0\n4\n0\n0\n0\n8\n\\(\\cdots\\)\n\\(M\\leq N\\)\n\n\n\n\nTherefore, total store statements executed for \\(N\\) push() invocations: \\[(1+1+\\cdots+1)+(1+2+4+\\cdots+M)\\text{ where }M\\le N\\]\n\nConsider \\(S=1+2+4+\\cdots+M\\): \\[\\begin{aligned}S=1+&2+4+\\cdots+M\\\\2S=\\quad\\ \\ &2+4+8+\\cdots+2M\\\\S=2S-S&=2M-1\\end{aligned}\\]\nTherefore, total store statements executed is \\[N+(2*M-1)\\leq N+2*N-1=3N-1\\]\nHence, average # store statement for 1 push() invocation is \\(\\dfrac{(3N-1)}{N}\\approx3\\)."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "title": "Lecture 8 Stack",
    "section": "Generic Stack",
    "text": "Generic Stack\n\nJava does not allow instantiation of a generic array, so the following code will cause error messages:\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = new T[N]; // Create an array of T objects --&gt; error\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nHowever, there’s a simple hack to work around this Java restriction.\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects, and casting\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nIn this way, Java will report warning messages (not fatal errors), so our program will still compile and run.\n\npublic class GenericStack&lt;T&gt; implements MyStackInterface&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public GenericStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects\n        // This will cause some warning, but it will compile (Java does not know if the casting will be successful)\n        // Why this will work: If we are working with unbounded generic types,\n        // we know T will be interpreted as Object by Java. Then we will create\n        // an array of Object, then cast it into our desired type T\n        stackTop = 0;\n    }\n    @Override\n    public boolean isEmpty() {\n        return stackTop == 0;\n    }\n\n    @Override\n    public boolean isFull() {\n        return stackTop == item.length;\n    }\n\n    @Override\n    public void push(T t) {\n        // if the array is full, then double the size of the array\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return;\n        }\n        item[stackTop] = t;\n        stackTop++;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // or throw an exception\n        }\n        stackTop--; // (1) decrease stackTop\n        return item[stackTop]; // return item\n    }\n\n    @Override\n    public T peek() {\n        return item[stackTop - 1];\n    }\n\n    public String toString(){\n        String result = \"\";\n        for (int i = 0; i &lt; stackTop; i++) {\n            result += item[i] + \" \";\n        }\n        return result;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "title": "Lecture 8 Stack",
    "section": "Java’s Stack Library",
    "text": "Java’s Stack Library\n\nThe Java library contains a generic Stack class: java.util.Stack\nTo instantiate Stack objects:\n\nStack&lt;Integer&gt; iStack = new Stack&lt;&gt;(); // Integer Stack\nStack&lt;String&gt; sStack = new Stack&lt;&gt;(); // String Stack\n\nThe Stack class contains the following instance methods: boolean empty(); E peek(); E push(E item); E pop().\nFor some reasons, the Stack class is a subclass of the Vector class, which can access the sotred data using an index.\n\nAs a subclass, Stack inherits those methods:\n\nget(int index); // Returns the element at the specified position\nremove(int index); // Removes the element at the specified position\n\nHowever, this inheritance makes the FIFO behavior not guaranteed. ## Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "title": "Lecture 8 Stack",
    "section": "Application of Stack: Reverse Polish Expression Evaluation",
    "text": "Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "title": "Lecture 8 Stack",
    "section": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression",
    "text": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression\n\nProblem description:\n\nWe are given a fully parenthesized arithmetic expression using only x, /, +, and - operations.\nWrite an algorithm to evaluate expressions in this form.\nWe will need 2 stakcs:\n\nAn operand stack that stores the operands in the input, and\nAn operator stack that stores the operators in the input.\n\n\nAlgorithm:\n\nFind the first occurrence of a right parenthesis ): observe the last 2 operands and the last operation prior to the right parenthesis.\n\nThis guarantees the most inner () will be the first to be evaluated.\nThe result of an operation must be pushed on to operand stack.\n\nThen, we can reduce the parenthesis and find the next earliest occurrence of the right parenthesis.\nRepeat the steps until the input array is exhausted.\nThe left parenthesis ( does not convey and information.\n\nimport java.util.Stack;\npublic class Dijkstra2Stackalg {\n  public static Integer eval(String[] inp) {\n      Stack&lt;Integer&gt; operandStck = new Stack&lt;&gt;();\n      Stack&lt;String&gt; operatorStck = new Stack&lt;&gt;();\n      String s;\n\n      for (int i = 0; i &lt; inp.lengthl i++) {\n          s = inp[i];\n          if (s.equals(\"(\")) {\n              // do nothing\n          } else if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) { // s is an operator\n              operatorStck.push(s);\n          } else if (s.equals(\")\")) { // compute the must inner ()\n              int o2 = operandStck.pop();\n              int o1 = operandStck.pop();\n              String op = operatorStck.pop();\n              int r = operate(op, o1, o2);\n              operandStck.psuh(r);\n          } else { // s is a number\n              operandStck.push(s);\n          }\n      }\n      return operandStck.pop();\n  }\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriented Thinking",
    "text": "Object-Oriented Thinking\n\nObject-Oriented Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriented Design methodology when developing the classes.\nThe Object-Oriented Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriented methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriented Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Overloading vs. Overriding",
    "text": "Overloading vs. Overriding\n\n\n\n\n\n\nNote 1: Overloading\n\n\n\nDefining different methods with the same (method) name but with different (method) signatures\n\n\n\n\n\n\n\n\nTip 2: Example of Overloading\n\n\n\n\n\npublic class SomeClass {\n  public int x;\n  public SomeClass (int a) {\n    x = a;\n  }\n  public void method1() {\n    System.out.println(\"SomeClass.method1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.method2()\");\n  }\n}\npublic class NewClass extends SomeClass {\n  NewClass (int a) {\n    super(a);\n  }\n  // Inherits: method1() and method2()\n  public void method1(int a) { // Overloads method1()\n    System.out.println(\"NewClass.m1(int)\");\n  }\n  public void method3() {\n    method1(); // Invokes SomeClass method1\n    method1(22); // Invokes NewClass method1(int)\n  }\n}\n\n\n\n\n\n\n\n\n\nNote 2: Overriding\n\n\n\nReplacing an inherited method by defining a method with the same (method) signature\n\n\n\n\n\n\n\n\nTip 3: Example of Overriding\n\n\n\n\n\npublic class NewClass extends SomeClass {\n  NewClass(int a) {\n    super(a);\n  }\n  // Inherites: method1() and method2()\n  public void method1() { // overrides method1()\n    System.out.println(\"NewClass.m1()\");\n  }\n  public void method3() {\n    method1(); // Invokes NewClass method1\n    super.method1(); // Invokes SomeClass method1\n  }\n}\n\n\n\n\nIn Java, we can add the special override annotation @Override before an overriding method for clarity: java     public class NewClass extends SomeClass {       // Inherits: method1(double)       @Override       public void method1(double x) {         System.out.println(\"x = \" + x);       }     }\n\nJava compiler will report an error if the defined method does not override any inherited methods.\n\nAdditional conditions on overriding methods\n\nThe overriding method must have the same return type as the overridden method. We will get a type incompatible error when we use different return types.\nThe overriding method should have the same accessibility modifier as the overridden method. Complicated errors can result when you do not use the same accessibility."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Things that the Java Compiler does automatically",
    "text": "Things that the Java Compiler does automatically\n\nEvery object must be initialized; therefore\n\nEvery class must have a constructor method\nif a class does not have one, the Java compiler will insert the default constructor\n\nEvery subclass object contains a superclass object (that must be initialized); therefore\n\nA subclass constructor must invoke super() as its first statement.\nIf not so, the Java compiler will insert super(); at the beginning.\n\nEvery class in Java is descended from one special class called the Object class. i.e., the Object class is the parent class of every class in any Java program\n\nIf no inheritance is specified when a class is defined, the Java compiler will automatically insert extends Object in the class definition.\nEvery class in Java inherits from the Object class.\nEvery object in Java will have all the methods defined in the Object class.\n\nOne important method in the Object class is toString()\n\ntoString() returns a string representation of this object.\nFurthermore, the System.out.println() method invokes the toString() method so it can print out any object.\nTherefore, we can control the print out of an object by overriding the toString() in a class."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Introduction to Polymorphism",
    "text": "Introduction to Polymorphism\n\nSo far, we have always used a reference variable to point to an object of the same class. Now, we will use a reference variable to point to an object of a different class.\n\n\n\n\n\n\n\nTip 4: Example of Polymorphism\n\n\n\n\n\npublic class SomeClass {\n  public int x = 44;\n  public void method1() {\n    System.out.println(\"SomeClass.m1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.m2()\");\n  }\n}\n\nThen, the following are legal\n\nDefine a reference variable: SomeClass a;\nCreate a SomeClass object: a = new SomeClass();\na.x\na.method1()\na.method2()\n\n\n\n\n\n\nThe Correctness of Program Execution (Suppose a SomeClass variable a is referencing to some arbitrary object with a.x, a.method1(), and a.method2() defined)\n\nRule: a reference variable must refer to an object that contains all members in a legal request\n\nReason: the referred object must perform all acrtions in the class or else we can have a request error.\nThe simplest way to satisfy this rule is to refer to an object of the same class.\nHowever, there is another safe (=correct) way due to the inheritance relationship.\n\nA subclass object can perform all actions that a superclass object performs.\n\nTherefore, it is safe to use a superclass reference variable to request members in a subclass object.\nJava allows we to access members in a subclass object using a superclass reference variable.\n\n\nDynamic Dispatch (aka: late binding)\n\nThe request a.method() will execute the method in the object that a is currently pointing to.\nThis feature is called dynamic dispatch or late binding, which means decision on which method to run is at the last moment.\n\n\n\n\n\n\n\n\nTip 5\n\n\n\n\n\npublic class SomeClass {\n    public int x = 44;\n    public void method1() {\n      System.out.println(\"SomeClass.m1()\");\n    }\n    public void method2() {\n      System.out.println(\"SomeClass.m2()\");\n    }\n}\npublic class NewClass extends SomeClass {\n    @Override\n    public void method1() {\n      System.out.println(\"NewClass.m1()\");\n    }\n    public void method3() {\n      System.out.println(\"newClass.m3()\");\n    }\n}\npublic class myProg {\n    public class void main(String[] args) {\n      SomeClass a = new NewClass(); // allowed!\n      System.out.println(a.x);\n      a.method1(); // Invokes method1() in NewClass\n      a.method2();\n      a.method3(); // illegal\n    }\n  }\n\nBecause a is pointing to a NewClass object, a.method1() will execute NewClass’s method1() even though a is a SomeClass object.\n\n\n\n\n\nPolymorphism\n\nConsider the following program:\n\n  SomeClass a; // superclass reference variable\n  // Use superclass variable to access overridden method in superclass\n  a = new SomeClass(); // refer superclass object\n  a.method1(); // calls SomeClass.method1()\n  // Use superclass variable to access overridden method in subclass\n  a = new NewClass(); // refers subclass object\n  a.method1(); // class NewClass.method1()\n\nThe same expression a.method1() invokes different methods\n:::{#nte-polymorphism .callout-note} ## Polymorphism The phenomenon that the same expression (program code) can result in different actions. Polymorphism is caused by using a superclass reference variable to access overridden members in the superclass and their subclasses and late binding. :::\n\nA reverse case: a superclass object may perform fewer actions than a subclass object.\n\nTherefore, it is illegal to use a subclass reference variable to access members in a superclass object."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Application of Polymorphism: Selection Sort Algorithm",
    "text": "Application of Polymorphism: Selection Sort Algorithm\n\n\n\n\n\n\nNote 3: Sorting an array\n\n\n\nRe-arrange the values in an array so that the values are ordered.\n\n\n\nIn our discussion, we will sort the array in ascending order.\nThere are many array sorting algorithms, but we will first examine the selection sort algorithm.\n\nSelection sort finds the smallest number in the list and swaps it with the first element.\nIt then finds the smallest number remaining and swaps it with the second element.\nAnd so on, until only a single number remains (i.e., the last number in the list)\n\npublic static void selectionSort(int[] list) {\nfor (int i = 0; i &lt; list.length-1; i++) {\n  // Find the minimum in the list[i...list.length-1]\n  int min      = list[i]; // Assume the first element is min\n  int minIndex = i;       // Index where min is found\n  for (int k = minIndex+1; k &lt; list.lenght; k++) {\n    if (list[k] &lt; min) {  // Find a smaller element\n      min      = list[k]; // Update min value\n      minIndex = k;       // Update its index\n    }\n  }\n  // Swap list[i] with list[minIndex] if necessary\n  if (minIndex != i) {\n    // Swap list[minIndex] and list[i]\n    // Standard exchange alg\n    int help       = list[minIndex];\n    list[minIndex] = list[i];\n    list[i]        = help;\n  }\n}\n}\nDue to polymorphism, we can change the selection sort algorithm for integers to Circle, Rectangle, and even GeometricObject objects.\n\nIn order to do so, the superclass object must provide all the necessary actions used in the selectionSort() algorithm.\nTo be more specific, that is why we have defined getArea() { return 0 } in the GeometricObject previously.\n\npublic static void selectionSort(GeometricObject[] list) {\n  for (int i = 0; i &lt; list.length-1; i++) {\n    GeometricObject min = list[i]; \n    int minIndex        = i; \n    for (int k = minIndex+1; k &lt; list.lenght; k++) {\n      if (list[k].getArea() &lt; min.getArea()) {  \n        min      = list[k];\n        minIndex = k;\n      }\n    }\n    if (minIndex != i) {\n      GeometricObject help = list[minIndex];\n      list[minIndex]       = list[i];\n      list[i]              = help;\n    }\n  }\n}\npublic static void mian(String[] args) {\n  GeometricObject[] myList = new GeometricObject[4];\n  myList[0] = new Circle(\"red\", 2);\n  myList[1] = new Rectangle(\"blue\", 1, 1);\n  myList[2] = new Circle(\"white\", 5);\n  myList[3] = new Rectangle(\"black\", 4, 4);\n  selectionSort(myList)l\n  for (int i = 0; i &lt; myList.length; i++) {\n    System.out.println(myList[i]);\n  }\n}\nSummary\n\nA common technique to generalize code is to write methods with a superclass type as parameter type.\nSuch a method can receive objects of any subclass type as argument.\nRequirement:\n\nThe superclass type must provide all the actions necessary to code the method\n\nJava provides an interface mechanism that is similar to the inheritance mechanism for defining superclass type and subclass type relationship.\nUsing this interface mechanism, we can make a superclass type that can unite the String, the Circle, and the Rectangle classes"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Exception Handling and Polymorphism",
    "text": "Exception Handling and Polymorphism\n\nThe exception types in Java are also organized as an inheritance hierarchy. The root type is Exception\nWe can catch more general exceptions using types higher up in the exception hierarchy. java     public static void main(String[] args) {       int[] a = new int[10];       try {         a[99] = 1;       } catch (Exception e) { // higher up.         System.out.println(e);       }     }\n\nUse Exception, we will catch all types of exceptions\n\nWe can use multiple catch clauses, but the more specific exceptions should come first. java     public static void main(String[] args) {       int[] a = new int[10];       try {         if (Math.random() &lt; 0.5) {           a = null;         }         a[99] = 1;       } catch (ArrayIndexOutOfBoundsException e) {         System.out.println(e);       } catch (Exception e() {         System.out.println(e);       }     }"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Upcasting, Downcasting, and instanceof operator",
    "text": "Upcasting, Downcasting, and instanceof operator\n\n\n\n\n\n\nNote 4: Upcasting\n\n\n\nCasting (converting) a subclass reference into a superclass reference. - Upcasting is a safe operation because we can make fewer requests using a superclass variable than using a subclass variable.\n\n\n\n\n\n\n\n\nNote 5: Downcasting\n\n\n\nCasting (converting) a superclass reference into a subclass reference. - Downcasting is an unsafe operation because we may make an illegal request using a subclass variable.\n\n\n\nUnder some situations, downcasting can be safe and necessary:\n\nWe first perform an upcasting operation\nLater, we want to perform an action defined in the subclass\n\n\n\n\n\n\n\n\nTip 6: To Perform a Safe Downcasting Operation\n\n\n\n\n\npublic static void main(String[] args) {\n  GeometricObject a = new Circle(\"red\", 1); // Upcasting\n  System.out.println(a.getArea()); // safe\n  // System.out.println(a.getRadius()); // illegal -- getRadius() is not defined in GeometricObject\n  Circle b;\n  b = (Circle) a; // Explicit upcasting\n  System.out.println(b.getRadius()); // allowed\n}\n\n\n\n\nWe can also write similar codes for downcasting a GeometricObject object to a Rectangle object. However, how can we write a program to cast the superclass variable references to a subclass variable of non-specific subclass?\nThe instanceof boolean condition:\n\nobjectRefVar instanceof className;\n// returns true if the object referred to by objectRefVar\n// is an object of className type or a subclass type of\n// className. Otherwise, returns false\n\nUsing the instanceof, we can solve the problem:\n\npublic static void main(String\\[\\] args) { \n  GeometricObject a; if (Math.random() \\&lt; 0.5) { \n    a = new Circle(\"red\", 1); \n  } \n  a = new Rectangle(\"blue\", 2, 1);\n       \n  if (a instanceof Circle) {\n    Circle b = (Circle) a; // downcast to a circle\n    System.out.println(b.getRadius();)\n  } else if (a instanceof Rectangle) {\n    Circle b = (Rectangle) a; // downcast to a rectangle\n    Syste.out.println(b.getWidth());\n    Syste.out.println(b.getHeight());\n  } else {\n    System.out.println(\"Invalid subclass type\");\n  }\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Hiding Variables and Multi-Inheritance",
    "text": "Hiding Variables and Multi-Inheritance\n\nIf a subclass defines a variable x with the same name as its superclass:\n\nthe name x will refer to the variable in the subclass:\n\nThe variable x in the subclass will overshadow (hide) the variable in the superclass.\n\nThe variable x in the superclass can be accessed in the subclass using super.x (or through a non-overridden method)\nHowever, it’s a terrible idea to override variables.\n\nMultiple-Inheritance\n\nJava allows a class to inherit from only one superclass, while other languages (such as C++) can inherit from multiple class and made things very complicated.\nJava does implement some features of multiple inheritance through interface:\n\nA class can have multiple parent interfaces\nBut these parent interfaces must be completely empty (=no variables and contains only method declarations)"
  },
  {
    "objectID": "notes/cs171/04-Packages/Packages.html",
    "href": "notes/cs171/04-Packages/Packages.html",
    "title": "Lecture 3 Packages",
    "section": "",
    "text": "Why do programming languages provide different accessibilities (i.e. private and public qualifiers):\n\nA large computer program has many methods stored in different classes\nMethods defined inside a class are used to solve the same problem\nMethods defined inside different classes usually do not solve the same problem\nA common cause for errors is accidental update of variable(s) by a method in a different class\nLimiting access to variables (with the private qualifiers) will reduce accidental update of variable(s) by a method from another class\n\nJava packages:\n\nSome problems are too complex that they cannot be solved by methods inside one single class\n\nWe may need to write multiple classes to solve such complex problems\n\nPrograms will run more efficiently if they can access variables directly\nI.e., Getter (getRadius()) and setter (setRadius()) will slow down a program\n\n\n\n\n\n\n\n\n\n\nNote 1: Package\n\n\n\nPackage in Java is used to organize multiple classes that cooperate and perform similar tasks\n\n\n\nIt facilitates (=make it easier) the cooperation: - Java can allow methods defined in classes inside the same package to access each other members (variables and methods) directly\nExample on using a package\n\npackage p1;\npublic class C1{\n    public int x1;\n           int x2; // Default (= package) access modifier\n           // \n    private int x3;\n\n    public void m1() { }\n           void m2() { } // Default (= package) access modifier\n    private void m3() { }\n}\n\nThe numbers x2 and m2() has no access modifier. In that case, they will be assigned with the default access modifier.\n\nA member with the default access can be accessed from methods in classes belong to the same package. - Class in a same package cooperate to perform a task\nA member with the default access is not accessible from methods in classes belong to a different package. - Class in different packages do not cooperate to perform a task\nSee Demo.java\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Introduction to Interfaces",
    "text": "Introduction to Interfaces\n\n\n\n\n\n\nNote 3: Interface\n\n\n\nAn interface can be used to define common behavior for any classes (including unrelated classes). It is a similar mechanism as inheritance for unrelated class that share some behaviors (methods)\n\n\n\nAn interface is an abstract class-like construction that contains only\n\nmethod declarations and\nconstants (static and final)\n\nWe can define interface variables but cannot instantiate objects with an interface (just like an abstract class)\n\npublic interface myInterface {\n    public abstract void myMethod(); // abstract is optional\n    // other methods\n}\n\nAn interface cannot have a constructor method. We cannot create objects of an interface type (similar to an abstract class)\nWe can define variables of an interface type (to achieve polymorphism): myInterface a;\nWe implement an interface with an implementation class:\n\npublic class myClass implements myInterface {\n    // must override all methods decleared in the interface\n    public void myMethod(){\n        System.out.println(\"Running myMethod() in myClass\");\n    }\n}\n\nThe implementation class must override all methods declared in an interface.\n\n\n\n\n\n\n\nTip 1: Example to Use an Interface\n\n\n\n\n\n\nWe cannot instantiate an object with an interface type\nHence, we always upcast an object of its implementation class and assign it to an interface variable.\n\nWe upcast an object if the class implements the interface\nan interface is a superclass (of unrelated objects)\nSee InterfaceSort.java\n\n\n\n\n\n\nThe Comparable interface of the Java library\n\nIt is the superclass of all objects that can be compared.\n\npublic interface Comparable&lt;E&gt; {\n  public int compareTo(E o);\n}\n\nThe syntax &lt;T&gt; is called a generic type in Java.\n\n\n\n\n\n\n\n\nTip 2: Example to Use the Comparable Interface\n\n\n\n\n\npublic class Circle extends GeometricObject implements Comparable&lt;Circle&gt; {\n    private double radius;\n    // other method omitted\n    /**\n     * Arrays.sort() will only work with Comparable objects\n     * The Circle class must implement the Comparable interface\n     * in order to use Array.sort()\n     */\n    public int compareTo(Circle other) {\n        double diff = this.getArea() - other.getArea();\n        return (int) Math.signum(diff);\n    }\n}\n\n\n\n\nA class can inherit from only one class, but a class can implement multiple interfaces.\n\nEach interface defines a set of capabilities or “roles”.\nImplementing an interface allows a class to fulfill the role defined by an interface.\nTherefore: a class in java can fulfill multiple roles.\n\ninstanceof\n\nThe instanceof operator tells us whether a variable is a member of a class or an interface (i.e., an interface is similar to a class in Java)\n\nMethods with a default implementation in an interface\npublic interface InterfaceName {\n  public default returnType methodName(params) {\n      // method body\n  }\n}\n\nUsage: when the implementing class does not override a method with a default implementation, the Java compiler will use the default implementation as the overriding method.\n\nUnlike classes that can extend only 1 class, an interface can extend one or more interfaces\n\npublic interface Insurable extends Sellable, Transportable {\n    public int insuredValue();\n}\n\nThe interface Insurable will combine:\n\nAll methods in Sellable\nAll methods in Transportable\nThe insuredValue() method\n\n\n\n\n\n\n\n\n\nAbstract Class\nInterface\n\n\n\n\nCan have constructors, instance variables, constants, abstract methods, and non-abstract methods\nCan only have abstract methods and constants\n\n\nIs extended by a subclass that may implement the abstract methods, but does not have to. (If the subclass does not implement all abstract methods, it must be defined as an abstract class too)\nIs implemented by a subclass that must implement all the abstract methods"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Review of OOP Concepts",
    "text": "Review of OOP Concepts\n\nA class, is like a definition of a data type in Java.\nAn instance of an object of a given class is created (instantiated) using a constructor and the new operator.\nObject instances in Java are accessed through reference variables.\nA subclass can extend a superclass and use its methods and instance variables through inheritance and polymorphism.\nAbstract classes can contain 0 or more abstract methods. Classes containing at least one abstract method must be abstract. Abstract classes can not be used to instantiate objects. Abstract classes are extended by a subclass that defines the abstract methods.\nInterfaces contain only abstract methods and constants and provides a template for another class to implement all of the methods declared in the interface."
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html",
    "href": "notes/cs171/07-Generics/Generics.html",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Intro to Generic Methods",
    "text": "Intro to Generic Methods\n\nSyntax to define a generic (parameterized) method\n    public static &lt;T1, T2, ...&gt; returnType methodName(params) {\n      // method body\n    }\n    ```\n-   We can use the type parameters `T1, T1, ...` to declare parameter variables, local variables, and the return type of the method.\n``` java\npublic static &lt;T&gt; void print(T[] list) {\n  for (int i = 0; i &lt; list.length; i++) {\n      System.out.println(list[i]);\n  }   \n}\n\nThe generic method will be made specific (with a data type) in the invocation.\n\nWhen we write a generic method, the Java compiler will replace every occurrence of &lt;T&gt; by Object and will remember that list[] is a parameterized class variable.\n\nWhen the print() method is used, the Java compiler will insert the appropriate casting operator\n\nSyntax to invoke a generic (parameterized) method:\n\n    Classname.&lt;T1, T2, ...&gt;methodName(arguments)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "href": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Bounded and Unbounded Parameter Type",
    "text": "Bounded and Unbounded Parameter Type\n\nAn unbounded generic type parameter T is specified as &lt;T&gt; or &lt;T extends Objects&gt;\n\nWe can use any object (reference) type to make the parameter type T into a specific type.\nWhen an unbounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by Object.\n\nWhen Object is inappropriate as the parent class: Object does not have certain required methods used in the code.\nA bounded generic type parameter T is specified as &lt;T extends SuperClass&gt;\n\nIn this way, we can only use a subtype of a superclass to make T into a specific type.\nWhen a bounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by the bounding type, instead of Object.\n\nThe use of bounded type parameter is necessary when we have used a method in the code that is not defined in the Object class."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html",
    "href": "notes/cs171/02-Review/Review.html",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#introduction",
    "href": "notes/cs171/02-Review/Review.html#introduction",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "href": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Computer Architecture",
    "text": "Review - Computer Architecture\n\nThe smallest unit of Computer Memory: bit\n\nComputers use memory devices built with electronics.\nThe smallest memory device used by the computer works like a switch. It can be in one of the 2 states:\n\nOff state (state 0)\nOn state (state 1)\n0 and 1 are called binary digits\n\nThe smallest memory device is called a bit (=binary digit)\nA row on \\(n\\) bits can be in one of \\(2^n\\) states: each switch can be in 2 states, and so the total number of combinations is \\(2\\times2\\times2\\times\\cdots\\times2=2^n\\)\nByte memory = 8 bits = a memory device that can retain (=remember) 8 binary digits. Since \\(2^8=256\\), each byte can store one of the 256 possible patterns of binary numbers.\nThough humans are very flexible in storing data (can use many different methods), computers can only store data/information as binary numbers.\n\n\n\nMemory address and Memory content\n\nEach memory cell is identified by a unique address (which is a number).\nEach memory cell stores a number (that is the data/information stored by the computer)."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "href": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Variables in Java",
    "text": "Review - Variables in Java\n\nWhat happens inside the computer when we define a variable int a:\n\nThe computer will find some used memory cells and mark them as used (aka: allocate memory)\nThe computer equates(=records) the name a to the memory location of the reserved cells.\n\nEach variable has a data type\n\nThe data type specifies the kind of information.\nEach kind of information has its own way of representation. The way of representation is called a code.\n\nEncoding method of a data type:\n\nInformation of a data type are represented by binary numbers.\nThe encoding method defines the way to interpret a binary number.\n\nData type provide the context to interpret a number and obtain the meaning of the number.\n\nSee datatype.java for an example.\n\nJava’s primitive data types:\n\n\n\n\nData type\nEncoding method\n\n\n\n\nbyte\n2’s complement encoding using 8 bits\n\n\nshort\n2’s complement encoding using 16 bits\n\n\nint\n2’s complement encoding using 32 bits\n\n\nlong\n2’s complement encoding using 64 bits\n\n\nfloat\nIEEE 754 encoding using 32 bits\n\n\ndouble\nIEEE 754 encoding using 64 bits\n\n\nchar\nUnicode encoding using 16 bits\n\n\nboolean\nEnumeration encoding using 0=false and 1=true\n\n\n\n\nBesides the primitive data types, all other data types in Java are reference data types:\n\nReference: A reference in computer science is a memory address\nReference data type: A variable of a reference data type stores a memory address\n\nPrimitive and reference data types are stored differently:\n\nThe variable of primitive data types contains a value of that data type.\nThe variable of reference data types contains a reference to the location where the object is stored."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---programming-language",
    "href": "notes/cs171/02-Review/Review.html#review---programming-language",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Programming Language",
    "text": "Review - Programming Language\n\n\n\n\n\n\nNote 3: Programming Language\n\n\n\nAn artificial language designed to convey commands unambigously to a machine.\n\nA programming language has a set of syntax rules to construct commands.\n3 types of commands/statements in a procedural programming language:\n\nAssignment statement - Selection statement: if, if-else\nLoop statement: while, for, do-while\n\nThese 3 types of statements are necessary and sufficient to make a programming language Turing-complete (meaning the machine can solve any computational problem given enough time and memory, no matter how complex).\n\n\n\n\n\n\n\n\n\nNote 4: Operator\n\n\n\nA symbol that represents an operation.\n\n\n\n\n\nAssignment\nArithmetic\nRelational\nLogical\nSpecial\n\n\n\n\n=\n\n==\n&&\n++\n\n\n+=\n+\n!=\n||\n--\n\n\n-=\n-\n&lt;\n!\n\n\n\n*=\n*\n&lt;=\n\n\n\n\n/=\n/\n&gt;\n\n\n\n\n%=\n%\n&gt;=\n\n\n\n\n\n\n\n\n\n\n\nNote 5: Operand\n\n\n\nThe value used in an operation.\n\nAn operator performs an operation on its operands and produce some result value.\n\n\n\n\n\n\n\n\n\nNote 6: Expression\n\n\n\nA combination of one or more operators and operands that performs a computation.\n\nAn expression can be built up from other expressions.\n\n\n\ncore = score - 10 * lateDays;\n\nConsists of the arithmetic expression 10 * lateDays\nwhich itself is an operand of the arithmetic expression score - •\nwhich is an operand of the assignment expression score = •\n\n\n\n\n\n\n\nNote 7: Pre-operators and Post-operators\n\n\n\n\nPre-operators preforms the operation first and will return the new value of the variable.\nPost-operators performs the operation later and returns the old value of the variable.\n\n\n\nx = 4;\ny = ++x;   &lt;===&gt;   x = x + 1; y = x; (PRE increment)\n\nResult: x = 5  y = 5\nx = 4;\ny = x++;   &lt;===&gt;   y = x; x = x + 1; (POST increment)\n\nResult: x = 5  y = 4\n\n\n\n\n\n\nNote 8: Statement\n\n\n\nA command issued to the computer to do something.\n\nStatement is the unit of execution in a programming language.\nIn Java, a statement must be contained inside some method.\n\n\n\n\nAssignment statement:\n\nvariable = expression;\n\nx = 4; // Store the value 4 in variable x\nx = x + 1; // Read the value in variable x, add 1 to it, then store result in variable x\n\nVariables on the RHS of the = operator are read/accessed.\nThe variable on the LHS of the = operator is written/updated\nif statement\n\nif (condition)\n  one-statement;\n\nif (conditon) {\n  statement1;\n  statement2;\n  ...\n}\n\nif-else statement\n\nif (condition)\n  one-statement;\nelse\n  one-statement;\n\nif (condition) {\n  statement1;\n  statement2;\n  ...\n} else {\n  statement3;\n  statement4;\n  ...\n}\n\nSwitch statement\n\nSwitch (integer-expression) {\n  case intVal1: statement1-1;\n                statement1-2;\n                ...\n                break;\n  case intVal2: statement2-1;\n                statement2-2;\n                ...\n                break;\n  ...\n  default: statementD-1; //optional clause\n           statementD-2;\n           ...\n           break;\n}\n\nwhile loop\n\nwhile (condition)\n  one-statement;\n   \nwhile (condition) {\n  statement1;\n  statement2;\n  ...\n}\n\nfor loop\n\nfor (init; term-cond; incr) {\n  statement1;\n  statement2;\n  ...\n}\n\nSee LoopTracing.java"
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---array",
    "href": "notes/cs171/02-Review/Review.html#review---array",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Array",
    "text": "Review - Array\n\nSyntax to define an array (reference) variable:\n\ndataType[] arrayRefVar; // Defines an array reference variable\n\nSyntax to create an array object\n\nnew dataType[N]; // Create an array of N elements\n\nProperties of an array in Java:\n\nAll elements in the array have the same data type.\nArray elements are stored consecutively in memory\n\nint[] A; // A is a reference variable\nA = new int[10];\n\nint[] A will allocate (reserve memory) a reference variable A.\nnew int[10] will allocate for an int[10] array (=40 bytes) and return its base address.\nA = will assign the return value to the variable A.\n\nCopy an array:\n\nMake a duplicate of an array where the duplicate contains the same data as the original\nUpdating array elements in the duplicate must not affect the data in the original array.\n\n public static void main(String[] args) {\n    double[] myList = {34, 15, 66, 7};\n    double[] myListCopy = new double[ myList.length ];\n\n    for ( int i = 0; i &lt; myList.length; i++)\n       myListCopy[i] = myList[i];\n } \nSee (CopyArray.java)[CopyArray.java].\nVariables of primitive data types (such as int, double, etc.) can be copied with an assignment. However, in Java, the assignment operation will not copy objects of non-primitive data types.\n\ndouble[] myList = {34, 15, 66, 7};\ndouble[] myListCopy;\n\nmyListCopy = myList;   // Does not copy an array object \n// ** This copies the reference in myList to myListCopy\n\nThe assignment myListCopy = myList will copy the reference in myList to the myListCopy variable.\nBecause myListCopy and myList refer to the same array object, updates made with myListCopy[i] will also affect myList[i] and vice versa. &gt; Alias: When a difference variable names can be used to reference the same variable, they are called aliases in computer science.\nSee Alias.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---methods",
    "href": "notes/cs171/02-Review/Review.html#review---methods",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Methods",
    "text": "Review - Methods\n\n\n\n\n\n\nNote 9: Methods\n\n\n\nMethods are used to encapsulate(=put in a capsule) a series of operations used to solve a complex problem.\n\nMethods allow programmers to work with higher level of abstraction.\n\nLow level of abstraction = when we can see a log of detail\nHigh level of abstraction = when we can see less detail and the big picture\n\nAbstraction is a commonly used technique to solve complex problems.\nComponents in a method definition\n\naccess specifier: public/private\nclass variable modifier: static\nreturn value data type: int/double/etc.\nmethod name\nparameter variables\nlocal variable\nreturn value\n\n\n\n\n/**\n * This method returns the summation of integers from the start integer to the end integer.\n * @param start the start integer\n * @param end the final integer\n * @return the summation\n */\npublic static int sum(int start, int end) {\n  int s = 0;\n  for (int i = start; i &lt;= end; i++) {\n      s += i;\n  }\n  return s;\n}\n\nInvoking a method: The values of the actual parameters(=arguments) are passed(=copied) to the parameter variables of the method.\nThe signature of a method = method name + data type of the parameters.\n\nJava uses the method signature to select which method to invoke.\nOverloaded method = when there are multiple method in the class with the same method name but different signatures.\n\npublic class Overload {\n public static void meth(int x) {\n    System.out.println(\"Running: meth(int x)\");\n }\n\n public static void meth(double x) {\n    System.out.println(\"Running: meth(double x)\");\n }\n\n public static void meth(int x, int y) {\n    System.out.println(\"Running: meth(int x, int y)\");\n }\n}\nAlso see Overload.java.\nParameter passing = conveying some information(=parameter) to a method.\nThe most commonly used parameter passing mechanisms are:\n\nPass-by-value: The value of the argument is passed(=assigned) to the parameter variable. The method will use the copy of the argument’s value in its computations.\nPass-by-reference: the address of the argument is passed(=assigned) to the parameter variable. The method will retrieve the value using the address in computations.\n\nOne key to remember: The parameter variables are local variables to the method. Arguments and parameter variables are different variables.\nJava always passes the arguments by-value to a method. However, because primitive typed variables and reference typed variables are stored differently, the outcome of the pass-by-value mechanism is different for primitive typed variables and reference typed variables.\n\nA primitive typed argument passed to a method cannot be modified:\n\nSee PassPrimitive.java.\n\nA reference typed argument passed to a method will be modified.\n\nSee PassReference.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "href": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Exception Handling",
    "text": "Review - Exception Handling\n\nWhen a method execution encounters an error, the method would return an error code: See ErrorCode.java.\nIn newer programming languages, the method will “throw an exception” when ti encounters an error: See ThrowException.java.\nYou can text(=catch) for the “error code” (exception type) and execute a block when the error code is detected: See CatchException.java."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "Adding or Deleting Elements from an Array.",
    "text": "Adding or Deleting Elements from an Array.\n\nAdding an element at the end of an array\n\nThe array size is fixed after its creation.\nTo add a new element to the end of an array:\n\nCreate a new array with the 1 more element\nCopy the elements in the original array to the new array.\nCopy the new value in the last element of the new array.\nChange the array reference to point to the new array.\n\npublic static int[] addElement(int[] x, int e) {\n    int[] temp = new int[x.length + 1];\n    for (int i = 0; i &lt; x.length; i++) {// copying\n        temp[i] = x[i];\n    } \n    temp[temp.length - 1] = e;\n    return temp;\n}\n\nThe algorithm executes \\(\\texttt{x.length}+1\\) data copy statements per addition.\nDeleting the last element from an array.\n\nThe array size is fixed after its creation.\nTo delete the last element from an array:\n\nCreate a new array with the 1 less element.\nCopy all except the last elements in the original array to the new array.\nChange the array reference to point to the new array.\n\npublic static int[] deleteElement(int[] x) {\n    int[] temp = new int[x.lenght - 1];\n    for (int i = 0; i &lt; temp.length; i++) {\n        temp[i] = x[i];\n    }\n    return temp;\n}\n\nWe can delete an element at a different location with a similar algorithm.\nA better way to add and delete elements in arrays: Dynamic arrays (aka. ArrayList in Java). It consists of\n\nA (fixed size) array\nA count of the actual number of elements stored in the array.\nThe array is increased only when the add() operation encounters a full array.\nThe array is reduced when the occupancy drops below a certain threshold.\nInserting a new value will increase the count. If the array is not full, we do not need to increase its size.\nThe array is increased only when the add() operation encounters a full array.\n\nThe add() method will increase the array size by approximately twice the original size. This will avoid frequent copy operations.\n\nThe array is reduced when the occupancy drops below a certain threshold.\n\nA commonly used algorithm to implement dynamic array is array doubling:\ntemp = new int[2 * x.length];\nfor (int i = 0; i &lt; x.length; i++) {\n  temp[i] = x[i];\n}\nx = temp;\nThe ArrayList class in Java implements a dynamic (resizable) array\n\nTo use it, we import java.util.ArrayList;\nSyntax to define an ArrayList (reference) variable:\n\nArrayList&lt;ObjectType&gt; varName\n\nSyntax to create an ArrayList object\n\nnew ArrayList&lt;Object Type&gt; ();\n\nThe ArrayList object will start with an array of limited size (about 10).\n\nSee DynamicArray.java\n\n\nCommonly used methods in the ArrayList class\n\nsize(): returns the actual number of elements in the ArrayList\ntoString() returns a String representation of all elements stored in the ArrayList\nadd(E e): appends the element e to the end of the ArrayList (E is the declared data type of the ArrayList elements)\nadd(int index, E elem): inserts the element e at index index and shifts and subsequent items to the right\nremove(int index): removes the element at index index and shifts all remaining items to the left.\nget(int index): returns the element stored at the index index\nset(int index, E elem): replaces the element at index index with the element elem\nIf the element at the index does not exist, get() and set() will throw IndexOutOfBoundsException.\n\nIterating through an ArrayList:\n\nUse a regular for-loop and get(index):\n\n  for (int i = 0; i &lt; numbers.size(); i++) {\n    System.out.println(numbers.get(i));\n  }\n\nUse a foreach loop:\n\n  for (int item: numbers) {\n    System.out.println(item);\n  }\n\nNote: a foreach loop cannot be used to update array elements\nUsing an iterator object:\n\nIterator&lt;Integer&gt; numItr = numbers.iterator();\nwhile (numItr.hasNext()) {\n  System.out.println(numItr.next());\n}\nJava Iterator interface and Iterable interface\n\nIterator is an interface (class containing all virtual methods) in java.util.Iterator.\nAn object that implements the Iterator interface must provide at least the following methods:\n\nhasNext(): returns true if the iteration has more elements\nnext(): return the next element in the iteration\n\nAn Iterator allows the user to iterate over the elements stored in an Iterable interface.\nAn object is Iterable if it implements the java.util.Iterable interface.\n\nIt must implement the iterator() method that returns a Iterator object.\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nArrayList\n\n\n\n\nPros\nUses less memory; can store primitive types; can be multi-dimensional\nSize is dynamic; easy to add/remove elements\n\n\nCons\nSize cannot change;hard to add/remove elements\nUses more memory; cannot store primitive types; can only be one-dimensional"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Defining a Class & Creating Objects",
    "text": "Defining a Class & Creating Objects\npublic class Circle {\n    public double radius = 1; // The radius of this circle\n\n    public Circle() { } // constructor 1 for a circle object\n    public Circle(double newRadius) { // constructor 2 for a circle object\n        radius = newRadius;\n    }\n\n    public double getArea() { // return the area of this circle\n        return 3.14159 * radius * radius;\n    }\n\n    public void setRadius(double newRadius) { // set new radius for this circle\n        radius = newRadius;\n    }\n}\nWe use the Circle class to create two Circle objects:\npublic static void main() {\n    Circle circle1 = new Circle(); // Invokes Circle() to make this circle\n\n    Circle circle2 = new Circle(2); // Invokes Circle(double) to make this circle\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n\n    double area2 = circle2.getArea(); // Tell circle2 to run getArea()\n    System.out.println(\"Area2: \" + area2);\n\n    circle1.setRaius(5); // Tell circle1 to run setRadius()\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n}\n\nSee TestCircle.java and Cirlce.java\n\n\n\n\n\n\n\nNote 4: Unified Modeling Language (UML)\n\n\n\nA standardized modeling representation description of classes and objects.\n\n\n\nA Java class uses variables to define data fields (properties) of objects.\nA Java class uses methods to define the actions/behaviors of objects.\n\nMethods to define the actions of objects DO NOT have the static qualifier\n\nA class provides special method called constructors which are invoked only to create a new object.\n\nConstructors are designed to perform initializing actions, such as initializing the data fields of objects.\n\nA class that represents real world objects usually does not need a main() method. Without a main() method, such class cannot be run as a Java program.\n\nThough we may include a main() method in the class to test the methods, but it is preferred to write a separate class to do the testing.\n\nPreventing undesirable behavior in objects:\n\nThe Circle class implementation allows a user to access the object variables directly because we did not define radius to be private.\n\npublic class Circle {\n  public double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // changes the value of radius directlly\n  }\n}\n\nWe prevent direct access to variables in a class by using the private qualifier.\n\npublic class Circle {\n  private double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // complie error\n  }\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "title": "Lecture 2 Objects and Classes",
    "section": "Constructors of a Class",
    "text": "Constructors of a Class\n\n\n\n\n\n\nNote 5: Constructor\n\n\n\nConstructors are special methods in a class that is only invoked when an object is created using the new operator:\nClassName objVar = new ClassName(...);\n\nConstructors have 3 special properties:\n\nA constructor must have the same name as the class itself.\nConstructors do not have a return type - not even void.\nIf we include a void return type, then the method is not a constructor, but a behavior that the object can take.\n\nConstructors cannot be invoked like an ordinary method.\nLike regular methods, constructors can be overloads (i.e., multiple constructors can be defined with different signatures).\nRules on constructors and the default constructor:\n\nEvery class must have at least one constructor.\nIf a class does not have any constructor, then the Java compiler will automatically insert this constructor: className() { }. This constructor is called the default constructor.\nHowever, the Java compiler will not insert the default constructor if there is a constructor defined in the class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "title": "Lecture 2 Objects and Classes",
    "section": "Objects as Reference Data Types",
    "text": "Objects as Reference Data Types\nCircle  is a reference data type\ncircle1 is a reference variable\ncircle1 references (points to) a Circle object\n\nWe create variables to store the properties of a new object when we create the object\nThe behavior of an object (=program instructions) is stored when Java compiles the class definition.\nAn object’s member can refer to:\n\nA data field in the object\nA method in the object\n\nAfter an object is created, its data can be accessed, and its methods can be invoked using the dot operator.\nobjectRefVar.dataField  references a data field in the object\nobjectRefVar.method(arguments)  invokes a method on the object\nThe dot operator is also known as the object member access operator.\nWhy Java have reference typed variables and primitive typed variables?\n\nVariables of a primitive data type can only store 1 value but can be accessed quickly – such variables are mainly used in computations.\nObjects can have many data fields and can allow the programmer to represent complex things in the real world.\n\nObjects are mainly used for data representation\nAccessing to data in an object is slower (need 2 memory accesses)\n\n\nWe can access the member variable without using any reference variable:\n\nAn instance method is always invoked using an object reference variable: objectRefVar.method(arguments)\nThe variable objectRefVar is also passed to an instance method as an implicit (=hidden) parameter. The name of the implicit parameter is called this.\nSee Circle.java\n\nThis implicit parameter this is almost never necessary to write in a Java class. There is only 1 case that it is necessary:\n\nwhen a parameter variable has the same name as an instance variable in the class.\nSee Circle.java\n\nThe this keyword is can also be used to invoke another constructor of the same class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Copying Objects",
    "text": "Copying Objects\n\nCopy an object means:\n\nMake a duplicate of an object where the duplicated object contains the same data as the original object.\nUpdating the instance variables in the duplicate object must not affect the values in the original object.\n\nOne way is to create a new object and then copy the data fields.\npublic static void main() {\n  Circle circle1 = new Circle(4);\n\n  // Make a COPY of circle1\n  Circle circle2 = new Circle();\n  circle2.radius = circle1.radius;\n}\n\nSee CircleCopy.java. This method only works when the data fields are defined in public.\n\nAnother way is through a copy constructor:\npublic class Circle{\n  private double radius = 1;\n  public Circle() { } // constructor for a circle object\n\n  public Circle(Circle c) { // copy constructor that copies circle c\n    radius = c.radius; \n  }\n}\n\nTo invoke the copy constructor:\n\npublic static void main() {\n  Circle circle1 = new Circle(4);\n  Circile circle2 = new Circle(circle1);\n}\n\nSee CircleCopy.java."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Arrays of Objects",
    "text": "Arrays of Objects\n\nSimilar to doubles and integers, we also have arrays of objects in Java. They are also defined in a similar way.\nIn other words, we can create a Circle object with new and assign it to an array element java     Circle[] circleArray = new Circle[10];     circleArray[0] = new Circle(4);\nHowever, an array of primitive variables is different from an array of reference variables.\n\nPrimitive:\n\nAfter creating an array of primitive variables, each array element can store a value.\nPrimitive type array variables (number[k]) contains values and is used in computations\n\nReference:\n\nAfter creating an array of reference variables, each array element can store a reference of an object.\nReference array variables (circleArray[k]) contains references and is used with the member selection operator . (the dot operator)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "title": "Lecture 2 Objects and Classes",
    "section": "Data Field Encapsulation",
    "text": "Data Field Encapsulation\n\nThe most important application of visibility(=accessibility) modifiers is: data field encapsulation.\n\n\n\n\n\n\n\nNote 6: Data Field Encapsulation Data Field Encapsulation is making data fields in an object inaccessible (=private) to other classes (which will disallow other classes from using the data fields directly).\n\n\n\n\n\n\n\nEncapsulation is important because\n\nIf a data field is not private, program written by other programmers can tamper with the data fields.\nWhen other programs use a data field in an object directly, changing the implementation of the object is more difficult.\n\nChanging the implementation of the object means change the way we present the properties of an object.\n\nFor example, we can use String to represent suit as {\"Spades\", \"Hearts\", \"Diamonds\", \"Clubs\"}. Meanwhile, we can also use int to represent it as {0 = \"Spades\", 1 = \"Hearts\", 2 = \"Diamonds\", 3 = \"Clubs}.\nWhen we use String, we can use card.suit.compareTo(\"Spades\") == 0 to test if the suit of the card is spade. However, if we change the implementation of card to int, the same code card.suit.compareTo(\"Spades\") == 0 will cause an error because we do not have a .compareTo() method for an integer.\n\n\n\nSo, data field encapsulation requires that data fields are defined as private.\nWhen other classes need to read a data field, we must provide a public mutator method. - See CardPrivate.java and TestCardPrivate.java.\n\nWhen we change the implementation of an object, we can still maintain compatibility with existing Java program by providing updated accessor/mutator methods that achieve the same effect as the old implementation.\n\n\n\n\n\n\n\n\nNote 7: Immutable Objects\n\n\n\nAn immutable object is an object where its properties cannot be changed after it is created.\n\n\n\nWhy we what to have immutable objects:\n\nSome computer applications are used to record a history of events which are represented by objects\nThe “historical objects” must not be changed.\n\nTo prevent the data fields of the objects being updated:\n\nPrevent the variables being updated with direct access (e.g. circle1.radius = newRadius):\n\nDefine all distance variables as private.\n\nPrevent the variables being updated with a mutator method:\n\nImmutable objects must not have any mutator methods.\n\nPrevent the variables being updated with a reference variable:\n\nImmutable objects should not have accessor methods that return a reference to an object that has public data fields.\n\n\n\n\n\n\n\n\n\nTip 1: An Example of Immutable Object:\n\n\n\n\n\nThe String class in Java will create immutable String objects: - The String class only has methods that construct a new String from an input string, and the input string is not updated.\npublic static void main(String[] args) { \n  String s1 = \"abc\"; String s2 = s1.toUpperCase();\n\n  System.out.println(s1); // \"abc\", unchanged\n  System.out.println(s2); // \"ABC\"\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Passing Objects as Parameters to Methods",
    "text": "Passing Objects as Parameters to Methods\n\nMethods can have reference type parameter variables.\n\nSee TestCircle.java\n\nHowever, the following code will change the properties of the object directly:\npublic static void incrementRadius(Circle c) {\n  c.radius++; // Increment radius by 1\n}\n\npublic static void main(String[] args) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4\n  incrementRadius(circle1); // radius of circle1 increases by 1\n  System.out.println(circle1.getRadius()); // 5\n}\n\nIn Java, the formal parameter c is an alias of the actual parameter circle1. So, c.circle++ will also update circle1.radius.\n\nSee CopyReference.java\n\n\nReview: Passing primitive variables to methods\n\nIn Java, the value of the argument copied (=assigned) to the parameter variable. So, x in main() and c in increment() are different variables.\nWhen increment() executes c++, it updates the parameter variable c.\nThe variable x in main() is not affected.\n\nPassing reference variables to methods\n\nThe reference type Cricle variable x contains a reference to a Circle object.\nIn Java, the value of the argument copied(=assigned) to the parameter variable. x in main() and c in increment() both reference to the same Circle object.\nWhen increment() executes c.radius++, it updates the radius variable through the referencec.\nThe variable x.radius in main() is ALSO affected because it is the same object.\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  updateCircle(circle1);\n  System.out.println(circle1.getRadius()); // 4.0\n}\npublic static void updateCircle(Circle c) {\n  c = new Circle(99);\n}\n\nThe reference type Circle variable circle1 contains a reference to a Circle object.\ncircle1 in main() and c in update() both refer to the same Circle object.\nWhen update() executes c = new Circle(99), it creates another Circle object and assign its address to reference variable c.\nThe variable circle1.radius in main() is not affected.\nThrough this example, we know: we can never make x in main() refer to a different object using a method call. This is because x is passed-by-value, we cannot update x and make it refer to a different object.\nIf we really want to write a method to update the reference of x, here’s an example to do so:\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  circle1 = updateCircle(circle1); // Step 2\n  System.out.println(circle1.getRadius()); // 99.0\n}\npublic static Circle updateCircle(Circle c) {\n  c = new Circle(99);\n  return c; // Step 1\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Static Variables (and Constants) and Static Methods",
    "text": "Static Variables (and Constants) and Static Methods\n\nThere are 2 kinds of variables that can be defined inside a class (that is outside any method): java     public class Circle{        public double radius; // (1) an instance variable       public static int count; // (2) a \"static\" variable     }\nInstance variables and static variables of objects are different:\n\nEach object has its own copy of an instance variable.\nstatic variable belongs to the class and all objects of that class share the same copy of a static variable.\nIn other words, there is only 1 only of a static variable in a Java program.\n\npublic static void main(String[] args) {\n  CircleCount circle1 = new CircleCount(2);\n      CircleCount circle2 = new CircleCount(4);\n\n      circle1.count = 99;\n\n      System.out.println(circle1.radius); // 2.0\n      System.out.println(circle1.count); // 99\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 99 \n\n      circle1.radius++; // Updates an instance variable\n      circle1.count++; // Updates a static variable\n      System.out.println(circle1.radius); // 3.0\n      System.out.println(circle1.count); // 100\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 100\n}\n\ncircle1.count and circle2.count are always the same because static variables are shared\ncircle1.radius and circle2.radius are independent to each other because instance variables are not shared.\n\nApplications of static variables:\n\nThe most common application where we need to use a static variable in a class is when writing a class that can keep a count on the number of objects that has been created by a Java program.\nHow to implement?\n\nDefine a static variable named count and initialize it to zero.\nEach constructor of the class must increase the count variable by one.\n\nWhy it works?\n\nBecause when an object is created, some constructor method is invoked once, and this algorithm will keep track on the number of objects created.\n\nExample:\npublic class Circle{\n  public double radius = 1;\n  public int count = 0;\n\n  public Circle() {\n    count++;\n  }\n  public Circle(double newRadius) {\n    radius = newRadius;\n    count++;\n  }\n}\n\nThere are also two kinds of methods that can be defined inside a class: instance method and static method.\n\nInstance methods always have an implicit(=hidden) object reference parameter (this) and can access instance variables.\nstatic method do not have an implicit(=hidden) object reference parameter and cannot access instance variables.\n\nProperties of static methods:\n\nA static method belongs to a class. For this reason, static methods are also known as class methods.\nA static method can be invoked without using an object instance: Math.pow(x, n)\nstatic methods can only access static members:\n\nInvoke other static methods\nAccess static variables\nstatic methods cannot access any instance variables nor invoke instance methods.\n\n\nstatic methods are used to perform a task that is not associated with a particular object.\nInstance methods are used to perform a task using data in a specific object.\nstatic methods can be invoked in 2 different ways:\n\ninstanceVar.staticMethod(...)\nClassName.staticMethod(...)  &lt;-- Preferred\n\nSome classes may have useful constants defined in them (such as \\(\\pi\\) and \\(e\\)). Since a constant cannot change its value, we will only need one copy of it, and so a constant can always be defined as static.\nThe static block\n\nA static block is a nameless and parameterless static method in a class:\n\npublic class myClass {\n  ...  (other memebers omitted for brevity)\n\n  // A static block    \n  static\n  {\n    ... (statements)\n  }\n}\n\nUse of a static block:\n\nstatic blocks are executed before the main() method\nstatic blocks are used to initialize static variables in a class."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html",
    "href": "notes/cs171/11-Linked-List/Linked List.html",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "href": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing a Simple Linked List",
    "text": "Implementing a Simple Linked List\n\nOperations on a Linked List\n\nThe linked list is a data structure used to store information.\nTo be useful as a data structure, the linked list must support the following operaqtions:\n\nCreate an empty linked list\nInsert a data item into the linked list\n\nInsert it at the beginning of the linked list\nInsert it at the end of the linked list\n\nDelete a data item from the linked list\n\nInsert the element at the beginning of the linked list\nInsert the element at the end of the linked list\n\nSearching for some data item in the linked list\n\nSearch by its index\nSearch by its key value\n\n\n\nConstructing a linked list using explicit helper reference variables\n\npublic class Demo {\n    public static Node first; // Define the first variable\n    \n    public static void main(String[] args) {\n        Node help1 = new Node();\n        Node help2 = new Node();\n        Node help3 = new Node();\n\n        help1.item = \"to\";\n        help2.item = \"be\";\n        help3.item = \"or\";\n\n        // Create the chain\n        help1.next = help2;\n        help2.next = help3;\n        help3.next = null;\n\n        first = help1;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "href": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "title": "Lecture 10 Linked List",
    "section": "Standard List Traversal Algorithm",
    "text": "Standard List Traversal Algorithm\n// The standard list raversal algorithm\nNode p;\np = first; // p now points to the first node\n\nwhile (p != null) {\n    // process data p.item in node p\n    p = p.next; // advances p to next node\n}\n\n\n\n\n\n\nTip 1: Use the list traversal algorithm to print out all items in a list\n\n\n\n\n\nNode current;\ncurrent = first; // initialize current to the first node\nwhile (p != null) {\n    System.out.println(current.item);\n    current = current.next;\n}\n\n\n\n\nEnhancements of the list traversal algorithm: find a node that contains X.\n\nNode current = first;\nwhile (current != null && !current.item.equals(\"X\")) {\n    current = current.next;\n}\n\nUse the list traversal algorithm to find a list element that contains a certain key\n\n/**\n * This method returns a list element that contains a certain value\n * @param f the linked list to be searched\n * @param s the value of searching\n * @return the node containing s\n */\npublic static Node findNode(Node f, String s) {\n    Node current = f;\n    while (current != null) {\n        if (current.item.equals(s)) { // found! \n            return current;\n        }\n        current  = current.next;\n    }\n    return null; // not found\n} \n\nList traversal using a for-loop: print out item in the linked list using a for-loop:\n\nfor (Node p = first; p != null; p = p.next) {\n    System.out.println(p.item);\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing the Standard Operations on a Simple Linked List",
    "text": "Implementing the Standard Operations on a Simple Linked List\n\nOperations on a linked list:\n\nTest if a list is empty\nGet the item at the start\nGet the item at the end\nInsert an item at the start\nInsert an item at the end\nDelete the item at the start\nDelete item at the end\nGet the item at position k in the linked list\nRemove the first item that contains the value key from the linked list\n\npublic interface SimpleList&lt;T&gt; { // A list that store objects of type T\n  public boolean isEmpty(); // check if the list is empty\n\n  public T getFirst(); // get the first item in the list\n  public T getLast(); // get the last item in the list\n\n  public void addFirst(T item); // add an item to the beginning of the list\n  public T removeFirst(); // remove the first item from the list\n\n  public voild addLast(T item); // add an item to the end of the list\n  public T removeLast(); // remove the last item from the list\n\n  public T get(int pos); // get the item at position pos in the list\n  public void remove(T key); // remove the first item that contains the value key from the list\n}\n\nimport java.util.NoSuchElementException;\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt; {\n    // Start of the inner class Node\n    public class Node&lt;T&gt; {\n        // Node instance variables\n        private T item; // the data stored in the node\n        private Node&lt;T&gt; next; // the link to the next node\n\n        // Constructor for Node\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the inner class Node\n\n    // The list starts at first\n    private Node&lt;T&gt; first;\n\n    // Contructs an empty list\n    public GenericLinkedList() {\n        first = null;\n    }\n\n    // check if the list is empty\n    public boolean isEmpty(){ \n        return first == null;\n    }\n\n    // get the first item in the list\n    public T getFirst() {\n        // Edge case: list is empty\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item; // retrieves item in first node\n    }\n    // get the last item in the list\n    public T getLast() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // (1) Find the last node\n        Node&lt;T&gt; current = first;\n        while (current.next != null) {\n            current = current.next;\n        }\n        // (2) Return item stored in this node\n        return current.item;\n    }\n\n    // add an item to the beginning of the list\n    public void addFirst(T item) {\n        Node&lt;T&gt; = newNode = new Node&lt;&gt;(item, first);\n        first = newNode;\n    }\n    // remove the first item from the list\n    public T removeFirst() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.tiem // first = null -&gt; crash\n        first = first.next;\n        return toReturn;\n    } \n\n    // add an item to the end of the list\n    public voild addLast(T item) {\n        if (isEmpty()) { // edge case\n            first = new Node&lt;&gt;(item, null);\n            // equivalent to: addFirst(item)\n        } else {\n            // (1) Find the last element in the linked list\n            Node&lt;T&gt; current = first; // if first = null -&gt; crash\n            while (current.next != null) { // Find the last element -&gt; list traversal\n                current = current.next;\n        }\n        // (2) Mkae a new Node with data to linke to the last element \n        current.next = new Node&lt;&gt;(item, null);\n        }\n    }\n    // remove the last item from the list\n    public T removeLast() {\n        // Edge case 1: list is empty\n        if (isEmpty()) { // empty list cannot remove anything\n            throw new NoSuchElementException();\n        }\n        // Edge case 2: list only contain one element\n        if (first.next == null) {\n            Node&lt;T&gt; ret = firtst; // save for return\n            first = null; // unlink by updating first\n            return ret.item;\n        }\n        //General Case: list not empty and have at least 2 elements\n        // to remove last, we need information of the second last element\n        Node&lt;T&gt; previous = first;\n        Node&lt;T&gt; current = first;\n\n        while (current.next != null) { // find the last list element\n            previous = current; // keep track of the previous node\n            current = current.next;\n        }\n        // previous points to the predecessor node of the last node\n        // current points to the last node\n        // Unlink the last node\n        previous.next = null;\n        // return item in the last node\n        return current.item;\n    } \n\n    // get the item at position pos in the list\n    public T get(int pos) {\n        // Edge case\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // General case\n        int i = 0;\n        Node&lt;T&gt; current = first;\n        while (current != null) {\n            if (i == pos) {\n                break;\n            }\n            i++;\n            current = current.next;\n        }\n        if (current == null) {\n            throw new IndexOutOfBoundsException();\n        \n        }\n        return current.item;\n    }\n    // remove the first item that contains the value key from the list\n    public void remove(T key) {\n       // Edge case 1: list is empty\n       if (first == null) { \n           throw new NoSuchElementException();\n       } else if (first.item.equals(key)) {\n           // Edge case 2: the first item is the key\n           first = first.next\n       } else {\n           // General case\n           // (1) Find the predecessor node of the node containing item == key\n           Node&lt;T&gt; = current = first; // Initialize\n           Node&lt;T&gt; = previous = first;\n           while (current != null && !current.item.equals(key)) {\n               previous = current;\n               current = current.next;\n           }\n           if (current == null) {\n               // key not found\n               throw new NoSuchElementException ();\n           }\n           // (2) Unlink the targeted node from its predecessor node \n           previous. next = current.next;\n       }\n    }\n}\n\nIt is important to consider edge cases when defining methods.\n\nOften, the edge cases are:\n\nThe empty list: first == null\nA list contains onlly 1 element: first == null\n\n\nGarbage: Note that we origianl first node is not referenced to by any permanent variables after the operation removeFirst()\n\nSuch objects are known as garbage\nObjects that become garbage are inaccessible and unusable in the program"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Other types of Simple Linked List",
    "text": "Other types of Simple Linked List\n\nSimple Linked List\n\nThe simple (or singly-cahined) linked list is chained linearly and without a loop\nA variant of the simple linked list is double-ended list. It uses a last reference to help find the last element quickly.\nThe simple circular linked list is chained linearly and contains a loop.\n\nDoubly Linked List\n\nThe doubly linked list is a chained linearly using forward and backward links without a loop.\nThe doubly linked circular list is chained using forward and backward links and contains two loops"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "href": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "title": "Lecture 10 Linked List",
    "section": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface",
    "text": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface\n\nJava has a for-each loop that iterates over collection objects:\n\nfor (dataType x : Collection) {\n    // operations on x\n}\n\nFor example, an ArrayList is an iterable collection\n\nArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;();\na.add(1); a.add(2); a.add(3);\n\nfor (Integer i : a) {\n    System.out.println(i);\n}\n\nWe can use an ArrayList in the for-each loop because the ArrayList is Iterable. Our previous implementation of the GenericLinkedList class is not iterable, so we cannot use it in the for-each loop.\nNow, we make some changes to the GenericLinkedList class so that it is iterable:\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt;, Iterable&lt;T&gt; {\n    // Private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        // ...\n    }\n\n    // Private inner class MyLinkedListIterator\n    private class MyLinkedListIterator&lt;T&gt; implements Interator&lt;T&gt; {\n        private Node&lt;T&gt; current; // current position in the iteration\n\n        public MyLinkedListInterator(Node&lt;T&gt; f) { // contructor\n            current = f; // initialize\n        }\n\n        public boolean hasNext() {\n            // returns true if there are more nodes\n            return current != null;\n        }\n\n        public T next() {\n            // return the next element in the iteration\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            T res = current.item; // get the current item\n            current = current.next; // advance to the next node\n            return res;\n        }\n    }\n    private Node&lt;T&gt; first;\n    public GenericLinkedList() {\n        first = null;\n    }\n    // ... Other methods\n    public Iterator&lt;T&gt; iterator() { // implements the Iterable interface\n        return new LinkedListIterator&lt;T&gt;(first);\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "href": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "title": "Lecture 10 Linked List",
    "section": "Use Linked List to Implement a Stack",
    "text": "Use Linked List to Implement a Stack\npublic class ListStack&lt;T&gt; implements MyStack&lt;T&gt; {\n    // private inner class Node\n    prviate class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the private inner class Node\n\n    private Node&lt;T&gt; frist;\n\n    public ListStack() { // constructor\n        first = null; //empty list = empty stack\n    }\n\n    // returns true is stack is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if stack is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // push(item) -&gt; insert at the front of the list\n    public void push(T item) {\n        Node&lt;T&gt; newNode = new Node&lt;T&gt;(item, first);\n        first = newNode;\n    }\n\n    // pop() -&gt; remove the first item and return it\n    public T pop() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nProperties of the stack implementation using a linked list\n\nThe push() and pop() does not have any loops!\n\nWe say that the push() and pop() runs in constant time\n\nWe can also implement a stack using push(item)=addLast(item) and pop()=removeLast().\n\nHowever, this is not preferred because addLast() and removeLast() requires the use of the list traversal algorithm and will run slower."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing Queue Using a Linked List",
    "text": "Implementing Queue Using a Linked List\npublic class ListQueue&lt;T&gt; implements MyQueue&lt;T&gt; {\n    // private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of private inner class\n\n    private Node&lt;T&gt; first;\n\n    public ListQueue() { // constructor\n        first = null; // empty list = empty queue\n    }\n\n    // returns true if queue is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if queue is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // enqueue(item) -&gt; insert at the end of the list\n    public void enqueue(T item) {\n        if (isEmpty()) {\n            first = new Node&lt;T&gt;(item, null);\n        } else {\n            Node&lt;T&gt; current = first;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = new Node&lt;T&gt;(item, null);\n        }\n    }\n\n    // dequeue() -&gt; remove the first item and return it\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nPostscript:\n\nWe can also implement a queue using:\n\nenqueue(item) = addFirst(item)\ndequeue() = removeLast()"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "href": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "title": "Lecture 10 Linked List",
    "section": "Java’s LinkedList<E> Class",
    "text": "Java’s LinkedList&lt;E&gt; Class\n\nJava’s LinkedList&lt;E&gt; class implemented as a doubly-linked list\nSample methods:\n\nsize() // returns the number of elements in this list\n\naddFirst(E e);\naddLast(E e);\nadd(int index, E element)\n\nremoveFirst();\nremoveLasT();\nremove(int index)\n\ngetFirst();\ngetLast();\nget(int index)"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "title": "Lecture 9 Queue Data Structure",
    "section": "The Queue Interface",
    "text": "The Queue Interface\npublic interface MyQueueInterface&lt;E&gt; {\n    boolean isEmpty(); // returns true if the queue is empty\n    boolean isFull(); // returns true if the queue is full\n\n    void enqueue(E e); // insert the element e at the back of the queue\n    \n    E dequeue(); // remove the element at the front of the queue and return it\n\n    E peek(); // return the element at the front without removing it. \n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Implementing a Queue using a (Circular) Array",
    "text": "Implementing a Queue using a (Circular) Array\n\nWe can implement a queue with a fixed size array and 2 indices head and tail, where\n\nhead = location of the front (first position) of the queue\ntail = location of the open spot at the tail (last position) of the queue\n\nThe enqueue(x) method will append the element x at the tail of the queue.\nHowever, elements dequeued from the front of the array will cause some spaces unused. To solve it, we need to copy the elements to the front of the array, which requires many copy operations.\nThen, to avoid frequently copying arrays to save spaces, we will use a circular array instead.\n\n\n\n\n\n\n\nNote 2: Circular Buffer\n\n\n\nAlso known as circular array or ring buffer, is a data structure that uses an array as if it were connected end-to-end.\n\n\n\nThe circular buffer data structure consists of an array with 2 pointers or indices:\n\nread pointer = the index of the read position in the array\nwrite pointer = the index of the write position in the array\n\nWhen the write (or read) pointer reaches the end of the array/buffer, the write (or read) will wrap around and reset to 0. To achieve the wrap around effect, the read (or write) pointer variables is updated using modulo arithmetic.\n\n// Normal increment operation:\nwrite = wrtie + 1;\nread = read + 1;\n\n// Increatment operation with modulo arithmetic:\nwrite = (write + 1) % buf.length;\n\n// Suppose writhe = 15 and buf.length = 16, then\n// write = (write+1)%buf.length = (15+1)%16 = 16%16 = 0\n\nThe write() operation on a circular buffer will store the data at the write pointer and advance it. The basic implementation of the write() operation (without checking if buffer is full):\n\nvoid write(T e) {\n    buf[write] = e;\n    write = (write + 1) % buf.length;\n}\n\nThe read() operation will return the data at the read pointer and advance it. The basic implementation of the read() operation (without checking if buffer is empty):\n\nT read() {\n    T retVal = but[read];\n    read = (read + 1) % buf.length;\n    return retVal;\n}\n\nHow to tell if a circular buffer if empty or full:\n\nThe circular buffer is not empty when read != write\nThe circular buffer is empty when read == write\nThe circular buffer is not full when read != write\nThe circular buffer is full when read == write. –&gt; This causes problem: this also means empty.\nTo avoid ambiguity, we define the circular buffer to be full when there is 1 empty slot left.\n\nThe implementation of the queue data structure using a circular buffer:\n\npublic class IntegerQueue implements MyQueueInterface&lt;Integer&gt; {\n    private Integer[] buf; // Array of the circular buffer\n    private int read; // read pointer (= head index of queue)\n    private int write; // write pointer (= tail index of queue)\n\n    // Constructor\n    public IntegerQueue(int N) {\n        // Variable of the circular buffer\n        buf = new Integer[N]; // Create new array\n        read = 0; // initialize read pointer\n        write = 0; // initialize write pointer\n    }\n\n    /**\n     * The queue is empty when read pointer == write pointer\n     * @return true if the queue is empty\n     */ \n    public boolean isEmpty() {\n        return read == write;\n    }\n\n    /**\n     * The queue is full when there is one open spot left\n     * @return true if the queue is full\n     */\n    public boolean isFull() {\n        // buffer has 1 open spot\n        // &lt;==&gt; write 1 item into the buffer and it's full\n        return (write + 1) % buf.length == read;\n    } \n\n    public void enqueue(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\"); // or throw exception\n            return;\n        }\n        buf[write] = e;\n        write = (write + 1) % buf.length;\n    }\n\n    public Integer dequeue() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        Integer retVal = buf[read];\n        read = (read + 1) % buf.length;\n        return retVal;\n    }\n\n    public Integer peek() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        return buf[read];\n    }\n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Double Ended (DE) Queue",
    "text": "Other Kinds of Queues - Double Ended (DE) Queue\n\n\n\n\n\n\nNote 3: Double Ended Queue\n\n\n\nA double ended queue is a data structure where we can insert or delete elements from either end\n\nThe operations on a Deque are:\n\naddFirst(x): insert x at the front of the Deque\naddLast(x): insert x at the tail of the Deque\nremoveFirst(x): remove the element at the front of the Deque and return it\nremoveLast(x): remove the element at the tail of the Deque and return it -\n\nA Double Ended Queue can work/operate like a stack. It can also work/operate like a queue."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Priority Queue",
    "text": "Other Kinds of Queues - Priority Queue\n\n\n\n\n\n\nNote 4: Priority Queue\n\n\n\nA priority queue is a data structure where\n\nThe stored data items can be ranked by some field rank in the data\nThe dequeue() operation will always remove the item in the priority queue that has the highest value in the rank field.\n\n\n\n\nThe priority queue is important in time cricical applications:\n\nSelect the next job to run (pick the most urgent one)\nSelect the next patient to treat, etc.\n\nA native implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) must make sure the array is sorted all the time (from large to small)\ndequeue(x) removes the first element in the array\n\nAnother naive implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) insert the element at the end\ndequeue(x) search the array for the largest element and remove it\n\nAn efficient implementation of the priority queue:\n\nThe heat data structure\nA heap is a complete binary tree data structure where the largest value is always stored in the root of the tree."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Use a Queue in Java’s Library",
    "text": "Use a Queue in Java’s Library\n\nUnlike the Stack (which is a class), the Queue is an interface in Java’s library.\nThe Queue interface is implemented by several classes, including\n\nArrayDeque\nPriorityQueue\n\nSome basic methods in the Queue interface:\n\nadd(E e): Inserts the specified element into this queue\nremove(): retrieves and removes the head of this queue\n\nExample:\n\npublic static void main(String[] args) {\n    Queue&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();\n\n    s.add(1);\n    System.out.println(s); // [1]\n    s.add(2);\n    System.out.println(s); // [1, 2]\n\n    System.out.println(s.remove()); // 1\n    System.out.println(s); // [2]\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriente-d Thinking",
    "text": "Object-Oriente-d Thinking\n\nObject-Oriente-d Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriente-d Design methodology when developing the classes.\nThe Object-Oriente-d Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriente-d methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriente-d Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "The protected Modifier and the final Modifier",
    "text": "The protected Modifier and the final Modifier\n\nThe accessibility modifiers indicates the degree of trust (closeness) of program code written by different people.\n\nHighest level of trust: Code inside a class\n2nd highest level of trust: code inside a package\nLowest level of trust: code inside a different package.\nThe protected modifier will allow subclasses inside a different package to access data fields or methods in the superclass.\nSyntax to define a member with protected accessibility:\n\n  protected memberDefinition;\n\nWhere we can access with protected accessibility:\n\nfrom inside a method in the same class (closest association)\nfrom inside a method in the same package (2nd closest association)\nfrom inside a method in a subclass defined outside the package\nbut not from inside a method in an unrelated class defined outside the package\n\n\n\n\n\n\n\n\n\n\n\n\nModifier on Members\nfrom the same class\nfrom the same package\nfrom subclass in different package\nfrom a different package\n\n\n\n\npublic\nOK\nOK\nOK\nOK\n\n\nprotectd\nOK\nOK\nOK\nNo\n\n\ndefault\nOK\nOK\nNo\nNo\n\n\nprivate\nOK\nNo\nNo\nNo\n\n\n\n\nSee TestNewCircle.java and TestNewCircle.java\nA class with the final qualifier cannot be extended (i.e., used as a superclass)\n\n// This class cannot be extended\npublic final class myClass {\n  // data fieds, constrcutors, and methods omitted.\n}\n\nA method with the final qualifier cannot be overridden in a subclass\n\npublic class myClass {\n  // This method cannot be overridden\n  public final void method1() {\n    // Do something,\n  }\n}\n\nSee FinalCircle.java and FinalGeometricObject.java"
  },
  {
    "objectID": "photo.html",
    "href": "photo.html",
    "title": "Photograph",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays: > - For a given search value key, find the index of the first array element that contains the search value key. > - Return -1 when the key is not found in the array.",
    "text": "The Search Problem for Arrays: &gt; - For a given search value key, find the index of the first array element that contains the search value key. &gt; - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays:",
    "text": "The Search Problem for Arrays:\nFor a given search value key, find the index of the first array element that contains the search value key. - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs377.html",
    "href": "notes/cs377.html",
    "title": "CS 377 Database Systems",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n1 The Relational Model\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nRelational Model\n\n\n\nThis lecture discusses the relational model, which is the foundation of modern database systems.\n\n\n\n\n\nAug 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n2 Relational Algebra\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nRelational Model\n\n\nRelational Algebra\n\n\n\nThis lecture discusses the relational algebra, which is the foundation of modern database systems. Topics include select, project, and join operators.\n\n\n\n\n\nSep 8, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n3 SQL Introduction\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\n\nThis note introduces SQL, the Structured Query Language, which is used to interact with databases. We will cover basic queries, the use of *, AS, conditions, and ORDER BY in SQL.\n\n\n\n\n\nSep 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n4 SQL Aggregation\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nAggregation\n\n\n\nThis lecture discusses SQL Aggregation, including computing on a column, GROUP BY, and HAVING clauses.\n\n\n\n\n\nSep 14, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n5 SQL Set Operations\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nSet Operations\n\n\n\nThis lecture discusses SQL set operations, including UNION, INTERSECT, and EXCEPT. It also covers the difference between bag and set semantics in SQL.\n\n\n\n\n\nSep 18, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n6 SQL Join\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJoin\n\n\n\nThis lecture discusses the different types of joins in SQL, including inner, outer, and cross joins. It also covers the dangers of using NATURAL JOIN and the best practices for using joins in SQL.\n\n\n\n\n\nSep 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n9 SQL DDL\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nDDL\n\n\n\nThis lecture discusses Database Modification Language in SQL, including Insert, Delete, Update, and Create operations. It also covers SQL Schemas, Types, Keys, and Foreign Keys.\n\n\n\n\n\nOct 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n10 JDBC\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJava\n\n\nJDBC\n\n\n\nThis lecture discusses how to embed SQL in Java using JDBC. It covers the JDBC API, SQL Injection, and Prepared Statements.\n\n\n\n\n\nOct 30, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n11 ER Design\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nDatabase Design\n\n\nER Design\n\n\n\nThis lecture discusses Entity-Relationship (ER) design, which is a technique for designing databases. It covers the ER model, ER diagrams, and the process of converting ER diagrams to relational schemas.\n\n\n\n\n\nNov 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html",
    "title": "9 SQL DDL",
    "section": "",
    "text": "Two ways to insert tuples, either into an empty or non-empty table: - INSERT INTO &lt;relation&gt; VALUES &lt;list of tuples&gt;; - INSERT INTO &lt;relation&gt; (&lt;subquery&gt;);\n\nCREATE TABLE Invite(\n    name TEXT,\n    campus TEXT DEFAULT 'StG',\n    email TEXT,\n    age INT\n);\n\nINSERT INTO Invite VALUES ('Mark', 'StG', 'm@m.com', 18);\nINSERT INTO Invite(name, email) VALUES ('Mark', 'm@m.com');\n\n-- the order of columns can be controlled for inserts\nINSERT INTO Invite(email, name) VALUES ('m@m.com', 'Mark');\n\nINSERT INTO Invite(name, email) (\n    SELECT firstname, email\n    FROM Student\n    WHERE cgpa &gt; 3.4\n);\n\nNaming attributes in INSERT\n\nSometimes we want to insert tuples, but we don’t have values for all attributes.\nIf we name the attributes we are providing values for, the system will use NULL or a default for the rest.\nConvenient!\n\n-- Insert multiple values\nINSERT INTO Invite VALUES\n  ('Mark', 'StG','m@m.com',18),\n  ('Sasha', 'UTM','s@s.com',19),\n  ('Al','StG','a@a.com',20),\n  ('Link','StG','li@li.com',18);\n\n\n\n\n\nDeletion\n\nDelete tuples satisfying a condition: DELETE FROM &lt;relation&gt; WHERE &lt;condition&gt;;\nDelete all tuples: DELETE FROM &lt;relation&gt;;\n\n-- Delete tough courses where no student has passed…  \nDELETE FROM Course  \n     WHERE NOT EXISTS (  \n     SELECT *  \n     FROM Took JOIN Offering ON Took.oid = Offering.oid  \n     WHERE  \n         grade &gt; 60 AND  \n         Offering.dept = Course.dept AND  \n         Offering.cnum = Course.cnum\n);\n\n\n\n\n\nTo change the value of certain attributes in certain tuples to given values:\n\nUPDATE &lt;relation&gt;\nSET &lt;list of attribute assignments&gt;\nWHERE &lt;condition on tuples&gt;;\n\n\n\n\n\n\nTip 1: Example of UPDATE\n\n\n\n\n\nUPDATE Student\nSET campus = 'UTM'\nWHERE sid = 999999;\n\nUPDATE Took\nSET grade = 50\nWHERE grade &gt;= 47 and grade &lt; 50;\n\n\n\n\n\n\n\n\n\nWarning 1: Inside the SET Clause, Aliases are Not Allowed\n\n\n\nUPDATE StrugglingLabel S\nSET S.label_country = ( -- Illegal!\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n-- The following is legal: \nUPDATE StrugglingLabel S\nSET label_country = ( -- no alias allowed here\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n\n\n\n\nCREATE TABLE &lt;table name&gt; (\n    &lt;column_name1&gt; &lt;data type&gt;,\n    &lt;column_name2&gt; &lt;data type&gt;,\n    &lt;column_name3&gt; &lt;data type&gt;,\n);"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#database-modifications",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#database-modifications",
    "title": "9 SQL DDL",
    "section": "",
    "text": "Two ways to insert tuples, either into an empty or non-empty table: - INSERT INTO &lt;relation&gt; VALUES &lt;list of tuples&gt;; - INSERT INTO &lt;relation&gt; (&lt;subquery&gt;);\n\nCREATE TABLE Invite(\n    name TEXT,\n    campus TEXT DEFAULT 'StG',\n    email TEXT,\n    age INT\n);\n\nINSERT INTO Invite VALUES ('Mark', 'StG', 'm@m.com', 18);\nINSERT INTO Invite(name, email) VALUES ('Mark', 'm@m.com');\n\n-- the order of columns can be controlled for inserts\nINSERT INTO Invite(email, name) VALUES ('m@m.com', 'Mark');\n\nINSERT INTO Invite(name, email) (\n    SELECT firstname, email\n    FROM Student\n    WHERE cgpa &gt; 3.4\n);\n\nNaming attributes in INSERT\n\nSometimes we want to insert tuples, but we don’t have values for all attributes.\nIf we name the attributes we are providing values for, the system will use NULL or a default for the rest.\nConvenient!\n\n-- Insert multiple values\nINSERT INTO Invite VALUES\n  ('Mark', 'StG','m@m.com',18),\n  ('Sasha', 'UTM','s@s.com',19),\n  ('Al','StG','a@a.com',20),\n  ('Link','StG','li@li.com',18);\n\n\n\n\n\nDeletion\n\nDelete tuples satisfying a condition: DELETE FROM &lt;relation&gt; WHERE &lt;condition&gt;;\nDelete all tuples: DELETE FROM &lt;relation&gt;;\n\n-- Delete tough courses where no student has passed…  \nDELETE FROM Course  \n     WHERE NOT EXISTS (  \n     SELECT *  \n     FROM Took JOIN Offering ON Took.oid = Offering.oid  \n     WHERE  \n         grade &gt; 60 AND  \n         Offering.dept = Course.dept AND  \n         Offering.cnum = Course.cnum\n);\n\n\n\n\n\nTo change the value of certain attributes in certain tuples to given values:\n\nUPDATE &lt;relation&gt;\nSET &lt;list of attribute assignments&gt;\nWHERE &lt;condition on tuples&gt;;\n\n\n\n\n\n\nTip 1: Example of UPDATE\n\n\n\n\n\nUPDATE Student\nSET campus = 'UTM'\nWHERE sid = 999999;\n\nUPDATE Took\nSET grade = 50\nWHERE grade &gt;= 47 and grade &lt; 50;\n\n\n\n\n\n\n\n\n\nWarning 1: Inside the SET Clause, Aliases are Not Allowed\n\n\n\nUPDATE StrugglingLabel S\nSET S.label_country = ( -- Illegal!\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n-- The following is legal: \nUPDATE StrugglingLabel S\nSET label_country = ( -- no alias allowed here\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n\n\n\n\nCREATE TABLE &lt;table name&gt; (\n    &lt;column_name1&gt; &lt;data type&gt;,\n    &lt;column_name2&gt; &lt;data type&gt;,\n    &lt;column_name3&gt; &lt;data type&gt;,\n);"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#sql-schemas",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#sql-schemas",
    "title": "9 SQL DDL",
    "section": "SQL Schemas",
    "text": "SQL Schemas\n\nSchema: a kind of namespace\n\nWhen you connect to your psql cloud instance, by default you’re in the public schema\nEverything defined (tables, types, etc.) goes into one big pot.\nSchemas let you create different namespaces.\nUseful for logical organization, and for avoiding name clashes.\n\nYou already have a schema called “public”.\nYou can also create your own.\n\nExample: CREATE SCHEMA University;\n\nTo refer to things inside a particular schema, you can use dot notation:\n\nCREATE TABLE University.Student (...);\nSELECT * FROM University.Student;\n\nThe search path\n\nTo see the current search path: SHOW SEARCH_PATH;\nYou can set the search path yourself.\n\nExample: SET SEARCH_PATH to University, public;"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#types",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#types",
    "title": "9 SQL DDL",
    "section": "Types",
    "text": "Types\n\nTable attributes have types\n\nWhen creating a table, you must define the type of each attribute.\nAnalogous to declaring a variable’s type in a program.\n\nEg, int num; in Java or C.\nSome programming languages don’t require type declarations. Eg, Python.\n\nWhy are type declarations required in SQL?\n\nUsually worth the cost in the world of DB systems, since validity of data is important\n\n\nBuilt-in types\n\nCHAR(n): fixed-length string of n characters. Padded with blanks if necessary.\nVARCHAR(n): variable-length string of up to n characters.\nTEXT: variable-length, unlimited. Not in the SQL standard, but psql and others support it. E.g. 'Macbeth', 'Shakespeare''s Sonnets'\nINT = INTEGER, e.g. 37\nFLOAT = REAL, e.g. 1.49, 37.96e2\nBOOLEAN = TRUE, FALSE\nDATE e.g. '2011-09-22'\nTIME e.g. '15:00:02', '15:00:02.5'\nTIMESTAMP (date plus time), e.g. 'Jan-12-2011 10:25'\n… Documentation\n\nUser-defined types (…in PostgreSQL)\n\nDefined in terms of a built-in type.\nYou make it more specific by defining constraints (and perhaps a default value).\n\n\n\n\n\n\n\n\nTip 2: Example of User-defined Types\n\n\n\n\n\nCREATE DOMAIN Grade AS int\n    DEFAULT null\n    CHECK (VALUE &gt;= 0 AND VALUE &lt;= 100);\n\nCREATE DOMAIN Campus AS varchar(4)\n    DEFAULT 'StG'\n    CHECK (VALUE IN ('StG','UTM','UTSC'));\n\n\n\n\nSemantics of type constraints\n\nConstraints on a type are checked every time a value is assigned to an attribute of that type.\nYou can use these to create a powerful type system.\n\nSemantics of default values\n\nThe default value for a type is used when no value has been specified.\nUseful! You can run a query and insert the resulting tuples into a relation – even if the query does not give values for all attributes.\nTable attributes can also have default values.\n\n\n-- attribute default: for that one attribute in that one table\nCREATE TABLE Awards (\n    sID Integer,\n    numAwards Integer DEFAULT 0,\n    FOREIGN KEY (sID) REFERENCE Student\n);\n\n-- type default: for for every attribute defined to be of that type\nCREATE DOMAIN CGPA AS NUMERIC(10, 2)\n    DEFAULT 0\n    CHECK (VALUE &gt;= 0 AND VALUE &lt;= 4.0)"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#keys-and-foreign-keys",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#keys-and-foreign-keys",
    "title": "9 SQL DDL",
    "section": "Keys and Foreign Keys",
    "text": "Keys and Foreign Keys\n\nKey constraints\n\nDeclaring that a set of one or more attributes are the PRIMARY KEY for a relation means:\n\nthey form a key (unique, minimal)\ntheir values will never be null (you don’t need to separately declare that)\n\nBig hint to the DBMS: optimize for searches by this set of attributes!\nEvery table must have 0 or 1 primary key.\n\nA table can have no primary key, but in practice, every table should have one.\nYou cannot declare more than one primary key. (Think of the PK as the identity of a row..)\n\n\nDeclaring primary keys\n\nFor a single-attribute key, can be part of the attribute definition.\nOr can be at the end of the table definition. (This is the only way for multi-attribute keys.) The brackets are required.\n\n\nCREATE TABLE Blah (\n    ID INTEGER PRIMARY KEY,\n    name VARCHAR(25)\n);\n\nCREATE TABLE Blah (\n    ID INTEGER,\n    name VARCHAR(25),\n    PRIMARY KEY (ID, name)\n);\n\nUniqueness constraints\n\nDeclaring that a set of one or more attributes is UNIQUE for a relation means:\n\nthey form a key\ntheir values can be null; if they mustn’t, you need to separately declare that\n\nYou can declare more than one set of attributes to be UNIQUE.\nUsed to enforce unique constraints on a column (or group of columns) which is not a primary key.\nExample: Make SID primary key, and SSN unique (it’s okay if it’s NULL but if you do have SSN then it must be unique!)\n\nDeclaring UNIQUE\n\nIf only one attribute is involved, can be part of the attribute definition.\nOr can be at the end of the table definition. (This is the only way if multiple attributes are involved.) The brackets are required.\n\n\nCREATE TABLE Blah (\n    ID integer UNIQUE,\n    name varchar(25)\n);\n\nCREATE TABLE Blah (\n    ID integer,\n    name varchar(25),\n    UNIQUE (ID)\n);\n\nWe saw earlier how nulls affect “unique”\n\nFor uniqueness constraints, no two nulls are considered equal.\n\n\n\n\n\n\n\n\nTip 3: Example of UNIQUE\n\n\n\n\n\n\nConsider:\n\nCREATE TABLE Testunique (\n    first VARCHAR(25),\n    last VARCHAR(25),\n    UNIQUE(first, last))\n\nThis would prevent two insertions of ('Stephen', 'Cook')\nBut it would allow two insertions of (null, 'Rackoff')\nThis can’t occur with a primary key because primary key will consider two nulls as equal.\n\n\n\n\n\nForeign key constraints\n\nExample from table Took: FOREIGN KEY (sID) REFERENCES Student\nMeans that attribute sID in this table is a foreign key that references the primary key of table Student.\nEvery value for sID in this table must actually occur in the Student table.\nRequirements:\n\nMust be declared either primary key or unique in the “home” table (i.e. table “Student” in the above example)\n\n\nDeclaring foreign keys\n\nAgain, declare with the attribute (only possible if just a single attribute is involved) or as a separate table element.\nCan reference attribute(s) that are not the primary key as long as they are unique; just name them.\n\n\nCREATE TABLE People (\n    SIN INTEGER PRIMARY KEY,\n    name TEXT,\n    AETNA TEXT UNIQUE\n);\n\nCREATE TABLE Volunteers (\n    email TEXT PRIMARY KEY,\n    AETNAnum text REFERENCES People(AETNA)\n);\n\n-- What if we run the following?\nCREATE TABLE Volunteers (\n    email TEXT PRIMARY KEY,\n    AETNAnum text REFERENCES People -- referring to the primary key by default\n);\n\nEnforcing foreign-key constraints\n\nSuppose there is a foreign-key constraint from relation \\(R\\) to relation \\(S\\).\nHow/when can the DBMS ensure that:\n\nthe referenced attributes are PRIMARY KEY or UNIQUE?\nthe values actually exist?\n\nWhat could cause a violation?\n\nExample: a row is deleted from Course; Offering is now referring to a course that doesn’t exist.\n\nYou get to define what the DBMS should do.\nThis is called specifying a “reaction policy.”"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#reaction-policies",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#reaction-policies",
    "title": "9 SQL DDL",
    "section": "Reaction Policies",
    "text": "Reaction Policies\n\nPossible Politicies\n\nCASCADE: propagate the change to the refering table\n\n\n\n\n\n\n\n\nTip 4: Example of CASCADE\n\n\n\n\n\nif a Student leaves university, delete all their referrals in Took!\n\n\n\n\nSET NULL: set the referring attribute(s) to NULL\nIf you say nothing, the default is to forbid the change in the referred-to table. i.e., RESTRICT\n\n\n\n\n\n\n\nWarning 2: Note the Assymetry\n\n\n\n\nSuppose table T refers to table S.\nYou can define “fixes” that propogate changes backwards from S to T.\n(You define them in table T because it is the table that will be affected)\nYou cannot define fixes that propogate forward from T to S.\n\n\n\n\n\n\n\n\n\nCaution 1: Syntax for Reaction Policies\n\n\n\n\nAdd your reaction policy where you specify the foreign key constraint\nExample:\n\nCREATE TABLE Took {\n    ...\n    FOREIGN KEY (sID) REFERENCES Student ON DELETE CASCADE\n}\n\n\n\nWhat you can react to: Your reaction policy can specify what to do either\n\non delete, i.e., when a deletion creates a dangling reference,\non update, i.e., when an update creates a dangling reference,\nor both. Just put them one after the other.\n\n\n\n\n\n\n\n\nTip 5: Example of What We Can React to\n\n\n\n\n\nON DELETE RESTRICT \nON UPDATE CASCADE\n\n\n\n\nWhat your reaction can be: Your policy can specify one of these reactions (there are others):\n\nRESTRICT: Don’t allow the deletion/update.\nCASCADE: Make the same deletion/update in the referring tuple.\nSET NULL: Set the corresponding value in the referring tuple to null."
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#removing-schema",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#removing-schema",
    "title": "9 SQL DDL",
    "section": "Removing Schema",
    "text": "Removing Schema\n\nRemoving a schema\n\nEasy: DROP SCHEMA University CASCADE;\n\nCASCADE means everything inside it is dropped too.\n\nTo avoid getting an error message if the schema does not exist, add IF EXISTS.\n\nUsage pattern\n\nYou can use this at the top of every DDL file:\n\nDROP SCHEMA IF EXISTS University CASCADE;\nCREATE SCHEMA University;\nSET search_path TO University;\n\nHelpful during development, when you may want to change the schema, or test queries under different conditions.\n\nUpdating the schema itself\n\nALTER: alter a domain or table or column\n\n-- You can add a column to a table\nALTER TABLE Course\nADD COLUMN numSections INTEGER;\n-- You can drop a column entirely from a table\nALTER TABLE Course\nDROP COLUMN breadth;\n-- You can change the type of a column in a table\nALTER TABLE Course\nALTER COLUMN dept TYPE VARCHAR(40);\n\nDROP: can also be used to remove a domain, table, view, or whole schema\n\nDROP TABLE course;\nHow is that different from this?\n\nDELETE FROM course;\n\nIf you drop a table that is referenced by another table, you must specify CASCADE\nThis removes all referring rows.\n\nCHECK: we’ve seen a check clause on a user-defined domain:\n\nCREATE DOMAIN Grade AS as smallint\n  DEFAULT NULL\n  CHECK (VALUE &gt;=0 AND VALUE &lt;=100);\n\nYou can also define a check constraint:\n\non an attribute\non the tuples of a relation\nacross relations\n\nAttribute-based CHECK constraints\n\nDefined with a single attribute and constrain its value (in every tuple)\nRefer to attributes by attributes by their names (do not use the keyword value)\nChecked when a tuple is inserted into that relation, or its value for that attribute is updated.\n\n\n\n\n\n\n\n\n\nTip 6: Example of Attribute-based CHECK constraints\n\n\n\n\n\nCREATE TABLE GradStudent (\n    sID INTEGER,\n    program VARCHAR(3) CHECK\n        (program IN ('MS', 'PhD')),\n    firstName VARCHAR(15) NOT NULL, ...);\n\n\n\n- `NOT NULL`constraint: \n  - You can declare that an attribute of a table is `NOT NULL`.\nCREATE TABLE Course (\n    cNum INTEGER,\n    name VARCHAR(40) NOT NULL,\n    dept Department,\n    breadth BOOLEAN,\n    PRIMARY KEY (cNum, dept));\n- In practise, many attributes should be not null.\n- This is a very specific kind of attribute-based constraint.\n\nTuple-based `CHECK constraints\n\nDefined as a separate element of the table schema so can refer to any attributes of the table.\nChecked when a tuple is inserted into that relation, or updated.\n\n\n\n\n\n\n\n\nTip 7: Example of Tuple-based CHECK constraints\n\n\n\n\n\nCREATE TABLE Student (\n    sID INTEGER,\n    age INTEGER,\n    year INTEGER,\n    college VARCHAR(4),\n        CHECK (YEAR = age - 18)\n);\n\n\n\n\nHow nulls affect CHECK constraints\n\nA check constraint only fails if it evaluates to FALSE.\nIt is not picky like a WHERE condition.\n\n\n\n\n\n\n\n\nTip 8: Example of How Nulls Affect CHECK Constraints\n\n\n\n\n\nSuppose CHECK (age &gt; 0) | age | Value of condition | CHECK outcome | WHERE outcome | |:—:|:——————-:|:—————:|:—————:| |19 | TRUE| pass| pass| |-5 | FALSE| fail| fail| |NULL | UNKNOWN| pass| fail|\n\n\n\n\n\n\n\n\n\nTip 9: Example of NOT NULL Constraint\n\n\n\n\n\n\nSuppose you created this table:\n\nCREATE TABLE Tester (\n    num INTEGER,\n    word VARCHAR(10),\n        CHECK (num &gt; 5));\n\nIt would allow you to insert (NULL, ‘hello’)\nIf you need to prevent that, use a NOT NULL constraint.\n\nCREATE TABLE Tester (\n    num INTEGER NOT NULL,\n    word VARCHAR(10),\n        CHECK (num &gt; 5));\n\n\n\n\n\n\n\n\n\nWarning 3: Order of Constraints\n\n\n\nOrder of constraints doesn’t matter, and doesn’t dictate the order in which they’re checked"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html",
    "title": "1 The Relational Model",
    "section": "",
    "text": "DB are designed to solve the problem Physical Data Dependence: so, they are physical data independence\n“The three-schema architecture” separates user programs from the physical DB"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#db-systems-to-rescue",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#db-systems-to-rescue",
    "title": "1 The Relational Model",
    "section": "",
    "text": "DB are designed to solve the problem Physical Data Dependence: so, they are physical data independence\n“The three-schema architecture” separates user programs from the physical DB"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#data-model",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#data-model",
    "title": "1 The Relational Model",
    "section": "Data Model",
    "text": "Data Model\n\n\n\n\n\n\nData Model\n\n\n\nEvery DBMS is based on some data model, a notation for describing data, including\n\nThe structure of the data\nConstraints on the content of the data\nOperations on the data\n\n\n\n\n\n\n\n\n\nTip 1: Examples of Data Model\n\n\n\n\n\n\nNetwork & hierarchical data model – of historical interest\nRelational data model\nSemistructured data model"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#relations-schema-instance-and-keys",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#relations-schema-instance-and-keys",
    "title": "1 The Relational Model",
    "section": "Relations: Schema, Instance, and Keys",
    "text": "Relations: Schema, Instance, and Keys\n\n\n\n\n\n\nDomain, Cartesian Product, and Relation (Tables)\n\n\n\nA domain is a set of values.\n\nSuppose \\(D_1,D_2,\\dots,D_n\\) are domains.\n\nThe Cartesian (cross) product \\(D_1\\times D_2\\times\\cdots\\times D_n\\) is the set of all tuples \\(\\langle d_1,d_2,\\dots,d_n\\rangle\\) such that \\(d_1\\in D_1, d_2\\in D_2,\\dots,d_n\\in D_n\\).\nMathematical relation on \\(D_1,\\dots,D_n\\) is a subset of the Cartesian product.\n\nOur database tables are relations, too.\n\n\n\n\n\n\n\n\n\nSchema\n\n\n\nSchema: definition of the structure of the relation.\n\nNotation: \\[\\text{Teams}(\\text{Name},\\text{HomeField},\\text{Coach})\\]\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nInstance: particular data in the relation.\n\nInstance change constantly; schemas rarely.\nExample: Adding a column (attribute) changes the schema as well as the instance\nWhen designing the DB, we should avoid changing schema very frequently because changing schema is expensive.\n\n\n\n\n\n\n\n\n\nMore Definitions\n\n\n\nIn a DB table:\n\nrelation = table itself\nattribute = column (optionally, we can specify that attributes have domains)\ntuple = row\narity = number of attributes (columns)\ncardinality = umber of tuples (rows)\n\n\n\n\nA relation is a set of tuples, which means:\n\nthere can be no duplicate tuples\norder of the tuples does not matter\n\n\n\n\n\n\n\n\nDatabase\n\n\n\nDatabase schema: a set of relation schemas –&gt; no actual data\nDatabase instance: a set of relation instances\n\n\n\n\n\n\n\n\nSuperkeys\n\n\n\nSuperkeys: a set of one or more attributes whose combined values are unique. That is, no two tuples can have the same values on all of these attributes.\n\nBy default, tuples cannot be duplicated. So, the entire tuple is viewed as a superkey. But, we can declare other superkeys. So, every relation have a superkey.\nThere can be multiple superkeys for a relation.\n\n\n\n\n\n\n\n\n\nKeys\n\n\n\nKey: a minimal superkey.\n\nThat is, you may not remove an attribute from a key, and still have a set of attributes whose combined values are unique.\n\n\n\n\n\n\n\n\n\nTip 2: Example\n\n\n\n\n\nA relation called Course, which attributes: department codes, course number, and course name. One tuple might be \\[\\text{Course}\\langle\\text{``cs''},\\text{``377''},\\text{``Introduction to Databases''}\\rangle\\] The superkey for this relation would be the combinations of cs and 377. The entire tuple can also be viewed as a superkey. However, \\(\\langle\\text{``cs''},\\text{``377''}\\rangle\\) is the key.\n\n\n\n\n\n\n\n\n\nTip 3: Example\n\n\n\n\n\nConsider the following relation: \\[\\text{Studnet}\\langle\\text{student\\#},\\text{netID},\\text{surname},\\text{firstname},\\text{gpa}\\rangle.\\] This relation has multiple key: student# or netID can either serve as a key.\n\n\n\n\nWe underline attributes in the schema to indicate that they form a key.\n\nFor example, \\[\\text{Team}\\langle\\underline{\\text{Name},\\text{HomeField}},\\text{Coach}\\rangle\\]\n\nAside: Called “superkey” because it is a superset of some key. (Not necessarily a proper superset.)\nIf a set of attributes is a key for a relation\n\nIt does not mean merely that “there are no duplicates” in particular instance of the relation\nIt means that in principle there cannot be any\n\nOften we have to invent an artificial new attribute to ensure all tuples will be unique.\nA key is a kind of integrity constraint."
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#reference-and-keys",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#reference-and-keys",
    "title": "1 The Relational Model",
    "section": "Reference and Keys",
    "text": "Reference and Keys\n\nRelations often refer to each other.\n\n\n\n\n\n\n\nForeign Key\n\n\n\nIf the referring attribute refers to a key attribute in another table, it is called a foreign key.\n\nFor example, in table Roles, the attribute aID refers to the key aID in the Artists table, we write \\(\\text{Roles}[\\text{aID}]\\subseteq\\text{Artists}[\\text{aID}]\\).\nMore generally, we use the following notation: \\(R_1[X]\\subseteq R_2[Y]\\).\n\n\n\n\nThis gives us a way to refer to a single tuple in that relation.\nA foreign key may need to have several attributes.\nThe \\(R[A]\\) notation:\n\n\\(R\\) is the relation, and \\(A\\) is a list of attributes in \\(R\\).\n\\(R[A]\\) is the set of all tuples from \\(R\\), but with only the attributes in list \\(A\\).\n\n\n\n\n\n\n\n\nReferential Integrity Constraints\n\n\n\nThese \\(R_1[X]\\subseteq R_2[Y]\\) relationships are called referential integrity constraints or inclusion dependencies.\n\nNot all referential integrity constraints are foreign key constraints.\n\\(R_1[X]\\subseteq R_2[Y]\\) is a foreign key constraint \\(\\iff\\) \\(Y\\) is a key for relation \\(R_2\\).\n\n\n\n\nIntegrity constraints is part of the process: designing a schema\n\nMapping from the real world to a relational schema is surprisingly challenging and interesting.\nTwo important goals:\n\nRepresent the data well.\nAvoid redundancy."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html",
    "title": "2 Relational Algebra",
    "section": "",
    "text": "Operands: Table\nOperators:\n\nchoose only the rows (tuples) you want\n\nchoose only the columns (attributes) you want\ncombine tables\n\nand a few other things.."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#introduction",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#introduction",
    "title": "2 Relational Algebra",
    "section": "",
    "text": "Operands: Table\nOperators:\n\nchoose only the rows (tuples) you want\n\nchoose only the columns (attributes) you want\ncombine tables\n\nand a few other things.."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#select-choose-rows",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#select-choose-rows",
    "title": "2 Relational Algebra",
    "section": "Select: choose rows",
    "text": "Select: choose rows\n\n\n\n\n\n\nNotation: Select\n\n\n\n\\({\\Large\\sigma}_C(R)\\), where\n\n\\(R\\) is the relation/table,\nCondition \\(c\\) is a boolean expression.\n\n\n\n\nIt can use comparison operators and boolean operators\nThe operands are either constants or attributes of R.\nThe result is a relation:\n\nwith the same schema as the operand\n\nbut with only the tuples that satisfy the condition.\n\n\n\n\n\n\n\n\nTip 1: Example: Select\n\n\n\n\n\nTo select all British actors, we can use \\({\\Large\\sigma}_{\\text{nationality}=\\text{``British''}}(\\texttt{Artists})\\). To select all movies from the 1970s, we can use \\({\\Large\\sigma}_{\\text{year}&gt;1969\\text{ and }\\text{year}&lt;1980}(\\texttt{Movies})\\). Instead of using the word “\\(\\text{and}\\),” we can also use the and operator in logic: \\(\\land\\)"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#project-choose-columns",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#project-choose-columns",
    "title": "2 Relational Algebra",
    "section": "Project: choose columns",
    "text": "Project: choose columns\n\n\n\n\n\n\nNotation: Project\n\n\n\n\\({\\Large\\pi}_L(R)\\), where\n\n\\(R\\) is a relation/table,\n\\(L\\) is a subset of the attributes of \\(R\\).\n\n\n\n\nThe result is a relation\n\nwith all the tuples from \\(R\\)\n\nbut with only the attributes in \\(L\\), and in that order.\n\nThe project operator removes duplicates:\n\nThis is due to that we are using the set notation, and so we cannot have duplicate tuples in a table.\n\n\n\n\n\n\n\n\nTip 2: Example: Project\n\n\n\n\n\n\\({\\Large\\pi}_{\\text{director}}(\\texttt{Movies})\\) will result \\(\\{\\text{Kubrick}, \\text{Altman}, \\text{Polanski}, \\text{Lucas}\\}\\) although the original table has \\(7\\) director names.\n\n\n\n\n\n\n\n\n\nTip 3: Example: Combine select and project\n\n\n\n\n\nQ: Write an RA expression to find the names of all directors of movies from the 1970s. A: \\({\\Large\\pi}_{\\text{director}}{\\Large\\sigma}_{\\text{year}&gt;1969\\land\\text{year}&lt;1980}(\\texttt{Movies})\\)\n\nNote that, as we want to find the names of directors, so we will to the project operator as the last step.\nHence, we will do select first, and then project."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#combining-tables",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#combining-tables",
    "title": "2 Relational Algebra",
    "section": "Combining Tables",
    "text": "Combining Tables\n\nCartesian Product: Combine Tables\n\n\n\n\n\n\nNotation: Cartesian Production\n\n\n\n\\(R_1\\times R_2\\), where\n\n\\(R_1\\) and \\(R_2\\) are tables.\n\n\n\n\nThe result is a relation with\n\nevery combination of a tuple from \\(R1\\) concatenated to a tuple from \\(R_2\\)\nIts schema is every attribute from \\(R_1\\) followed by every attribute of \\(R_2\\), in order.\n\nThe number of tuples in \\(R_1\\times R_2\\) is given by \\(|R_1|\\times|R_2|\\), where \\(|R|\\) is the cardinality of \\(R\\).\nIf an attribute occurs in both relations, it occurs twice in the result, prefixed by relation name.\n\n\n\n\n\n\n\nTip 4\n\n\n\n\n\nIn the result of \\(\\texttt{Movie}\\times\\texttt{Roles}\\), we will see \\(\\text{Movies.mID}\\) and \\(\\text{Roles.mID}\\).\n\n\n\n\nHowever, Cartesian product can be inconvenient\n\nIt can introduce nonsense tuples.\nHowever, we can get rid of them with select operators.\n\nDue to this inconvenience, we need join operators.\n\n\n\nNatural Join\n\n\n\n\n\n\nNotation: Natural Join\n\n\n\n\\(R\\bowtie S\\), where\n\n\\(R\\) and \\(S\\) are tables\n\\(\\bowtie\\) is the natural join operator.\n\n\n\n\nThe result is formed by\n\ntaking the Cartesian product,\nselect to ensure equality on attributes that are in both relations (determine by name),\nprojecting to remove duplicate attributes.\n\n\n\n\n\n\n\n\nWarning 1: Properties of Natural Join\n\n\n\n\nCommutativity (although attribute orders may vary): \\[R\\bowtie S=S\\bowtie R\\]\nAssociativity: \\[R\\bowtie(S\\bowtie T)=(R\\bowtie S)\\bowtie T\\]\nWhen writing \\(n\\)-ary joins, brackets are irrelevant. We can just write: \\[R_1\\bowtie R_2\\bowtie\\cdots\\bowtie R_n.\\]\n\n\n\n\nSpecial cases of Natural Join\n\nIf there is not tuple match, natural join will result in the empty set \\(\\emptyset\\).\nNatural join is looking for exact match.\nIf there is no attributes in common, the result will be the Cartesian product of the two relations.\n\nNatural join can over-match\n\nNatural join bases the matching on attribute names.\nWhat if two attributes have the same name, but we don’t want them to have to match?\n\nNatural join can under-match\n\n\nWhat if two attributes don’t have the same name and we do want them to match?\n\n\n\n\n\nTheta Join\n\n\n\n\n\n\nDefinition: Theta Join \\({\\Large\\bowtie}_{\\text{condition}}\\)\n\n\n\n\nRationale: it is easier to check conditions after making the Cartesian production: \\({\\Large\\sigma}_{\\text{condition}}(R\\times S)\\)\nSyntax: \\(R\\ {\\Large\\bowtie}_{\\text{condition}}\\ S\\)\nThe result is the same as Cartesian product (not natural join!) followed by select: \\[R\\ {\\Large\\bowtie}_{\\text{condition}}\\ S={\\Large\\sigma}_{\\text{condition}}(R\\times S)\\]\n\n\n\n\n\nOuter Join\n\nOuter Join keeps all the tuples and adds null values whenever no value exists\nThree variants:\n\nLeft Outer Join: only do this “null padding” for left operand: ⟕\nRight Outer Join: only do this “null padding” for right operand: ⟖\nFull Outer Join: pad other operands: ⟗\n\n\n\n\nCardinality of Some Operators\n\nGiven \\(R_1(X_1)\\) and \\(R_2(X_2)\\), the cardinality (number of tuples) of\n\nCartesian product: \\(|R_1\\times R_2|=|R_1|\\times|R_2|\\)\nNatural join: \\(0\\leq|R_1\\Join R_2|\\leq|R_1|\\times|R_2|\\)\n\nNotice that if the attributes used in a natural join (i.e., the attributes in \\(X_1\\cap X_2\\)) contain a key of \\(R_2\\), then \\[0\\leq|R_1\\Join R_2|\\leq|R_1|\\]\n\nSame applies for left/right outer joins, if and only if the “outer” part is pointint to the table with the non-key attribute."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#composing-larger-expressions",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#composing-larger-expressions",
    "title": "2 Relational Algebra",
    "section": "Composing Larger Expressions",
    "text": "Composing Larger Expressions\n\nAssignment and Rename Operator\n\n\n\n\n\n\nNotation: Assignment\n\n\n\n\\(R\\coloneqq\\text{Expression}\\) or \\(R(A_1,\\dots,A_n)\\coloneqq\\text{Expression}\\)\n\nThe later notation lets us name all the attributes of the new relation\nSometimes, we don’t want the name they would get from Expression\n\\(R\\) must be a temporary variable, not one of the relations in the schema. That is, we are not updating the content of a relation.\n\n\n\n\n\n\n\n\n\nTip 5: Example: Using Assignment\n\n\n\n\n\n\\[\\begin{aligned}\\text{Temp }1&\\coloneqq Q\\times R\\\\\\text{Temp }2&\\coloneqq{\\Large\\sigma}_{a=99}(\\text{Temp }1)\\times S\\\\\\text{Answer}(\\text{part},\\text{price})&\\coloneqq{\\Large\\pi}_{b,c}(\\text{Temp }2)\\end{aligned}\\]\n\nThis is all for readability.\nAssignment helps us break a problem down.\nIt also allows us to change the names of relations (and attributes).\n\n\n\n\n\n\n\n\n\n\nNotation: Rename\n\n\n\n\\({\\Large\\rho}_{R_1}R_2\\) or \\({\\Large\\rho}_{R_1(A_1,\\dots,A_n)}(R_2)\\)\n\nThe later notation lets us rename all the attributes as well as the relation.\n\n\n\n\nEquivalent Notations: \\[R_1(A_1,\\dots,A_n)\\coloneqq R_2\\equiv R_1\\coloneqq{\\Large\\rho}_{R_1(A_1,\\dots,A_n)}(R_2)\\]\n\\(\\rho\\) is useful if we want to rename within an expression.\n\n\n\nSet Operations\n\nBecause relations are sets, we can use set intersection (\\(\\cap\\)), union (\\(\\cup\\)), and difference (\\(-\\)). But only if the operands are relations over the same attributes (in number, name, and order). Schema needs to be identical."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#precedence-of-operators",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#precedence-of-operators",
    "title": "2 Relational Algebra",
    "section": "Precedence of Operators",
    "text": "Precedence of Operators\n\nExpressions can be composed recursively\nParentheses \\(()\\) and precedence rules define the order of evaluation\nPrecedence, from highest to lowest, is:\n\n\\(\\Large{\\sigma,\\ \\pi, \\rho}\\)\n\\(\\Large{\\times,\\ \\Join}\\)\n\\(\\Large{\\cap}\\)\n\\(\\Large{\\cup,\\ -}\\)"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#specific-types-of-query",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#specific-types-of-query",
    "title": "2 Relational Algebra",
    "section": "Specific Types of Query",
    "text": "Specific Types of Query\n\nMax\n\nThe function Max is not directly supported in relational algebra.\nIdea:\n\nPair tuples and find those that are not the max\nThen, subtract from all to find the maxes.\n\nProcedure: \\(S\\) to be the table and we want to find \\(\\max(\\text{GPA})\\)\n\nCreate the pair of tuples: \\({\\Large\\rho}_{S_1}(S)\\times{\\Large\\rho}_{S_2}(S)\\)\nFilter those GPA that is smaller than the other one in each pair: we will left will everything “smaller;” that is, \\(\\max{\\text{GPA}}\\) will not be present. \\[S_3(\\text{GPA})\\coloneqq{\\Large\\pi}_{S_1.\\text{GPA}}{\\Large\\sigma}_{(S_1.\\text{GPA}&lt;S_2.\\text{GPA})}({\\Large\\rho}_{S_1}(S)\\times{\\Large\\rho}_{S_2}(S))\\]\nThen, doing the subtraction, we will get the maximum: \\[\\max(\\text{GPA})={\\Large\\pi}_\\text{GPA}(S)-{\\Large\\pi}_\\text{GPA}(S_3)\\]\n\n\n\n\n\\(k\\) or more\n\nTo write a query about something like “students with two or more classes with grade &gt; 80” we:\n\nMake all combos of \\(k\\) different tuples that satisfy the condition.\n\n\n\n\n\n\n\n\nTip 6: Example: \\(k\\) or more\n\n\n\n\n\n\\[S\\coloneqq{\\Large\\rho_{R_1}}(R)\\times{\\Large\\rho_{R_2}}(R)\\] \\[R_3={\\Large\\sigma}_{(R_1.\\text{sID}=R_2.\\text{sID}\\land R_1.\\text{Class}\\neq R_2.\\text{Class})}(S)\\] \\[{\\Large\\pi}_{\\text{sID}}{\\Large\\sigma}_{(R_1.\\text{Grade}&gt;80\\land R_2.\\text{Grade}&gt;80)}(R_3)\\]\n\n\n\n\n\nExactly \\(k\\)\n\n“\\(k\\) or more” – “\\((k+1)\\) or more”"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#integrity-constraints-via-ra",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#integrity-constraints-via-ra",
    "title": "2 Relational Algebra",
    "section": "Integrity Constraints via RA",
    "text": "Integrity Constraints via RA\n\nIn a schema description, we can express integrity constraints using a relational algebra expression\nWe use the notation\n\n\\(R=\\emptyset\\), or\n\\(R\\subseteq S\\)\n\n\n\n\n\n\n\n\nTip 7: Example: Integrity Constraints\n\n\n\n\n\n\nCourses at the 400-level cannot count for breadth. \\[{\\Large\\sigma}_(400\\leq\\text{cNum}\\leq500)\\land\\text{breadth}(\\text{Course})=\\emptyset\\]\nIn terms when CS 490 is offered, CS 454 must be offered. \\[\\text{CS490Terms}(\\text{term})\\coloneqq{\\Large\\pi}_\\text{term}({\\Large\\sigma}_{(\\text{dept}=\\text{'CS'}\\land\\text{cNum}=490)}(\\text{Offering}))\\]\\[\\text{CS454Terms}(\\text{term})\\coloneqq{\\Large\\pi}_\\text{term}({\\Large\\sigma}_{(\\text{dept}=\\text{'CS'}\\land\\text{cNum}=454)}(\\text{Offering}))\\] \\[\\text{CS490Terms}-\\text{CS454Terms}=\\emptyset\\]"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html",
    "title": "3 SQL Introduction",
    "section": "",
    "text": "RA is procedural\n\nAn RA query itself suggests a procedure for constructing the result (i.e., how one could implement the query).\nWe say that it is procedural\n\nHow good is a RA query?\n\nAny problem has multiple RA solution, and some may be more efficient.\nHowever, we don’t care much about efficiency.\n\nIn a DBMS, queries actually are executed, & efficiency matters!\n\nWhich query execution plan is most efficient depends on the data in the database and what indices you have.\nFortunately, the DBMS optimizes our queries.\nWe can focus on what we want, not how to get it"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#ra-review",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#ra-review",
    "title": "3 SQL Introduction",
    "section": "",
    "text": "RA is procedural\n\nAn RA query itself suggests a procedure for constructing the result (i.e., how one could implement the query).\nWe say that it is procedural\n\nHow good is a RA query?\n\nAny problem has multiple RA solution, and some may be more efficient.\nHowever, we don’t care much about efficiency.\n\nIn a DBMS, queries actually are executed, & efficiency matters!\n\nWhich query execution plan is most efficient depends on the data in the database and what indices you have.\nFortunately, the DBMS optimizes our queries.\nWe can focus on what we want, not how to get it"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#sql-structured-query-language",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#sql-structured-query-language",
    "title": "3 SQL Introduction",
    "section": "SQL: Structured Query Language",
    "text": "SQL: Structured Query Language\n\nTwo sub-parts:\n\nDDL (Data Definition Language): defining schemas.\nDML (Data Manipulation Language): writing queries and modifying the database.\n\n\n\nBasic Queries\nSELECT attributes\nFROM Table\nWHERE &lt;condition&gt;;\n\n\n\n\n\n\nTip 1: Example: Link SQL and RA\n\n\n\n\n\nSELECT name\nFROM Course\nWHERE dept = 'CSC';\nEquiv. to \\({\\Large\\pi}_{\\text{name}}\\left({\\Large\\sigma}_{\\text{dept}=\\text{``csc''}}(\\text{Course})\\right)\\)\n\n\n\n\n\n\n\n\n\nTip 2: Example: , is the Cartesian Product\n\n\n\n\n\nSELECT name\nFROM Course, Offering, Took\nWHERE dept = 'CSC';\nEquiv. to \\({\\Large\\pi}_{\\text{name}}\\left({\\Large\\sigma}_{\\text{dept}=\\text{``csc''}}(\\text{Course}\\times\\text{Offering}\\times\\text{Took})\\right)\\)\n\n\n\n\n\n\n\n\n\nTip 3: Example: Renaming\n\n\n\n\n\nSELECT e.name, d.name\nFROM employee e, department d\nWHERE d.name = 'marketing' AND\n      e.name = 'Horton';\nThis is link \\(\\rho\\) in relational algebra.\nWhy do we need to rename? Can be convenient vs. the longer full names\nSELECT employee.name, department.name\nFROM employee, department\nWHERE department.name = 'marketing' AND\n      employee.name = 'Horton';\n\n\n\n\n\n\n\n\n\nTip 4: Example: Self-Joins\n\n\n\n\n\nNote: Renaming is required fro self joins\nSELECT e1.name, e2.name\nFROM employee e1, employee e2\nWHERE e1.salary &lt; e2.salary\n\n\n\n\n\nUse of *, AS, Conditions, and ORDER BY\n\nUsing * in SELECT clauses\n\nA * in the SELECT clause means “all attributes of this relation”\n\n\n\n\n\n\n\n\nTip 5: Example: Using *\n\n\n\n\n\nSELECT *\nFROM Course\nWHERE dept = 'CSC';\n\n\n\n\nRenaming attributes\n\nUse As &lt;new name&gt; to rename an attribute in the result\n\n\n\n\n\n\n\n\nTip 6: Example: Renaming Attributes\n\n\n\n\n\nSELECT name AS title, dept\nFROM Course\nWHERE breadth;\n\n\n\n\nComplex Conditions in a WHERE\n\nOperators:\n\nComparison operators: =, &lt;&gt; (aka !=), &gt;, &lt;, &gt;=, &lt;=\n\nCombine boolean expressions: AND, OR, NOT\n\n\n\n\n\n\n\n\nTip 7: Example: Conditions\n\n\n\n\n\nSELECT *\nFROM Offering\nWHERE dept = ‘CSC’ AND cnum &gt;= 300;\n\n\n\n\nOrder by\n\nTo put the tuples in order, ORDER BY &lt;attritbue list&gt; [DESC]\nThe default is ascending order; DESC overrides it to force descending order\nYou can order some attributes in ASC order, others in DESC:\nThe attribute list can include expressions, such as ORDER BY sales+rentals\n\n\n\n\n\n\n\n\nTip 8: Example: Multiple ordering\n\n\n\n\n\nSELECT * FROM Course\nORDER BY cnum ASC, dept DESC;\n\n\n\n\nCase-sensitivity and whitespace\n\nselect surName\nfrom Student\nwhere campus = 'StG';\n\nKeywords, like select, are not case-sensitive.\n\nOne convention is to use UPPERCASE for keywords\n\nIdentifiers, like Student are not case-sensitive.\n\none convention is to use lowercase for attributes, and a leading capital letter followed by lowercase for relations\n\nLiteral strings, like 'StG', are case sensitive, and require single quotes.\nWhitespaces (other than inside quotes) is ignored.\n\n\n\nMore on SELECT Clauses\n\nExpression in SELECT clauses\n\nInstead of a simple attribute name, you can use an expression in a SELECT clause.\nOperands: attributes, constants\nOperators: arithmetic ops, string ops\n\n\n\n\n\n\n\n\nTip 9: Example: Expressions in SELECT Clauses\n\n\n\n\n\nNote: || means string concatenation\nSELECT sid, grade-10 as adjusted\nFROM Took;\nSELECT dept| |cnum as fullCourseName\nFROM course;\n\n\n\n\nExpressions that are a constant\n\nSometimes it makes sense for the whole expression to be a constant (something that doesn’t involve any attributes!).\n\n\n\n\n\n\n\n\nTip 10: Example: Constant Expressions\n\n\n\n\n\nSELECT name, \n       ‘satisfies’ AS breadthRequirement\nFROM Course\nWHERE breadth;\n\n\n\n\n\nPattern Operations\n\nTwo ways to compare a string to a pattern by\n\n&lt;attribute&gt; LIKE &lt;pattern&gt;\n&lt;attribute&gt; NOT LIKE &lt;pattern&gt;\n\nPattern is a quoted string\n\n% means: any string (0 or more)\n_ means: any single character\n\n\nSELECT *\nFROM Course\nWHERE name LIKE = '%Comp%';\n\nMore examples:\n\n... WHERE phone LIKE '268_ _ _ _ _ _'\n\nphone numbers with area code 268\n\n... WHERE Dictionary.entry NOT LIKE '%est'\n\nIgnore ‘biggest’, ‘tallest’, ‘fastest’, ‘rest’, … (i.e., ignore any strings ends with ‘est’)\nNote: ‘est’ itself is also ignored.\n\n... WHERE sales LIKE '%30!%%' ESCAPE '!'\n\nSales of 30%\nNote: PostgreSQL allows you to define your own ESCAPE\nThe thing after the ESCAPE character should be treated as a normal string (not a special character)."
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html",
    "title": "4 SQL Aggregation",
    "section": "",
    "text": "Computing on a column\n\nWe often want to compute something across the values in a column\nSUM, AVG, MIN, and MAX\nWe can also count the number of tuples (rows) by using COUNT(*)\n\n\nSELECT *\nFROM Took;\n\nSELECT grade\nFROM Took;\n\nSELECT AVG(grade)\nFROM Took;\n\nSELECT AVG(grade) AS myAVG /* It is recommend to always rename */\nFROM Took;\n\n/* One can combine multiple aggregations */\nSELECT MAX(grade), AVG(grade), COUNT(*), MIN(sID)\nFROM Took;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#aggregation",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#aggregation",
    "title": "4 SQL Aggregation",
    "section": "",
    "text": "Computing on a column\n\nWe often want to compute something across the values in a column\nSUM, AVG, MIN, and MAX\nWe can also count the number of tuples (rows) by using COUNT(*)\n\n\nSELECT *\nFROM Took;\n\nSELECT grade\nFROM Took;\n\nSELECT AVG(grade)\nFROM Took;\n\nSELECT AVG(grade) AS myAVG /* It is recommend to always rename */\nFROM Took;\n\n/* One can combine multiple aggregations */\nSELECT MAX(grade), AVG(grade), COUNT(*), MIN(sID)\nFROM Took;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#group-by",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#group-by",
    "title": "4 SQL Aggregation",
    "section": "GROUP BY",
    "text": "GROUP BY\n\nIf we follow a SELECT-FROM-WHERE expression with GROUP BY &lt;attributes&gt;\n\nThe rows are grouped together according to the values of those attributes, and\nany aggregations is applied only within each group\n\n\nSELECT oID, AVG(grade) AS offAvg\nFROM Took\nGROUP BY oID;\n\nNote: SELECT cannot include un-aggregated columns\n\n/* The following will produce an error */\nSELECT oID, AVG(grade) AS offAvg, sID\nFROM Took\nGROUP BY oID;\n\nRestrictions on Aggregation:\n\nIf any aggregation is used, then each element of the SELECT list must be either\n\naggregated, or\nan attribute on the GROUP BY list."
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#having",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#having",
    "title": "4 SQL Aggregation",
    "section": "HAVING",
    "text": "HAVING\n\nSometimes, we want to keep some groups and eliminate others from our result set.\nWHERE let us decide which tuples to keep - performed before the grouping\nHAVING decides which groups to keep - performed after the grouping\n\n...\nGROUP BY &lt;attributes&gt;\nHAVING &lt;condition&gt;\n\nOnly groups satisfying the condition are kept.\nRequirements on HAVING clauses:\n\nOutside subqueries, HAVING may refer to attributes only if they are either:\n\naggregated, or\nan attribute on the GROUP BY list\n\nThis requirement is the same as SELECT clause.\n\n\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nGROUP BY oID\nHAVING AVG(grade) &gt; 80; \n/* Cannot use offAvg here. HAVING is executed before SELECT*/\n\n/* The following two queries are WRONG / produce undesired results */\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nGROUP BY oID\nWHERE AVG(grade) &gt; 80; /* Incorrect! */\n\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nWHERE AVG(grade) &gt; 80 /* Incorrect! */\nGROUP BY oID;\n\n/* Another HAVING example */\nSELECT oID, avg(grade) as offAvg\nGROUP BY oID\nHAVING oID &lt;= 5\nORDER BY oID;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#order-of-execution-of-a-sql-query",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#order-of-execution-of-a-sql-query",
    "title": "4 SQL Aggregation",
    "section": "Order of Execution of a SQL Query",
    "text": "Order of Execution of a SQL Query\n\n\n\nQuery Order\nExecution Order\n\n\n\n\nSELECT\nFROM\n\n\nFROM\nWHERE\n\n\nWHERE\nGROUP BY\n\n\nGROUP BY\nHAVING\n\n\nHAVING\nSELECT\n\n\nORDER BY\nORDER BY\n\n\n\n\nHowever, note that we can order by a column even if it is not selected.\n\n/* The following query is legal. */\nSELECT sID\nFROM Took\nGROUP BY sID\nHAVING AVG(grade) &gt; 80\nORDER BY AVG(grade)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#duplicates-in-sql",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#duplicates-in-sql",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#views",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#views",
    "title": "5 SQL Set Operations",
    "section": "Views",
    "text": "Views\n\nThe idea\n\nA view is a relation defined in terms of stored tables (called base tables) and possibly also other views.\nAccess a view like any base table.\nTwo kinds of view:\n\nVirtual: no tuples are stored; view is just a query for constructing the relation when needed.\nMaterialized: actually constructed and stored. Expensive to maintain.\n\nViews are particularly important when you want to give different access rights (i.e. permissions) to different users viewing data in your tables!\n\n\n\n\n\n\n\nTip 5: Example: Application of Views\n\n\n\n\n\nCanvas student page vs. instructor page\n\n\n\n\n\n\n\n\n\nTip 6: Example: Creating a View\n\n\n\n\n\n\nA view for students who earned an 80 or higher in a CSC course:\n\nCREATE VIEW topresults AS\n    SELECT firstname, surname, cnum\n    FROM Student, Took, Offering\n    WHERE\n        Student.sid = Took.sid AND\n        Took.oid = Offering.oid AND\n        grade &gt;= 80 AND dept = 'CSC';\n\n\n\n\n\nUses of Views\n\nBreak down a large query\nProvide another way of looking at the same data, e.g. for one category of user\nWrap commonly used complex queries"
  },
  {
    "objectID": "notes/cs377/06-sql-join/06 SQL Join.html",
    "href": "notes/cs377/06-sql-join/06 SQL Join.html",
    "title": "6 SQL Join",
    "section": "",
    "text": "Expression within SQL\nMeaning in RA\n\n\n\n\nR, S\n\\[R\\times S\\]\n\n\nR CROSS JOIN S\n\\[R\\times S\\]\n\n\nR NATURAL JOIN S\n\\[R\\bowtie S\\]\n\n\nR JOIN S ON &lt;condition&gt;\n\\[R\\bowtie_\\texttt{condition} S\\]\n\n\nR NATURAL LEFT [OUTER] JOIN S\n\\[R⟕S\\]\n\n\nR NATURAL RIGHT [OUTER] JOIN S\n\\[R⟖S\\]\n\n\nR NATURAL FULL [OUTER] JOIN S\n\\[R⟗S\\]\n\n\nR LEFT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟕_\\texttt{condition}S\\]\n\n\nR RIGHT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟖_\\texttt{condition}S\\]\n\n\nR FULL [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟗_\\texttt{condition}S\\]\n\n\n\n\nIf your query includes left/right/full, adding OUTER is optional\nIf your outer join is not natural, then adding on &lt;condition&gt;becomes necessary\n\n\n\n\nAttributes with matching names don’t necessarily mean matching meanings!\nHaving implicit comparisons impairs readability.\nAlso: if the schema changed, a query that looks fine may actually be broken, without being able to tell.\nBest practice: Don’t over-use NUATURAL JOIN.\n\n\n\n\n\nWe get an OUTER join iff you use the keywords LEFT, RIGHT, or FULL.\nIf you don’t use the keywords LEFT, RIGHT, or FULL you get an INNER join."
  },
  {
    "objectID": "notes/cs377/06-sql-join/06 SQL Join.html#the-joins-we-know-from-ra",
    "href": "notes/cs377/06-sql-join/06 SQL Join.html#the-joins-we-know-from-ra",
    "title": "6 SQL Join",
    "section": "",
    "text": "Expression within SQL\nMeaning in RA\n\n\n\n\nR, S\n\\[R\\times S\\]\n\n\nR CROSS JOIN S\n\\[R\\times S\\]\n\n\nR NATURAL JOIN S\n\\[R\\bowtie S\\]\n\n\nR JOIN S ON &lt;condition&gt;\n\\[R\\bowtie_\\texttt{condition} S\\]\n\n\nR NATURAL LEFT [OUTER] JOIN S\n\\[R⟕S\\]\n\n\nR NATURAL RIGHT [OUTER] JOIN S\n\\[R⟖S\\]\n\n\nR NATURAL FULL [OUTER] JOIN S\n\\[R⟗S\\]\n\n\nR LEFT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟕_\\texttt{condition}S\\]\n\n\nR RIGHT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟖_\\texttt{condition}S\\]\n\n\nR FULL [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟗_\\texttt{condition}S\\]\n\n\n\n\nIf your query includes left/right/full, adding OUTER is optional\nIf your outer join is not natural, then adding on &lt;condition&gt;becomes necessary\n\n\n\n\nAttributes with matching names don’t necessarily mean matching meanings!\nHaving implicit comparisons impairs readability.\nAlso: if the schema changed, a query that looks fine may actually be broken, without being able to tell.\nBest practice: Don’t over-use NUATURAL JOIN.\n\n\n\n\n\nWe get an OUTER join iff you use the keywords LEFT, RIGHT, or FULL.\nIf you don’t use the keywords LEFT, RIGHT, or FULL you get an INNER join."
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Loop Analysis",
    "text": "Loop Analysis\n\n\n\n\n\n\nTip 7: Example: Loop Analysis 1\n\n\n\n\n\nfor (int i = 0; i &lt; 10; i++) {\n    doPrimitive();\n}\n\nThe loop is executed \\(10\\) times for any input size.\nRunning time \\(=10\\) operations.\nRun time complexity \\(=\\mathcal{O}(1)\\implies\\) constant time.\n\n\n\n\n\n\n\n\n\n\nTip 8: Example: Loop Analysis 2\n\n\n\n\n\nn = input size;  // (e.g.: # elements in an array)\nfor (int i = 0; i &lt; n; i++) {\n    doPrimitive();\n}\n\nThe loop is executed \\(n\\) times for an input size of \\(n\\).\nRunning time \\(=n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nNotation Remark\n\n\n\n\\(n\\) or \\(N\\) will always denote the input size in algorithm analysis.\n\n\n\n\n\n\n\n\nTip 9: Example: Loop Analysis 3\n\n\n\n\n\nint sum = 0;\nfor (int i = 0; i &lt; 5*n; i = i + 4) {\n    sum = sum + 1;\n}\n\nThe loop is executed \\(\\frac{5}{4}n\\) times for an input size of \\(n\\).\nRunning time \\(=\\frac{5}{4}n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nTip 10: Example: Loop Analysis 4\n\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt; 0; i = i - 4) {\n    sum = sum + 1;\n}\n\nThe loop is executed \\(\\frac{1}{4}n\\) times for an input size of \\(n\\).\nRunning time \\(=\\frac{1}{4}n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nTip 11: Example: Loop Analysis 5\n\n\n\n\n\nint sum = 0;\nfor (int i = 1; i &lt;= n; i = 2*i) {\n    sum++;\n}\n\n\\(i\\) will take the following numbers in the loop \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\]\nLoop will exists when \\(i&gt;n\\): \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\quad n\\]\nSuppose \\(2^{k-1}\\leq n\\leq 2^k\\) \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\quad2^{k-1}\\quad n\\quad2^{k}\\]\nIterations: \\(k\\approx\\log{n}\\). So, \\(\\mathcal{O}(\\log{n})\\). (\\(n\\approx2^{k}\\Longleftrightarrow k\\approx\\log(n)\\))\n\n\n\n\n\n\n\n\n\n\nTip 12: Example: Loop Analysis 6\n\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt;= 1; i = i/2) {\n    sum++;\n}\n\n\\(i\\) will take the following numbers in the loop \\[n\\quad n/2\\quad n/4\\quad\\cdots\\quad1\\]\nLoop will exists when \\(i&lt;1\\).\nSuppose \\(n/2^{k}&lt;1&lt;n/2^{k-1}\\). \\[n\\quad n/2\\quad n/4\\quad\\cdots\\quad n/2^{k-1}\\quad1\\quad n/2^{k}\\]\nIterations \\(k\\approx\\log{n}\\). So, \\(\\mathcal{O}(\\log{n})\\) (\\(n/2^k\\approx1\\implies n\\approx2^k\\implies k\\approx\\log{n}\\))\n\n\n\n\n\n\n\n\n\n\nTip 13: Example: Loop Analysis 7\n\n\n\n\n\nint sum = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt;= i; j++) {\n        sum++;\n    }\n}\n\n\n\n\\(i\\)\n0\n2\n3\n4\n\\(\\cdots\\)\n\\(n-1\\)\n\n\n\n\n\\(j\\)\n*\n*\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n*\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n\n\n\\(\\vdots\\)\n*\n\n\n\n\n\n\n\n\n*\n\n\n\n\nWe sum up those starts. That is adding from \\(1\\) to \\(n\\).\nIterations \\(=\\dfrac{n(n+1)}{2}\\). So, \\(\\mathcal{O}(n^2)\\).\n\n\n\n\n\n\n\n\n\n\nTip 14: Example: Loop Analysis 8\n\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt; 0; i = i/2) {\n    for (int j = 0; j &lt; i; j++) {\n        sum++;\n    }\n}\n\n\n\n\\(i\\)\nn\nn/2\nn/4\nn/8\n\\(\\cdots\\)\n1\n\n\n\n\n\\(j\\)\n*\n*\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n*\n*\n*\n*\n\\(\\cdots\\)\n\n\n\n\n*\n*\n*\n*\n\n\n\n\n\n*\n*\n*\n\n\n\n\n\n\n*\n*\n\n\n\n\n\n\n\n*\n\n\n\n\n\n\n\n\n\nIn total, we have \\(\\log{n}\\) \\(i\\)’s. We add up those starts. That is, \\(n+n/2+n/4+n/8+\\cdots+1\\).\nBy Geometric sum, we have Iteration = \\(n(1+1/2+1/4+\\cdots+1/n)\\approx n(2)=2n\\).\nSo, \\(\\mathcal{O}(n)\\).\n\n\n\n\n\n\n\n\n\n\nTip 15: Example: Loop Analysis 9\n\n\n\n\n\nint sum = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 0; j &lt; n; j = j + i) {\n        sum++;\n    }\n}\n\n\n\n\\(i\\)\n1\n2\n3\n4\n\\(\\cdots\\)\nn\n\n\n\n\n\\(j\\)\n0\n0\n0\n0\n\\(\\cdots\\)\n0\n\n\n\n1\n2\n3\n4\n\\(\\cdots\\)\n\n\n\n\n2\n4\n6\n8\n\n\n\n\n\n3\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\n\n\n4\n\\(n-1\\)\n\\(n-1\\)\n\\(n-1\\)\n\n\n\n\n\n\\(\\vdots\\)\n\n\n\n\n\n\n\n\n\\(n-1\\)\n\n\n\n\n\n\n\n\n\nWhen \\(i=1\\), we iterate \\(j\\) for \\(n\\) times. When \\(i=2\\), we iterate \\(j\\) for \\(n/2\\) times. For an arbitrary \\(i\\), we iterate \\(j\\) for \\(n/i\\) times.\nSo, iteration = \\(n+n/2+n/3+\\cdots+n/n=n(1+1/2+1/3+\\cdots+1/n)\\approx n\\log(n)\\) by the harmonic series. So, \\(\\mathcal{O}(n\\log{n})\\)."
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html",
    "href": "notes/cs377/10-JDBC/10 JDBC.html",
    "title": "10 JDBC",
    "section": "",
    "text": "Load the driver and register it with the driver manager (download the driver .jar file)\nConnect toe database\nCreate a statement object\nExecute a query and retrieve the results, or make changes to the database\nDisconnect from the database\n\nimport java.sql.*; // API for accessing and processing DB datqa\n\npublic class JDBCTest {\n  public static void main(String args[]) {\n    try {\n      // Load the driver\n      Class.forName(\"org.postgresql.Driver\");\n      // Connect to the database\n      Connection conn = DriverManager.getConnection(\"jdbc:postgresql://localhost:5433/\", \"postgres\", \"postgres\")\n      \n      // Create a statement object\n      Statement stmt = conn.createStatement();\n\n      // Execute a query and retrieve the results\n      ResultSet rs = stmt.executeQuery(\"SELECT * FROM mytable\");\n\n      // Process the results\n      while ( rs.next() ) {\n        System.out.println(rs.getString(\"name\"));\n      }\n      rs.close();\n\n      // Disconnect from the database\n      stmt.close();\n      conn.close();\n    }\n    // Handle exceptions\n    catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n\nArguments to getConnection:\n\njdbc:postgresql: indicates the driver to use PostgreSQL\nlocalhost:5433/:\n\nHost address: port number\nUse localhost to indicate that we are running the Java application on same server as the database\n\nusername\npassword\nWe can also specify the schema we want to connect:\n\nurl = jdbc:postgresql://localhost:5433/postgres?currentSchema=mySchema\nAlternatively, we can use conn.setSchema(\"mySchema\").\n\n\nResultSet:\n\nrs.next(): moves the cursor to the next row\nrs.getString(\"name\"): retrieves the value of the column name in the current row\n\nIf the tuple also contains other data types, we can use rs.getInt(\"age\"), rs.getDouble(\"salary\"), etc.\n\nrs.close(): closes the result set\n\nExceptions can occur when:\n\nThe driver is not found\nThe connection fails\nThe query fails\nThe result set is not closed"
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#jdbc-steps",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#jdbc-steps",
    "title": "10 JDBC",
    "section": "",
    "text": "Load the driver and register it with the driver manager (download the driver .jar file)\nConnect toe database\nCreate a statement object\nExecute a query and retrieve the results, or make changes to the database\nDisconnect from the database\n\nimport java.sql.*; // API for accessing and processing DB datqa\n\npublic class JDBCTest {\n  public static void main(String args[]) {\n    try {\n      // Load the driver\n      Class.forName(\"org.postgresql.Driver\");\n      // Connect to the database\n      Connection conn = DriverManager.getConnection(\"jdbc:postgresql://localhost:5433/\", \"postgres\", \"postgres\")\n      \n      // Create a statement object\n      Statement stmt = conn.createStatement();\n\n      // Execute a query and retrieve the results\n      ResultSet rs = stmt.executeQuery(\"SELECT * FROM mytable\");\n\n      // Process the results\n      while ( rs.next() ) {\n        System.out.println(rs.getString(\"name\"));\n      }\n      rs.close();\n\n      // Disconnect from the database\n      stmt.close();\n      conn.close();\n    }\n    // Handle exceptions\n    catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n\nArguments to getConnection:\n\njdbc:postgresql: indicates the driver to use PostgreSQL\nlocalhost:5433/:\n\nHost address: port number\nUse localhost to indicate that we are running the Java application on same server as the database\n\nusername\npassword\nWe can also specify the schema we want to connect:\n\nurl = jdbc:postgresql://localhost:5433/postgres?currentSchema=mySchema\nAlternatively, we can use conn.setSchema(\"mySchema\").\n\n\nResultSet:\n\nrs.next(): moves the cursor to the next row\nrs.getString(\"name\"): retrieves the value of the column name in the current row\n\nIf the tuple also contains other data types, we can use rs.getInt(\"age\"), rs.getDouble(\"salary\"), etc.\n\nrs.close(): closes the result set\n\nExceptions can occur when:\n\nThe driver is not found\nThe connection fails\nThe query fails\nThe result set is not closed"
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#prepared-statements",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#prepared-statements",
    "title": "10 JDBC",
    "section": "Prepared Statements",
    "text": "Prepared Statements\n\nPreparing a statement includes parsing the SQL, compiling and optimizing it.\nThe resulting PreparedStatement object can be executed any number of times wihtout having to repeat these steps.\n\nJava Documentation\n\nIf the query isn’t know until run time:\n\nYou may need input and computation to determine the query.\nYou can hard-code the parts you know, and use ? as a placeholder for the values you don’t know.\nThis is enough to allow a PreparedStatement to be constructed.\nOnece you know values fro the placeholders, methods setInt, setString, etc. can be used to set the values.\n\n\n\n\n\n\n\n\nTip 1: Example of Using Placeholders\n\n\n\n\n\n  PreparedStatement studioStat = \n    conn.preparedStatement(\n      \"INSERT INTO STUDIO(name, address)\n      VALUES(?, ?)\"\n    );\n  \n  /* OMITTED: Get values for studioName and StudioAddr*/\n  studioStat.setString(1, studioName);\n  studioStat.setString(2, studioAddr);\n  studioStat.executeUpdate();\n\n\n\n\n\n\n\n\n\nWarning 1: Why not just build the query in a string?\n\n\n\n\nWe constructed an incomplete preparedStatement and filled in the missing values using method calls.\nInstead, we could just build up the query in an ordinary string at run time, and ask to execute that.\nThere are classes and methods that will do this in JDBC.\nBut never use that approach because it is vulnerable to injections: insertion of strings into a query with malicious intent.\nAlways use a preparedStatement instead!\n\n\n\n\nAdvantages of a prepared statement\n\nPreformance: it is pre-complied. DB server prepares an execution plane once and caches it (before execution).\nSecurity: it is a good way to protect against SQL injection.\n\n\n\n\n\n\n\n\nTip 2: Example with createStatement\n\n\n\n\n\n  Statement stat = conn.createStatement();\n  String query = \n    \"SELECT networth\n    FROM MovieExec\n    WHERE execName LIKE '%Spielberg%'\n    \";\n  ResultSet worth = stat.executeQuery(query);\n\n\n\n\n\n\n\n\n\nTip 3: Example of SQL Injection\n\n\n\n\n\n\nSuppose we want the user to provide the string to compare to.\nWe did this by allowing user input to be concatenated into the query string.\n\n  Statement stat = conn.createStatement();\n  String who = /* User input */\n  String query = \n    \"SELECT networth\n    FROM MovieExec\n    WHERE execName LIKE '%\" + who + \"%'\n    \";\n\n  ResultSet worths = stat.executeQuery(query);\n\nA gentle user does not harm might enter Cameron, making the query:\n\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Cameron%'\n\nNothing bad happens.\nHowever, an injection can exploit the vulnerability: if the user enters Milch%'; DROP TABLE Contracts; --, the query becomes:\n\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Milch%'; DROP TABLE Contracts; --%'\n\n-- Equivalent to:\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Milch%';\n\nDROP TABLE Contracts; --%';\n\nAll the contracts table will be dropped.\nThis is a SQL Injection.\n\n\n\n\n\nQueries vs. updates in JDBC\nexecuteQuery is used for queries that return a result set.The previous examples used executeQuery.\nThis method is only for pure queries.\nFor SQL statements that change the database (insert, delete, or modify tuples, or change the schema), use the analogous executeUpdate method."
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#example-of-using-placeholders",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#example-of-using-placeholders",
    "title": "10 JDBC",
    "section": "Example of Using Placeholders",
    "text": "Example of Using Placeholders\n  PreparedStatement studioStat = \n    conn.preparedStatement(\n      \"INSERT INTO STUDIO(name, address)\n      VALUES(?, ?)\"\n    );\n  \n  /* OMITTED: Get values for studioName and StudioAddr*/\n  studioStat.setString(1, studioName);\n  studioStat.setString(2, studioAddr);\n  studioStat.executeUpdate();"
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html",
    "href": "notes/cs377/11-er-design/11 ER Design.html",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-er-design",
    "href": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-er-design",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-database-design",
    "href": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-database-design",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#the-entityrelationship-er-model",
    "href": "notes/cs377/11-er-design/11 ER Design.html#the-entityrelationship-er-model",
    "title": "11 ER Design",
    "section": "The Entity/Relationship (E/R) Model",
    "text": "The Entity/Relationship (E/R) Model\n\nOverview:\n\nUsing the E/R model to model the real world.\nFrom there, designing a database schema:\n\nReconstructuring of an E/R model\nTranslating an E/R model into a logical model (DB schema)\n\nE/R model is a Visual data model (diagram-based):\n\nQuickly “chart out” a databse design\nEasier to “see” big picture\nComparable to class diagrams in UML\n\nBasic concept: entities and their relationships along with attributes describing them.\n\n\n\n\n\n\n\n\nNote 1: Entity Set: (Represented by a rectangle \\(\\Huge{\\boxed{\\ \\ }}\\))\n\n\n\n\nAn entity set represents a category of objects that have properties in common and an autonomous existence.\n\nE.g., City, Department, Employee, Sale\n\nAn entity is an instance of an entity set.\n\nE.g., “San Francisco” is an entity in the City entity set.\n\n\n\n\n\n\n\n\n\n\nNote 2: Relationship Sets: (Represented by a diamond \\(\\Huge{\\diamond}\\))\n\n\n\n\nA relationship set is an association between two or more entity sets.\n\nE.g., Residence is an relationship set between entity sets City and Employee.\n\nA relationship is an instance of a n-ary relationship set.\n\nE.g., the pairt (“San Francisco”, “John”) is an instance of relationship Residence.\n\n\n\n\n\nRecursive Relationships\n\nRecursive relationsihps relate an entity to itself.\nNote, sometimes, relationship is not symmetric.\n\nIn this case, we need to indicate the two roles that the entity plas in the relationship.\nE.g., “Sovereign” is a recurvie relationship of “Succession.” However, the two rols are “Predecessor” and “Successor”.\n\n\nTernary Relationships\n\nTernary relationships relate three entity sets.\nE.g., “Supply” is a ternary relationship between “Supplier”, “Product”, and “Department.”\n\n\n\n\n\n\n\n\nNote 3: Attributes: (Represented by an oval \\(\\Huge{\\circ}\\))\n\n\n\n\nAn attribute describes elementary properties of entities or relationships.\n\nE.g., “Name” is an attribute of the entity set “City.”\n\nAttributes may be single-valued or multi-valued.\nComposite attributes are grouped attributes of the same entity or relationship that have closed connected meaning or uses.\n\nE.g., “Address” is a composite attribute of the entity set “City.” “Address” can be further decomposed into “Street,” “City,” “State,” and “Zip.”\n\n\n\n\n\n\n\n\n\n\nNote 4: Cardinalities\n\n\n\n\nEach entity set participates in a relationship set with a minimum (min) and a maximum (max) cardinality.\nCardinalities constrain how entity instances participate in relationship instances.\nGraphically, cardinalities are represented by lines connecting entities to relationships.\n\n\n\n\n\n\nflowchart LR\n    A[Employee]---|\"(1,5)\"|B{Assignment}---|\"(0, 50)\"|C[Task]\n\n\n\n\n\n\n\nNote: an entity might not participate in any relationship.\nIn principle, cardinalities are pairs of non-negative integers \\((n,N)\\) such that \\(n\\leq N\\), where \\(N\\) means any number.\nMinimum cardinality \\(n\\):\n\nIf \\(0\\), entity participation in a relationship is optional.\nIf \\(1\\), entity participation in a relationship is rmandatory.\n\nMaximum cardinality \\(N\\):\n\nIf \\(1\\), each instance of the entity is associated with at most one instance of the relationship.\nIf \\(N\\), each instance of the entity is associated with many instances of the relationship.\n\n\n\n\n\nExamples of Cardinalities\n\n\n\n\n\n\nflowchart LR\n    A[Tourist]---|\"(1,N)\"|B{Reservation}---|\"(0, N)\"|C[Voyage]\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[Order]---|\"(0,1)\"|B{Sale}---|\"(1, 1)\"|V[Invoice]\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[Person]---|\"(1,1)\"|B{Residence}---|\"(0, N)\"|C[City]\n\n\n\n\n\n\n\nMultiplicity of Relationships\n\nIf entities \\(E_1\\) and \\(E_2\\) participate in relationship \\(R\\) with cardinalities \\((n_1,N_1)\\) and \\((n_2,N_2)\\), then the multiplicity of \\(R\\) is \\(N_1\\)-to-\\(N_2\\) (which is the same as \\(N_2\\)-to-\\(N_1\\)).\nExamples:\n\n\\(1\\)-to-\\(1\\)\n\\(1\\)-to-\\(N\\) or \\(N\\)-to-\\(1\\)\n\\(N\\)-to-\\(N\\)\n\n\nCardinalities of Attributes\n\nDescribe min/max number of values an attribute can have.\nWhen the cardinality of an attribute is \\((1,1)\\), it can be omitted (single-valued attributes).\nThe value of an attribute, nmay also be null or have several values (multi-valued attributes).\n\n\n\n\n\n\n\nflowchart LR\n    A((Surname)) --- B[Person]\n    C((License Number)) --- |\"(0,1)\"| B\n    B --- |\"(0, N)\"| D((CarRegistration#))\n\n\n\n\n\n\n\nMulti-valued attributes foten represent situations that can be modeled with additional entities.\n\nE.g., the above model can be transformed into the following model:\n\n\n\n\n\n\n\nflowchart LR\n    A((Surname)) --- B[Person]\n    C((License Number)) --- |\"(0,1)\"| B\n    B --- |\"(0,N)\"| E{Owns}\n    E --- |\"(1,1)\"| D((CarRegistration#))\n\n\n\n\n\n\n\n\n\n\n\n\nNote 5: Keys: (Represented by an underline \\(\\Huge{\\underline{\\ \\ }}\\) or \\(\\Huge{\\bullet}\\))\n\n\n\n\nKeys consist of minimal sets of attributes which uniquely identify instances of an entity set.\n\nSSN may be a key of Person\nfirstName, middleName, lastName, address may be a key of Person\n\nIn most cases, a key is formed by one or more attributes of the entity itself (internal key).\nSometimes, an entity doesn’t have a key among its attributes. This is called a weak entity.\n\nSolution: the keys of related entities brought into help with identification (becoming foreign keys).\n\nA key for a relationship consists of the keys of the entities it relates.\n\n\n\n\nExample of Keys\n\nInternal, single-attribute\ninternal, multi-attribute\nweak entity with foreign key \n\nExample of Schema with Keys"
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#challenges-in-er-design-modeling-the-real-world",
    "href": "notes/cs377/11-er-design/11 ER Design.html#challenges-in-er-design-modeling-the-real-world",
    "title": "11 ER Design",
    "section": "Challenges in E/R Design: Modeling the “Real World”",
    "text": "Challenges in E/R Design: Modeling the “Real World”\n\nLife is arbitrarily complex\nDesign choices: should a concept be modeled as an entity, an attribute, or a relationship?\nLimitations of the E/R Model: A lot of data semantics can be captured but some cannot.\nKey to successfull model: parsimony:\n\nAs complex as necessary, but no more.\nChoose to present only relevant things."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#from-er-model-to-relationship-database-schema",
    "href": "notes/cs377/11-er-design/11 ER Design.html#from-er-model-to-relationship-database-schema",
    "title": "11 ER Design",
    "section": "From E/R Model to Relationship Database Schema",
    "text": "From E/R Model to Relationship Database Schema\n\nRelational Database Design\n\nGiven a conceptual schema (ER, but could also be other models), generate a logical (relational) schema.\nIt is helpful to divide the design into two steps:\n\nRestructuring (refining) of the E/R schema, based on criteria for the optimization of the schema\n\nTranlation into the logical model, based on the features of the logical model (relational model)\n\n\n\nRestructuring An E/R Model\n\nRestructuring Overview\n\nInput: E/R Schema\nOUtput: Resturctured (Refined) E/R Schema\n\nRestructuring includes:\n\nAnalysis of redundancies\nChossing entity set vs. attribute\nLimiting the use of weak entity sets\nSelection of keys\nCreating entity sets to replace attributes with cardinality greater than one.\n\nExample: Redundancies\n\nIn the followign E/R schema, the attribute Manf. Address is redundant.\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    E((Manf. Address)) --- A\n\n\n\n\n\n\n\nThe schema can be restructured as follows:\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, 1)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nHowever, here’s still a redundancy in the schema: we don’t need the Manf. Name attribute.\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, 1)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nEntity Sets vs. Attributes\n\nAn entity set should satisfy at least one of the following conditions:\n\nIt is mor than the name of something; it has at least one non-key attribute, or\nIt is the many in a many-one or many-many relationship.\n\nRules of thumb:\n\nA thing in tis own right: entity set\nA detail about some other thing: attribute\nA detial correlated among many things: entity set\n\nIt is to avoid redundancy.\n\nExample: domain fact change: A Part can have more than one Manufacturer.\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nHowever, if we add another domain fact change: No manufacturer address:\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n\n\n\n\n\n\n\nManufacturer does not have a nonkey attribute anymore…\n\nHowever, it is an “many” in a many-to-many relaionship.\nSo, we cannot convert it to an attribute.\n\nExample: What if we start from the following schema?\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    E((Manf. Address)) --- A\n\n\n\n\n\n\n\nWe still apply the same domain fact changes:\n\nA Part can have more than one Manufacturer, and\nNo manufacturer address.\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) ---|\"(1,N)\"| A\n\n\n\n\n\n\n\nIt looks good, but we want to avoid multi-value attributes as it is not compatible with relational DBs.\nSo, we convert the multi-value attribute Manf. Name to an entity set.\nAnother example: if we apply the domain fact change: A Manufactuere can have 0 Part. Then,\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(0, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nIf no parts are associated with a manufacturer, then we lose all information on the manufacturer in this system.\nWhen to use weak entity sets?\n\nThe usual reason is that there is no global authority capble of creating unique IDs.\n\nDon’t oversue weak entity sets:\n\nBeginner database designers often doubt that anything could be a key by itself:\n\nThe make all entity sets weak, supported by all other entity sets to which they are linked.\n\nIt is usually better to create unique IDs\n\nSelecting a Primary Key\n\nEvery entity must have a primary key.\nThe crteria for this decision are as follows:\n\nAttributes with null values cannot form primary keys.\nOne/few attributes is preferable to many attributes.\nInternal keys preferable to external ones (week entities depend for their existence on other entities).\n\n\nKeep Keys Simple: Multi-attribute and/or string keys\n\nWaste space (are redundant)\nBreak encapsulation\nAre brittle (nasty interaction of above two points)\nAlso: computers are good at numbers, not strings.\n\nAttributes with Cardinality Greater than One\n\nThe relational model doesn’t allow multi-valued attributes. We must convert these to entity sets.\n\nExample: Multi-valued Attributes\n\nConsider the following schema:\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) ---|\"(1,N)\"| A\n\n\n\n\n\n\n\nWe have to convert it to the following schema (making Manf. Name an entity set):\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F"
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#translation-into-the-logical-model",
    "href": "notes/cs377/11-er-design/11 ER Design.html#translation-into-the-logical-model",
    "title": "11 ER Design",
    "section": "Translation into the Logical Model",
    "text": "Translation into the Logical Model\n\nOverview\n\nInput: E/R Schema\nOutput: Relational Schema\nStarting from an E/R schema, an equivalent relationap schema is constructed.\n\n“equivalent:” a schema capble of representing the same information.\nA good translation should also:\n\nnot allow redundancy\nnot invite unnecessary null values\n\n\nEach entity set becomes a relation whose attributes are\n\nthe attributes of the entity set, and\n\nEach relationship becomes a relation whose attributes are\n\nthe keys of the entity sets that it connects, plus\nthe attributes of the relationship itslef.\n\nThere are some exceptional cases here that will come up later.\n\n\n\nMany-to-Many Relationships\n\nExample 1\n\n\n\n\n\n\nflowchart LR\n    A[Employee] --- |\"(0, N)\"| B{Participation} --- |\"(0, N)\"| C[Project]\n    D((Surname)) --- A\n    E((Salary)) --- A\n    F((\"&lt;u&gt;Name&lt;/u&gt;\")) --- A\n    G((StartDate)) --- B\n    C --- H((Name))\n    C --- I((Budget))\n    C --- J((\"&lt;u&gt;Code&lt;/u&gt;\"))\n\n\n\n\n\n\n\n\n\n\n\n\nTip 1: Answer\n\n\n\n\n\n\nEmployee(Number, Surname, Salary)\nProject(Code, Name, Budget)\nParticipation(EmployeeNumber, ProjectCode, StartDate)\n\n\n\n\n\nExample 2\n\n\n\n\n\n\nflowchart TB\n  A{Composition} --- |\"(0, N) Part\"| B[Product]\n  B --- |\"(0, N) Subpart\"| A\n  C((Quantity)) --- A\n  B --- D((Cost))\n  B --- E((Name))\n  B --- F((\"&lt;u&gt;Code&lt;/u&gt;\"))\n\n\n\n\n\n\n\n\n\n\n\n\nTip 2: Answer\n\n\n\n\n\n\nProduct(Code, Name, Cost)\nComposition(PartCode, SubpartCode, Quantity)\n\n\n\n\n\nExample 3\n\n\n\n\n\n\nflowchart LR\n  A[Supplier] --- |\"(0, N)\"| B{Supply} --- |\"(1, N)\"| C[Product]\n  B --- |\"(1,N)\"| D[Department]\n  D --- E((\"&lt;u&gt;Name&lt;/u&gt;\"))\n  D --- F((Telephone))\n  G((\"&lt;u&gt;SupplierID&lt;/u&gt;\")) --- A\n  H((\"SupplierName\")) --- A\n  I((Quantity)) --- B\n  C --- J((\"&lt;u&gt;Code&lt;/u&gt;\"))\n  C --- K(Type)\n\n\n\n\n\n\n\nThis schema can be translated into the following relational schema:\n\n\n\n\n\n\n\nTip 3: Answer\n\n\n\n\n\n\nSupplier(SupplierID, SupplierName)\nProduct(Code, Type)\nDepartment(Name, Telephone)\nSupply(SupplierID, ProductCode, DeptName, Quantity)\n\n\n\n\n\n\nOne-to-One Relationships\n\nExample 1: with mandatory participation for one\n\n\n\n\n\n\nflowchart LR\n  A[Player] --- |\"(1,1)\"| B{Contract} --- |\"(1,1)\"| C[Team]\n  D((\"&lt;u&gt;DateOfBirth&lt;/u&gt;\")) --- A\n  E((\"&lt;u&gt;SurName&lt;/u&gt;\")) --- A\n  F((Position)) --- A\n  G((Salary)) --- B\n  C --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n  C --- I((Town))\n  C --- J(TeamColor)\n\n\n\n\n\n\n\n\n\n\n\n\nTip 4: Answer\n\n\n\n\n\n\nPlayer(DateOfBirth, SurName, Position)\nTeam(Name, Town, TeamColor)\nContract(PlayerDateOfBirth, PlayerSurName, Team Salary)\n\nThis line is incorrect because one player can only have one contract with one team. Having a contract with a team is not a unique identifier for a player.\nFor example, this schema allows Messi to sign contracts with Barcelona and Real Madrid at the same time. This is not possible in real life.\n\nContract(PlayerDateOfBirth, PlayerSurName, Team, Salary)\n\n\nAnother correct solution:\n\nPlayer(DateOfBirth, SurName, Position, TeamName, Salary)\nTeam(Name, Town, TeamColor)\n\n\n\n\n\n\nExample 2: with mandatory participation for both\n\n\n\n\n\n\nflowchart LR\n  A[Head] --- |\"(1,1)\"| B{Management} --- |\"(1,1)\"| C[Department]\n  D((Salary)) --- A\n  E((Name)) --- A\n  F((\"&lt;u&gt;Number&lt;/u&gt;\")) --- A\n  G((StartDate)) --- B\n  C --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n  C --- I((Telephone))\n  C --- J((Branch))\n\n\n\n\n\n\n\n\n\n\n\n\nTip 5: Answer\n\n\n\n\n\n\nHead(Number, Name, Salary, DeptName, StartDate)\nDepartment(Name, Telephone, Branch)\n\n\nAnother correct solution:\n\nHead(Number, Name, Salary, StartDate)\nDepartment(Name, Telephone, Branch, HeadNumber)\nRemark: We included StartDate in table Head instead of table Department because it is more meaningful to associate the date as a dept was managed with the manager (i.e., the head) rather than with the department.\n\n\n\n\n\n\nExample 3: with optional participation for one\n\n\n\n\n\n\nflowchart LR\n  A[Employee] --- |\"(1,1)\"| B{Management} --- |\"(1,1)\"| C[Department]\n  D((Salary)) --- A\n  E((Name)) --- A\n  F((\"&lt;u&gt;Number&lt;/u&gt;\")) --- A\n  G((StartDate)) --- B\n  C --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n  C --- I((Telephone))\n  C --- J((Branch))\n\n\n\n\n\n\n\n\n\n\n\n\nTip 6: Answer\n\n\n\n\n\n\nEmployee(Number, Name, Salary)\nDepartment(Name, Telephone, Branch, ManagerNumber, StartDate)\n\n\nWhat if both entities had optional participation, i.e., \\((0,1)\\)?\n\nEmployee(Number, Name, Salary)\nDepartment(Name, Telephone, Branch)\nManagement(ManagerNumber, DeptName, StartDate)\n\n\n\nHow can we guarantee that a department cannot have more than one manager?\n\nDeclare a UNIQUE constraint for attribute DeptName in table Management.\n\n\n\nCan DeptName be a key instead of ManagerNumber?\n\nYes, for this schema, choosing either of them to be a key is correct.\n\n\n\n\n\n\nSummary of Types of Relationship\n\nMany-to-many: create a new relation with the keys of the entities and the attributes of the relationship.\nOne-to-many:\n\nManditory participation for one: add the key of the entity with mandatory participation to the relation of the entity with optional participation.\nManditory participation for both: add the keys of both entities to the relation.\n\nOne-to-one:\n\nManditory participation for one: add the key of the entity with mandatory participation to the relation of the entity with optional participation.\nManditory participation for both: add the keys of both entities to the relation.\nOptional participation for both: add the keys of both entities to the relation.\n\n\nSee summaries in slides 20-er-design-part3.pdf\nWill the schema be “good”?\n\nThe process ensure that there is no redundancy.\nBut only with respect to what the E/R diagram represents.\nThe next topic (DB normalization) will help us better analyze the goodness of a schema design."
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#analysis-of-recursive-algorithms",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#analysis-of-recursive-algorithms",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Analysis of Recursive Algorithms",
    "text": "Analysis of Recursive Algorithms\n\n\n\n\n\n\nTip 16: Example: Recursion Analysis 1\n\n\n\n\n\npublic static void recurse(int n) {\n    if (n == 0) {\n        doPrimitive();\n    } else {\n        doPrimitive();\n        recurse(n-1);\n    }\n}\n\nLet \\(C(n)=\\) # of times that doPrimitive() is executed when input \\(=n\\).\n\\(C(0)=1\\) because when \\(n=0\\), we only execute doPrimitive() one time and terminate. This is the base case.\n\\(C(n)=1+C(n-1)\\) for \\(n&gt;0\\). This is because recurse(n) will invoke recurse(n-1), and by definition, the # times that doPrimitive() is executed when input \\(=n-1\\) is: \\(C(n-1)\\)\nTo solve the recursive relation, we will use the technique . \\[\n\\begin{aligned}\n  C(n)&=1+C(n-1)\\\\\n  &=1+1+C(n-2)\\\\\n  &=1+1+1+C(n-3)\\\\\n  &=\\underbrace{1+1+1+\\cdots+1}_{n\\text {times}}+C(0)\\\\\n  &=n+1\n\\end{aligned}\n\\]\nSo, \\(\\mathcal{O}(n)\\)\n\n\n\n\n\n\n\n\n\n\nTip 17: Example: Recursion Analysis 2\n\n\n\n\n\npublic static void recurse(int n) {\n    if (n == 0) {\n        doPrimitive();\n    } else {\n        for (int i = 0; i &lt; n; i++) {\n            doPrimitive();\n        }\n        recurse(n-1);\n    }\n}\n\nLet \\(C(n)=\\) # of times that doPrimitive() is executed when input \\(=n\\).\n\\(C(0)=1\\) as the base case; \\(C(n)=n+C(n-1)\\) for \\(n&gt;0\\) because recurse(n) will invoke recurse(n-1), and by definition, the # times that doPrimitive() is executed when input = \\(n-1\\) is: \\(C(n-1)\\).\nTelescoping: \\[\n\\begin{aligned}\n  C(n)&=n+C(n-1)\\\\\n  &=n+(n-1)+C(n-2)\\\\\n  &=n+(n-1)+(n-2)+C(n-3)\\\\\n  &=n+(n-1)+(n-2)+\\cdots+1+C(0)\\\\\n  &=\\dfrac{n(n+1)}{2}+1\n\\end{aligned}\n\\]\nSo, \\(\\mathcal{O}(n^2)\\).\n\n\n\n\n\n\n\n\n\n\nTip 18: Example: Recursion Analysis 3\n\n\n\n\n\npublic static void recurse(int[] A, int a, int b) {\n    if (b-a &lt;= 1) {\n        doPrimitive();\n    } else {\n        doPrimitive();\n        recurse(A, a, (a+b)/2); // First half of array\n        recurse(A, (a+b)/2, b); // 2nd half of array\n    }\n}\n\nLet \\(C(n)=\\) # of times that doPrimitive() is executed when input \\(=n\\).\n\\(C(1)=1\\) because if \\(b-a\\leq1\\), it executes \\(1\\) doPrimitive().\n\\(C(n) = 1 + C(n/2) + C(n/2)=1+2C(n/2)\\) for \\(n &gt; 0\\) because: recurse(n) will invoke recurse() twice with input size \\(n/2\\), and by definition, the # times that doPrimitive() is executed when input = \\(n/2\\) is: \\(C(n/2)\\).\nTelescoping: \\[\n\\begin{aligned}\n  C(n)&=1+2C(n/2)\\\\\n  &=1+2+4C(n/4)\\\\\n  &=1+2^1+2^2+\\cdots+2^k*C(n/2^k)\n\\end{aligned}\n\\] We want \\(C(n/2^k)\\) to eventually be \\(C(1)\\). So, we have \\(1=n/2^k\\implies n=2^k\\implies k=\\log{n}\\). So, \\[\n\\begin{aligned}\n  C(n)&=1+2^1+2^2+\\cdots+2^kC(1)\\\\\n  &=1+2^1+2^2+\\cdots+2^k\\\\\n  2C(n)&=2^1+2^2+2^3+\\cdots+2^{k+1}\\\\\n  C(n)=2C(n)-C(n)&=2^{k+1}-1\\\\\n  &=2^{\\log{n}+1}-1\\\\&=2\\cdot2^{\\log{n}}-1\\\\\n  &=2n-1\n\\end{aligned}\n\\]\nSo, \\(\\mathcal{O}(n)\\)."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "",
    "text": "Goal of sorting: rearrange \\(N\\) items such that their keys are in ascending (increasing) order.\nSorting algorithms are based on the following operations:\n\nCompare: compare two items and determine their relative order.\nExchange: swap two items.\n\nThe preimitive operation in sorting is the comparison.\nComparing items: the Java Comparable interface:\n\nSorting requires that 2 items can be compared.\nJava defines the Comparable&lt;T&gt; interface to represent this requirement:\npublic Interface Comparable&lt;T&gt; {\n    public int  compareTo(T o);\n}\nClass that implements Comparable&lt;T&gt; are comparable classes, and they must implement the compareTo() method.\nRequirement of the compareTo() method:\n\na.compareTo(b) returns a negative value if a is less than b.\na.compareTo(b) returns zero if a is equal to b.\na.compareTo(b) returns a positive value if a is greater than b.\n\n\nExchanging two items (objects) in an array:\npublic static void exch(DataType[] a, int i, int j) {         \n    DataType help;         \n    help = a[i];         \n    a[i] = a[j];         \n    a[j] = help;     \n}\n\nThe exch() method will only work on objects of the type DataType.\nWe can define a generic (parameterized) exch() so that it will only work on subclasses of Comparable&lt;T&gt;:\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void exch(T[] a, int i, int j) {\n    T help;\n\n    help = a[i];\n    a[i] = a[j];\n    a[j] = help;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#introduction-to-sorting",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#introduction-to-sorting",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "",
    "text": "Goal of sorting: rearrange \\(N\\) items such that their keys are in ascending (increasing) order.\nSorting algorithms are based on the following operations:\n\nCompare: compare two items and determine their relative order.\nExchange: swap two items.\n\nThe preimitive operation in sorting is the comparison.\nComparing items: the Java Comparable interface:\n\nSorting requires that 2 items can be compared.\nJava defines the Comparable&lt;T&gt; interface to represent this requirement:\npublic Interface Comparable&lt;T&gt; {\n    public int  compareTo(T o);\n}\nClass that implements Comparable&lt;T&gt; are comparable classes, and they must implement the compareTo() method.\nRequirement of the compareTo() method:\n\na.compareTo(b) returns a negative value if a is less than b.\na.compareTo(b) returns zero if a is equal to b.\na.compareTo(b) returns a positive value if a is greater than b.\n\n\nExchanging two items (objects) in an array:\npublic static void exch(DataType[] a, int i, int j) {         \n    DataType help;         \n    help = a[i];         \n    a[i] = a[j];         \n    a[j] = help;     \n}\n\nThe exch() method will only work on objects of the type DataType.\nWe can define a generic (parameterized) exch() so that it will only work on subclasses of Comparable&lt;T&gt;:\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void exch(T[] a, int i, int j) {\n    T help;\n\n    help = a[i];\n    a[i] = a[j];\n    a[j] = help;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#selection-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#selection-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Selection Sort",
    "text": "Selection Sort\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void selectionSort(T[] list) {\n    for (int i = 0; i &lt; list.length-1; i++) {\n        // Find the minimum in the list[i..list.length-1]\n        T min = list[i]; // Assume first element is min\n        int minIndex = i; // index where min is found\n\n        for (int k = minIndex+1; k &lt; list.length; k++) {\n            if (list[k].compareTo(min) &lt; 0) { // compare list[k] and min\n                min = list[k]; // update min value\n                minIndex = k; // update min index\n            }\n        }\n\n        // Swap list[i] with list[minIndex] if necessary\n        if (minIndex != i) {\n            exch(list, i, minIndex);\n        }\n    }\n}\n\n\n\n\n\n\nTip 1: Runtime Analysis of Selection Sort\n\n\n\n\n\n\nThe algorithm can be simplified as follows:\n\nfor (int i = 0; i &lt; n-1; i++) {\n    for (int k = i + 1; k &lt; n; k++) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n0\n1\n2\n…\nn-3\nn-2\n\n\n\n\nk=\n1\n2\n3\n…\nn-2\nn-1\n\n\nk=\n2\n3\n4\n…\nn-1\n\n\n\n…\n…\n…\n…\n\n\n\n\n\nk=\nn-2\nn-1\n\n\n\n\n\n\nk=\nn-1\n\n\n\n\n\n\n\n\n\nSo, number of iterations is \\((n-1)+(n-2)+(n-3)+\\cdots+2+1\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\n\n\n\n\n\n\n\n\nNote 1: Additional Properties of Sorting Algorithms: In-place and Stability\n\n\n\n\nIn-place: a sorting algorithm is in-place if it does not require another array to execute the algorithm.\nStable: a sorting algorithm is stable if it preserves the relative order of equal keys in the array.\n\n\n\n\nSelection sort is in-place but not stable."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#bubble-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#bubble-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Bubble Sort",
    "text": "Bubble Sort\n\nThe bubble sort algorithm will:\n\nCompare every pair of adjacent element\nExchange(=swap) them if they are out of order.\n\nExample:\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n9\n5\n4\n8\n1\nOrignal array\n\n\n\n\n2\n9\n5\n4\n8\n1\n2 &lt; 9 –&gt; OK, no swap\n\n\n2\n9\n5\n4\n8\n1\n9 &gt; 5 –&gt; swap\n\n\n2\n5\n9\n4\n8\n1\n9 &gt; 4 –&gt; swap\n\n\n2\n5\n4\n9\n8\n1\n9 &gt; 8 –&gt; swap\n\n\n2\n5\n4\n8\n9\n1\n9 &gt; 1 –&gt; swap\n\n\n2\n5\n4\n8\n1\n9\nFinish first iteration\n\n\n\n\nNote that after 1 iteration, the largest element is at the end of the array (the correct position). Therefore, if we repeat \\(n-1\\) times, the array will be sorted.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void bubbleSort(T[] arr) {\n    int n = arr.length;\n\n    for (int i = 0; i &lt; n-1; i++) { // repeat n-1 times\n        // compare every adjacent pair of elements\n        for (int j = 0; j &lt; n-1-i; j++) {\n            if (arr[j].compareTo(arr[j+1]) &gt; 0) { // if out of order\n                exch(arr, j, j+1); // swap\n            }\n        }\n    }\n}\n\n\n\n\n\n\nTip 2: Runtime Analysis of Bubble Sort\n\n\n\n\n\n\nThe loop structure of bubble sort can be simplified as\n\nfor (int i = 0; i &lt; n-1; i++) {\n    for (int j = 0; j &lt; n-1-i; j++) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n0\n1\n2\n…\nn-3\nn-2\n\n\n\n\nj=\n0\n0\n0\n…\n0\n0\n\n\nj=\n1\n1\n1\n…\n1\n\n\n\n…\n…\n…\n…\n\n\n\n\n\nj=\nn-4\nn-4\nn-4\n\n\n\n\n\nj=\nn-3\nn-3\n\n\n\n\n\n\nj=\nn-2\n\n\n\n\n\n\n\n\n\nSo, number of iterations is \\((n-1)+(n-2)+(n-3)+\\cdots+2+1\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\n\n\n\nIn fact, we can improve the basic bubble sort algorithms.\nThe idea is that if we find that the array is already sorted, we can stop the algorithm.\n\nFacts:\n\nIn each iteration, the bubble sort algorithm will compare every pair of elements and swap only out-of-place pairs.\nWhen the array is sorted: an (entire) iteration in bubble sort will not perform any exchange operation.\n\nSo, we can add a variable to track the number of swaps in each iteration. If we find that the number of swaps is zero, we can stop the algorithm.\n\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void bubbleSort(T[] arr) {\n    int n = arr.length;\n    boolean swapped; \n\n    for (int i = 0; i &lt; n-1; i++) { // repeat n-1 times\n        swapped = false; // reset swapped to false\n        // compare every adjacent pair of elements\n        for (int j = 0; j &lt; n-1-i; j++) {\n            if (arr[j].compareTo(arr[j+1]) &gt; 0) { // out of order\n                exch(arr, j, j+1); // swap\n                swapped = true; // set swapped to true\n            }\n        }\n\n        if (swap == false) { // if no swap in this iteration\n            break; // stop the algorithm\n        }\n    }\n}\n\nThe bubble sort algorithm is an in-place and stable sorting algorithm."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#insertion-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#insertion-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Insertion Sort",
    "text": "Insertion Sort\n\nThe insertion sort algorithm will:\n\nSelections the next unsorted element/key in the array\nInsert(=exchange) it towards the front into its correct position\n\nExample:\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n9\n5\n4\n8\n1\nOriginal array\n\n\n\n\n2\n9\n5\n4\n8\n1\n2 is in the correct position\n\n\n2\n9\n5\n4\n8\n1\n9 is in the correct position\n\n\n2\n9\n5\n4\n8\n1\n5 is not in the correct position, swap\n\n\n2\n5\n9\n4\n8\n1\n5 is not in the correct position, swap\n\n\n2\n4\n5\n9\n8\n1\n8 is not in the correct position, swap\n\n\n2\n4\n5\n8\n9\n1\n9 is not in the correct position, swap\n\n\n1\n2\n4\n5\n8\n9\nFinished!\n\n\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void insertionSort(T[] arr) {\n    int n = arr.length;\n\n    for (int i = 1; i &lt; n; i++) { // Repeat n-1 times\n        // Compare adjacent pairs starting at (i-1, i)\n        for (int j = i; j &lt; 0; j--) {\n            if (arr[j-1].compareTo(arr[j]) &gt; 0) { // out of order\n                exch(arr, j-1, j); // swap\n            } else {\n                break; // stop the inner loop\n            }\n        }\n    }\n}\n\n\n\n\n\n\nTip 3: Runtime Analysis of Insertion Sort\n\n\n\n\n\n\nThe loop structure of the insertion sort algorithm can be simplified as:\nfor (int i = 1; i &lt; n; i++) {\n    for (int j = i; j &gt; 0; j--) {\n        doPrimitive();\n    }\n}\n\n\n\ni=\n1\n2\n3\n…\nn-2\nn-1\n\n\n\n\nj=\n1\n2\n3\n…\nn-2\nn-1\n\n\nj=\n\n1\n2\n…\nn-3\nn-2\n\n\n…\n…\n…\n…\n\n\n\n\n\nj=\n\n\n\n\n\n1\n\n\n\n\nSo, number of iterations is \\(1+2+3+\\cdots+(n-2)+(n-1)\\), which is the triangular sum.\nThen, we know number of iterations=\\(\\dfrac{n(n-1)}{2}\\).\nThis indicates that the runtime is \\(\\mathcal{O}(n^2)\\).\n\n\n\n\n\n\nThe selection sort algorithm is an in-place and stable sorting algorithm."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#merge-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#merge-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Merge Sort",
    "text": "Merge Sort\n\nMerge Algorithm\n\nWe are given two sorted array portions that are adjacent to each other:\n\nInput:\nA[]:    ...... A[s] ... A[m-1] A[m] ... A[e-1] ...\n               &lt;-------------&gt; &lt;-------------&gt;\n                    sorted          sorted\n\nWe will design an efficient algorithm to merge the 2 sorted array portions. The result will then occupy the same portion in the array.\nParameters of the merge algorithm:\n\nThey merge algorithm has 3 (index) parameters: s, m, and e.\ns: the starting index of the first sorted array portion.\nm: the ending index of the first sorted array portion.\ne: the ending index of the second sorted array portion.\n\nThe merge algorithm will:\n\nonly merge the array elements inside A[s] ... A[e-1]\nnot affect the array elements outside the range.\n\nVariables used in the merge algorithm:\n\nWe use 2 indices i and j to point to the current elements in each sorted array portion:\n\nThe element A[i] is always the smallest value in the left (sorted) portion.\nThe element A[j] is always the smallest value in the right (sorted) portion.\n\nWe also use a helper array variable H[] array to perform the merge operation.\n\nWe will repeatedly copy the smallest value from both arrays to H[].\nIf A[j] &lt; A[i], we will copy A[j] to H[] and increment j.\nIf A[i] &lt; A[j], we will copy A[i] to H[] and increment i.\nWhen i == m, we know the left portion is exhausted, so we can copy the remaining elements in the right portion to H[].\nWhen i == m and j == e, both portions are exhausted, and H[] now contains the merged result. We will then copy H[] back to A[].\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void \n                                    merge(T[] A, int s, int m, int e, T[] H) {\n    // The merge() method will be invoked repeatedly. \n    // If we create a helper array inside merge(), \n    // we would repeatedly allocated and de-allocate memory.\n    // That is inefficient.\n    // So, we create a helper array outside merge() and pass it as a parameter.\n    int i = s, j = m; // current elements in left and right portions\n    int k = 0; // current element in helper array\n\n    while (i &lt; m || j &lt; e) { // loop as long as there are unprocessed items\n        if (i &lt; m && j &lt; e) {\n            // Case 1: both portions have unprocessed elements\n            if (A[i].compareTo(A[j]) &lt; 0) {\n                H[k++] = A[i++];\n            } else {\n                H[k++] = A[j++];\n            }\n        } else if (i == m) {\n            // Case 2: the left portion is exhausted\n            H[k++] == A[j++];\n        } else if (j == e) {\n            // Case e: the right portion is exhausted\n            H[k++] = A[i++];\n        }\n    }\n\n    // Copy H[] back to A[]\n    for (i = s, k = 0; i &lt; e; i++, k++) {\n        A[i] = H[k];\n    }\n}\n\n\n\n\n\n\n\n\nTip 4: Runtime Analysis of Merge Algorithm\n\n\n\n\n\n\nWe can simplify the while-loop into:\n\nwhile (i &lt; m || j &lt; e) {\n    doPrimitive();\n    // Then do either: \n    i++; // --&gt; i = s; i &lt; m; i++ = m-s times\n    // Or do: \n    j++; // --&gt; j = m; j &lt; e; j++ = e-m times\n}\n// Copy\nfor (int i = s, k = 0; i &lt; e; i++, k++) {\n    // i = s; i &lt; e; i++ = e-s times\n    doPrimitive();\n}\n\nThe while loop will be executed \\((m-s)+(e-m) = e-m=n\\) times.\nThe for loop will be executed \\(e-s=n\\) times.\nIn total, we have \\(2n\\) primitive operations.\nThe running time of the merge() algorithm is \\(2n\\), which is \\(\\mathcal{O}(n)\\).\n\n\n\n\n\n\nMerge Sort Algorithm\n\nThe Merge sort algorithm will:\n\nSplit the array a[] into 2 halves:\n\nan array left[] containing a[0] ... a[n/2]\nan array right[] containing a[n/2+1] ... a[n-1]\n\nSort both halves of the arrays (by repeating the above step)\nMerge the sorted arrays into the final sorted array\n\nThe recursive structure (illustration using selectinoSort):\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a, int s, int e, T[] H) {\n    if (e-s &lt;= 1) { // A[s]..A[e] has 0 or 1 elements\n        return; // nothing to sort\n    }\n    int m = (s+e)/2; // m is the middle index\n\n    /*\n     * Sort the left portion A[s]..A[m-1]\n     * Sort the right portion A[m]..A[e-1]\n     * Merge the sorted portions\n     */\n    selectionSort(A, s, m);\n    selectionSort(A, m, e);\n\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nNow, the real merge sort algorithm is simply to replace selectionSort() with mergeSort().\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] a, int s, int e, T[] H) {\n    if (e-s &lt;= 1) { // A[s]..A[e] has 0 or 1 elements\n        return; // nothing to sort\n    }\n    int m = (s+e)/2; // m is the middle index\n\n    /*\n     * Sort the left portion A[s]..A[m-1]\n     * Sort the right portion A[m]..A[e-1]\n     * Merge the sorted portions\n     */\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nThe merge sort algorithm is not an in-place sorting algorithm, but it is a stable sorting algorithm.\n\n\n\n\n\n\n\nTip 5: Runtime Analysis of Merge Sort\n\n\n\n\n\n\nIf we want to sort \\(n\\) elements, we can rewrite the algorithm into\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] a, int n, T[] H) {\n    if (n &lt;= 1) {\n        return;\n    }\n    mergeSort(a, n/2, H); // running time = T(n/2)\n    mergeSort(a, n/2, H); // running time = T(n/2)\n    // Final merge\n    merge(a, 0, n/2, n, H); // running time = 2n\n}\n\nSo, \\(T(n)=0\\) for \\(n\\leq 1\\) and \\(T(n)=2T\\left(\\dfrac{n}{2}\\right)+2n\\) for \\(n\\geq2\\).\nNow, let’s solving the following relationship: \\[\n\\begin{aligned}\nT(1)&=0\\\\\nT(n) &= 2T\\left(\\dfrac{n}{2}\\right)+2n \\\\\n&= 2\\left[2T\\left(\\dfrac{n}{4}\\right)+2\\left(\\dfrac{n}{2}\\right)\\right]+2n \\\\\n&=2^2T\\left(\\dfrac{n}{2^2}\\right)+2(2n) \\\\\n&=2^2\\left[2T\\left(\\dfrac{n}{2^3}\\right)+2\\left(\\dfrac{n}{2^2}\\right)\\right]+2(2n) \\\\\n&=2^3T\\left(\\dfrac{n}{2^3}\\right)+3(2n) \\\\\n&\\vdots \\\\\n&=2^kT\\left(\\dfrac{n}{2^k}\\right)+k(2n) \\\\\n\\text{Set }\\dfrac{n}{2^k}=1&\\implies 2^k=n\\implies k=\\log(n)\\\\\nT(n)&=2^kT\\left(\\dfrac{n}{2^k}\\right)+k(2n) \\\\\n&=2^kT(1)+2kn \\\\\n&=0+2kn=2n\\log(n) \\\\\n\\end{aligned}\n\\]\nSo, the running time is \\(T(n)=2n\\log(n)\\), which is \\(\\mathcal{O}(n\\log(n))\\).\n\n\n\n\n\nMerge sort is one of few algorithms that has a runtime of \\(\\mathcal{O}(n\\log(n))\\).\n\n\\(\\mathcal{O}(n\\log(n))\\) is the theoretical lower bound on running time of sorting algorithms.\n\nSome problems with pure merge sort algorithm:\n\nThere is a very high overhead to executive a recursive algorithm for tiny sublists.\nMerge sort will merge even when the 2 halves are sorted.\nMerge sort is not an in-place algorithm.\n\nMerge sort requires an additional array to perform the merge operation.\n\n\nTo solve the first problem, we can have a cutoff value for the size of the sublist. If the size of the sublist is smaller than the cutoff value, we will use selection sort instead of merge sort. This hybrid algorithm is called Tim Sort.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, int s, int e, T[] H) {\n    if (e - s &lt;= CUTOFF) {\n        selectionSort(A, s, e);\n        return;\n    }\n    int m = (s + e) / 2;\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n    // Merge both sorted arrays\n    merge(A, s, m, e, H);\n}\n\nTo solve the second problem, we can simply add a comparison of the last element in the left portion and the first element in the right portion. If the last element in the left portion is smaller than the first element in the right portion, we can skip the merge operation.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, int s, int e, T[] H) {\n    if (e - s &lt;= CUTOFF) {\n        selectionSort(A, s, e);\n        return;\n    }\n    int m = (s + e) / 2;\n    mergeSort(A, s, m, H);\n    mergeSort(A, m, e, H);\n    // Merge both sorted arrays only when values over lap\n    if (A[m-1].compareTo(A[m]) &lt; 0) {\n        return;\n    }\n    merge(A, s, m, e, H);\n}\n\n\nNon-recursive Merge Sort\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void mergeSort(T[] A, T[] H) {\n    int mergeSize = 1;\n\n    while (mergeSize &lt; A.length) {\n        int s, m, e;\n        for (s = 0; s &lt; A.length; s += 2*mergeSize) {\n            m = s + mergeSize;\n            e = Math.min(s + 2*mergeSize, A.length);\n            merge(A, s, m, e, H);\n        }\n        mergeSize *= 2;\n    }\n}\nA[]: | mergeSize | mergeSize | mergeSize | mergeSize | ...\n     s           m          e/s          m           e"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#quick-sort",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#quick-sort",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Quick Sort",
    "text": "Quick Sort\n\nIntroduction to Quick Sort\n\nQuick sort is the most commonly used sorting algorithm.\nQuick sort was invented by Antony Hoare in 1959 and was honored as one of the top 10 algorithms in the 20th centry.\nSome facts on quick sort:\n\nIt is a divide-and-conquer algorithm. (just like merge sort)\n\nUnlike merge sort, quick sort is an in-place algorithm. So it does not require an extra array.\n\nBig idea of quick sort:\n\nWe select a pivot element in the array.\nWe partition the array into 2 portions:\n\nThe left portion contains elements that are smaller than the pivot.\nThe right portion contains elements that are larger than the pivot.\n\nInsert the pivot to the correct position.\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; void quickSort(T[] A, int s, int e) {\n  if (e - s &lt;= 1) { // Base case\n      return;\n  }\n  // partition sub array A[s]..A[e-1] using A[s] as pivot\n  int pivotLoc = partition(A, s, e);\n  // partiion(A, s, e) returns the index (=location) of the pivot element. \n  // it is the border of the 2 sub array/groups\n  quickSort(A, s, pivotLoc); // sort left portion\n  quickSort(A, pivotLoc+1, e); // sort right portion\n}\n\n\nThe Partition Algorithm for Quick Sort\n\nA simplified partition algorithm:\n\nA partitioning algorithm maintains 2 half arrays: a low half and a high half.\nThe simplified partitioning algorithm only compares the pivot against A[high].\n           low half                   high half\nA[] = [P L L L L L L ? ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^             ^ &lt;---------&gt;\n       |     &lt;P      |             |     &gt;= P   \n     pivot          low           high\n       |                           |\n       +---------------------------+\n        compares: pivot &lt;==&gt; A[high]\n\nIf A[high] (X) &gt;= pivot, then A[high] belongs to the high partition, and we decrement high\n\n           low half                   high half\nA[] = [P L L L L L L ? ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^           ^ &lt;-----------&gt;\n       |     &lt;P      |           |     &gt;= P   \n     pivot          low         high\n       |                         |\n       +-------------------------+\n        compares: pivot &lt;==&gt; A[high]\n\nIf A[high] (X) &lt; pivot, then A[high] belongs to the low partition: we exchange X and Y and then increment low.\n\n           low half                   high half\nA[] = [P L L L L L L Y ? ? ? ? ? ? X H H H H H H]\n       ^ &lt;---------&gt; ^             ^ &lt;---------&gt;\n       |     &lt;P      |             |     &gt;= P   \n     pivot          low           high\n\n           low half                   high half\nA[] = [P L L L L L L X ? ? ? ? ? ? Y H H H H H H]\n       ^ &lt;-----------&gt; ^           ^ &lt;---------&gt;\n       |     &lt;P        |           |     &gt;= P   \n     pivot            low         high\n\nWe repeat the steps until we get low &gt; high. Then, we will put the pivot in its correct location by exchanging pivot and A[high].\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; int partition(T[] A, int s, int e) {\nT pivot = A[s];\nint low = s, high = e - 1;\n\nwhile (low &lt;= hight) {\n    if (A[high].compareTo(pivot) &gt;= 0) {\n        high--;\n    } else {\n        exch(A, low, high);\n        low++;\n    }\n}\nexch(A, s, high); // A[s] = pivot\nreturn high;\n}\n\nA rather complicated partitioning algorithm:\n\npublic static int partition(int[] list, int first, int last) {\n    int pivot = list[first]; // choose the first element as the pivot\n    int low = first + 1; // index for forward search\n    int high = last - 1; // index for backward search\n\n    while (low &lt; high) {\n        // Search forward from left\n        while (low &lt;= high && list[low] &lt;= pivot) {\n            low++;\n        }\n        // Search backward from right\n        while (low &lt;= high && list[high] &gt; pivot) {\n            high--;\n        }\n        // Swap two elements in the list\n        if (low &lt; high) {\n            int temp = list[high];\n            list[high] = list[low];\n            list[low] = temp;\n        }\n    }\n    // Adjust high to find the border\n    while (high &gt; first && list[high] &gt;= pivot) {\n        high--;\n    }\n    // Swap pivot with list[high]\n    if (pivot &gt; list[high]) {\n        list[first] = list[high];\n        list[high] = pivot;\n        return high;\n    } else {\n        return first; // pivot was the smallest element\n    }\n}\n\nThe quick sort algorithm is an in-place algorithm, but it is not stable.\n\n\n\nRuntime Analysis of Quick Sort\n\nSynopsis of the partition() algorithm\npublic statbic &lt;T extends Comparable&lt;T&gt;&gt; int partition(T[] A, int s, int e) {         \n    T pivot = A[s];         \n    int low = s+1; high = e-1;         \n    while (low &lt;= high) {             \n        doPrimitive(); \n        // either high--; or low++             \n        // --&gt; loop will run (e-1) - (s+1) times = e-1-s-1=e-s-2 times         \n    }         \n    doPrimitive(); // exchange pivot and A[high]         \n    return hight;     \n}\n\nIn this case, the running time will be \\(n-1\\approx n\\). Or, \\(\\mathcal{O}(n)\\).\n\nThe running time of the quick sort algorithm depends on how partition() splits the input array.\n\nIMPORTANT: the running time of quick sort depends on how large the 2 array halves are.\nSuppose the partition(A, s, e) algorithm partitions the input as follows:\n         &lt;-------------- n ---------------&gt;\nINPUT:  [P .. .. .. .. .. .. .. .. .. .. ..]\nRESULT: [.. .. .. .. .. .. P .. .. .. .. ..]\n         &lt;------ k ------&gt;   &lt;--- n-k-1 --&gt;\n\nThe running time \\(T(n)\\) for input size \\(n\\) will have the following recurrence relationship: \\(T(n)=T(k)+T(n-k-1)+n\\).\n\n\nThe best case running time of quick sort.\n\nThe best case running time of the quick sort algorithm happens when: the partition() algorithm always divides the input array into 2 equal halves.\nIn this case, we have \\[\n\\begin{aligned}\nT(n)&=T(k)+T(n-k-1)+n\\\\\n&=T(n/2) + T(n/2-1) + n\\\\\n&\\approx 2T(n/2) + n,\n\\end{aligned}\n\\] which is similar recurrence relation as the one in merge sort.\nSo, we can solve it with telescoping and the result is \\(T(n)=n\\log(n)\\).\n\nThe worst case running time of quick sort:\n\nThe worst case running time of the quick sort algorithm happens when the partition() always divides the input array into (1) array containing the pivot and (2) an array with \\(n-1\\) elements.\nIn this case, we have \\[\n\\begin{aligned}\nT(n)&=T(0)+T(n-1)+n\\\\\n&=0+T(n-1)+n\\\\\n&=T(n-1)+n\\\\\n&=T(n-2)+(n-1)+n\\\\\n&=T(n-3)+(n-2)+(n-1)+n\\\\\n&\\vdots\\\\\n&=T(0)+1+2+\\cdots+(n-2)+(n-1)+n\\\\\n&=1+2+\\cdots+(n-2)+(n-1)+n&\\text{triangular sum}\\\\\n&=\\dfrac{n(n+1)}{2}-1\\\\\n&=\\mathcal{O}(n^2)\n\\end{aligned}\n\\]\nSo, the worse case running time is \\(\\mathcal{O}(n^2)\\).\nAn example that makes quick sort achieve the worse case running time: a sorted array.\n\nBecause the pivot is always the smallest value, partition() will always produce:\n\nAn array containing the pivot, and\nAn array containing the other \\(n-1\\) elements.\n\n\nTo prevent the worse case, a commonly used practice when using quick sort is to:\n\nShuffle the input array randomly (To ensure partition() will not always find the pivot as the first element)\nUse quick sort of the shuffled input array.\nThen, the quick sort will achieve the average running time performance with a randomized input array.\n\n\nThe average running time of quick sort:\n\nRecall the recurrence relation for the running time of quick sort is \\(T(n)=T(k)+T(n-k-1)+n\\), where \\(k\\) is the final position of the pivot.\nDepending on the value of \\(k\\), the recurrence relation for \\(T(n)\\) are different: \\[\\begin{aligned}\nT(n)=T(0)+T(n-1)+n\\quad\\text{ if }k=0\\\\\nT(n)=T(1)+T(n-2)+n\\quad\\text{ if }k=1\\\\\n\\cdots\\\\\nT(n)=T(n-1)+T(0)+n\\quad\\text{ if }k=n-1\n\\end{aligned}\\]\nSince each value of \\(k\\) is equally likely to occur, we can take the average by summing them and dividing the sum by \\(n\\). \\[\\begin{aligned}\nnT(n)=(T(0)+\\cdots+T(n-1))+(T(n-1)+\\cdots+T(0))+n^2\\\\\nnT(n)=2T(0)+2T(1)+\\cdots+2T(n-1)+n^2\\\\\nT(n)=\\dfrac{2}{n}T(0)+\\dfrac{2}{n}T(1)+\\cdots+\\dfrac{2}{n}T(n-1)+n\n\\end{aligned}\\]\nNow, we want to solve the following recurrence relation: \\[\n\\begin{aligned}\nT(1)&=1\\\\\nT(n)&=\\dfrac{2}{n}T(0)+\\dfrac{2}{n}T(1)+\\cdots+\\dfrac{2}{n}T(n-1)+n\\\\\nnT(n)&=2T(0)+2T(1)+\\cdots+2T(n-1)+n^2\\\\\n(n-1)T(n-1)&=2T(0)+2T(1)+\\cdots+2T(n-2)+(n-1)^2\\\\\nnT(n)-(n-1)T(n-1)&=2T(n-1)+n^2-(n-1)^2\\\\\n&=2T(n-1)+2n-1\\\\\nnT(n)&=(n+1)T(n-1)+2n-1\\\\\nT(n)&=\\dfrac{n+1}{n}T(n-1)+2-\\dfrac{1}{n}\\\\\n\\dfrac{T(n)}{(n+1)}&=\\dfrac{T(n-1)}{n}+\\dfrac{2}{(n+1)}-\\dfrac{1}{n(n+1)}\\\\\n\\dfrac{T(n-1)}{n}&=\\dfrac{T(n-2)}{(n-1)}+\\dfrac{2}{n}-\\dfrac{1}{(n-1)n}\\\\\n\\dfrac{T(n-2)}{(n-1)}&=\\dfrac{T(n-3)}{(n-2)}+\\dfrac{2}{(n-1)}-\\dfrac{1}{(n-2)(n-1)}\\\\\n&\\vdots\\\\\n\\dfrac{T(2)}{3}&=\\dfrac{T(1)}{2}+\\dfrac{2}{3}-\\dfrac{1}{2\\cdot3}\\\\\n\\dfrac{T(n)}{(n+1)}&+\\dfrac{T(n-1)}{n}+\\dfrac{T(n-2)}{(n-1)}+\\cdots+\\dfrac{T(2)}{3}\\\\\n&=\\dfrac{T(n-1)}{n}+\\dfrac{T(n-2)}{(n-1)}+\\cdots+\\dfrac{T(2)}{3}+\\dfrac{T(1)}{2}\\\\\n&\\quad+\\dfrac{2}{(n+1)}+\\dfrac{2}{n}+\\dfrac{2}{(n-1)}+\\cdots+\\dfrac{2}{3}\\\\\n&\\quad-\\dfrac{1}{n(n+1)}-\\dfrac{1}{(n-1)n}-\\cdots-\\dfrac{1}{3\\cdot2}\\\\\n\\dfrac{T(n)}{(n+1)}&\\approx2\\left(\\dfrac{1}{(n+1)}+\\dfrac{1}{n}+\\dfrac{1}{(n-1)}+\\cdots+\\dfrac{1}{3}+\\dfrac{1}{2}+1\\right)\\\\\n&=2\\log(n+1)\n\\end{aligned}\n\\]\n\nTherefore, \\(T(n)=2(n+1)\\log(n+1)\\), or \\(\\mathcal{O}(n\\log(n))\\).\n\n\n\n\n\nImprovements to Quick Sort\n\nAs mentioned above, one way to improve the quick sort algorithm is to shuffle the input array randomly.\npublic static void main(String[] args) { \n    Integer[] A = ...; // Array to be sorted with quick sort      \n    // shuffle array A\n    for (int k = 0; k &lt; N; k++) {\n        int i = Math.random() * A.length;\n        int j = Math.random() * A.length;\n        exch(A, i, j);\n    }\n    quickSort(A, 0, A.length);\n}\n\nWhy shuffle?\n\nMake quick sort avoid picking the smallest pivot all the time.\nHelp quick sort achieve the average running time performance with a randomized array.\n\n\nAnother way to improve the quick sort algorithm is the increase the likelihood to partition the array into 2 equal halves.\n\nThe best pivot value is the median of the input array.\nWe can improve the likelihood of picking the median by considering 3 (random value) selected from the input array. (Instead of always using the first element as pivot).\nThe median of 3 partition method:\nA[] = [X .. .. .. .. .. Y .. .. .. .. .. Z]\nLet M = median(X, Y, Z)\n    (1) swap M and X\n    (2) partition(A, s, e)\nAlgorithm to find the median of 3 values:\npublic static int medianOf3(int a, int b, int c) {\n    if ((b &lt;= a && a &lt;= c) || (c &lt;= a && a&lt;= b)) {\n        return a;\n    }\n    if ((a&lt;= b && b &lt;= c) || (c &lt;= b && b &lt;= a)) {\n        return b;\n    }\n    return c;\n}\n\nAn improved (faster) algorithm: using the exclusive OR (^) operator.\n\npublic static int medianOf3(int a, int b, int c) {\n    if ((a &gt; b) ^ (a &gt; c)) { // either a &gt; b or a &gt; c\n        return a;\n    }\n    if ((b &gt; a) ^ (b &gt; c)) { // either b &gt; a or b &gt; c\n        return b;\n    }\n    return c;\n}"
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#faster-computer-vs-better-algorithm.",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#faster-computer-vs-better-algorithm.",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Faster Computer VS Better algorithm.",
    "text": "Faster Computer VS Better algorithm.\n\nConsider:\n\nA sorting algorithm (e.g. merge sort) with \\(\\mathcal{O}(n\\log(n))\\) running time.\nA sorting algorithm (e.g. insertion sort) with \\(\\mathcal{O}(n^2)\\) running time running on a faster computer (e.g. 1,000,000 times faster).\n\nWhich one is better?\n\nThe answer is: it depends.\nIf the input size is small, the faster computer will be better.\nIf the input size is large, the better algorithm will be better.\nA better algorithm will always beat an average algorithm when the input size is sufficiently large."
  },
  {
    "objectID": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#sorting-algorithms-in-javas-library",
    "href": "notes/cs171/13-Sorting-Algorithms/Sorting Algorithms.html#sorting-algorithms-in-javas-library",
    "title": "Lecture 12 Sorting Algorithms",
    "section": "Sorting Algorithms in Java’s Library",
    "text": "Sorting Algorithms in Java’s Library\n\nThe sort() method (an overloaded method) can be found in:\n\njava.util.Arrays to sort arrays:\n\nsort(int[] a): the sorting algorithm is a Dual-Pivot Quick Sort.\nsort(Object[] a): This implementation is a stable, adaptive, iterative Merge Sort.\n\njava.util.Collections to sort collections (e.g. ArrayList):\n\nAccording to information on the Internet, they used Merge Sort in Collections.\n\n\nRequirement to use sort() methods in Java’s library:\n\nThe objects that are sorted must implement the Comparable&lt;T&gt; interface."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html",
    "href": "notes/cs171/14-Hashing/Hashing.html",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "",
    "text": "Note 1: Dictionary/Map as a Data Structure.\n\n\n\nDictionary/map (aka. associative array) is a data structure that consists of a collection of (key, value) pairs called an entry of a dictionary.\n\nNote: the key and the value can be composite.\n\n\n\n\nUsage of a dictionary:\n\nThe dictionary data structure is used to store (key, value) pairs where the user can loop up (=search) a value using the key.\nTo support its usage, a dictionary must provide the following operations:\n\nsize(): return the number of entries stored inside this dictionary.\nput(key, value)L if key is found in the dictionary, it updates the value with value. Otherwise, it inserts (key, value) into the dictionary.\nget(key): return the corresponding value if key is found, and return null otherwise.\nremove(key): remove the dictionary entry containing key (and return the corresponding vaue if key is found).\n\nThe most frequently used operation is get(key), so fast lookup is required!\n\nThe Dictionary interface:\n\npublic interface Dictionary&lt;K,V&gt; {\n    public int size(); // return number of entires in the dictionary\n    public void put(K key, V value); // insert or update (key, value) pair\n    public V get(K key); // return value associated with key; \n                         // return null if not found\n    public V remove(K key); // remove entry with key and return corresponding value\n}\n\nWe can implement the dictionary data structure using:\n\nAn array\nA linked list\n\nFor simplicity, we will implement the dictionary using an array. To achieve it, we need to:\n\nDefinition of the Entry class to represent an entry in a dictionary.\nDefinition of a class to represent a dictionary using an array.\nImplement the (support) methods of the Dictionary interface.\n\nThe Entry class and the ArrayMap implementation:\n\npublic class ArrayMap&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key; // The key (to look up)\n        private V value; // the value (corresponding to the key)\n\n        public Entry(K k, V v) { // constructor\n            key = k;\n            value = v;\n        }\n\n        /** Accessor method fvor the key **/\n        public K getKey() {\n            return key;\n        }\n\n        /** Accessor method for the value **/\n        public V getValue() {\n            return value;\n        }\n\n        /** Mutator method for the value **/\n        public void setValue(V v) {\n            this.value = v;\n        }\n\n        @Override\n        public String toString() {\n            return \"(`\" + key + \"`, `\" + value + \"`)\"; \n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    Entry&lt;K,V&gt;[] entry; // Dictionary\n    int nEntries; // number of entries in the dictionary\n\n    public ArrayMap(int N) { // Constructor\n        entry = new Entry[N];\n        nEntries = 0;\n    }\n\n    @Override\n    public int size() {\n        return nEntries;\n    }\n\n    @Override\n    public void put(K k, V v) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getkey().equals(k)) {\n                // Found\n                entry[i].setValue(v); // update the value\n                return;\n            }\n        }\n        // Key not found\n        entry[nEntries] = new Entry&lt;K,V&gt;(k, v); // insert (k,v)\n        nEntries++;\n    }\n\n    @Override\n    public V get(K k) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getKey().equals(k)) {\n                // Found\n                return entry[i].getValue();\n            }\n        }\n        // Not found\n        return null;\n    }\n\n    @Override\n    public V remove(K k) {\n        boolean found = false; // Indicate key not found\n        int loc = -1; // contains index of key\n        V ret = null; // contains the return value\n\n        for (int i = 0; i &lt; nEntires; i++) {\n            if (entry[i].getKey().equals(k)) {\n                found = true; // indicates key k was found\n                loc = i; // remember the index of the entry\n                break;\n            }\n        }\n\n        if (found) {\n            // Key found\n            ret = entry[loc].getValue(); // update return value\n            for (int i = loc + 1; i &lt; nEntries; i++) {\n                // delete entry [loc]\n                entry[i-1] = entry[i]; // shift array\n            }\n            nEntries--;\n        }\n        return ret;\n    }\n}\n\nProblems with the ArrayMap implementation:\n\nA dictionary is used to look up information (=value) for a given key.\nThe loop up operation get() is \\(\\mathcal{O}(n)\\).\n\nCan we do better than \\(\\mathcal{O}(n)\\)?\n\nYes, we can sort the array and use binary search to reduce the runtime to \\(\\mathcal{O}(\\log n)\\).\n\nCan we do better than \\(\\mathcal{O}(\\log n)\\)?\n\nYes, we can use hashing to reduce the runtime to \\(\\mathcal{O}(1)\\)."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#the-dictionary-data-structure",
    "href": "notes/cs171/14-Hashing/Hashing.html#the-dictionary-data-structure",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "",
    "text": "Note 1: Dictionary/Map as a Data Structure.\n\n\n\nDictionary/map (aka. associative array) is a data structure that consists of a collection of (key, value) pairs called an entry of a dictionary.\n\nNote: the key and the value can be composite.\n\n\n\n\nUsage of a dictionary:\n\nThe dictionary data structure is used to store (key, value) pairs where the user can loop up (=search) a value using the key.\nTo support its usage, a dictionary must provide the following operations:\n\nsize(): return the number of entries stored inside this dictionary.\nput(key, value)L if key is found in the dictionary, it updates the value with value. Otherwise, it inserts (key, value) into the dictionary.\nget(key): return the corresponding value if key is found, and return null otherwise.\nremove(key): remove the dictionary entry containing key (and return the corresponding vaue if key is found).\n\nThe most frequently used operation is get(key), so fast lookup is required!\n\nThe Dictionary interface:\n\npublic interface Dictionary&lt;K,V&gt; {\n    public int size(); // return number of entires in the dictionary\n    public void put(K key, V value); // insert or update (key, value) pair\n    public V get(K key); // return value associated with key; \n                         // return null if not found\n    public V remove(K key); // remove entry with key and return corresponding value\n}\n\nWe can implement the dictionary data structure using:\n\nAn array\nA linked list\n\nFor simplicity, we will implement the dictionary using an array. To achieve it, we need to:\n\nDefinition of the Entry class to represent an entry in a dictionary.\nDefinition of a class to represent a dictionary using an array.\nImplement the (support) methods of the Dictionary interface.\n\nThe Entry class and the ArrayMap implementation:\n\npublic class ArrayMap&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key; // The key (to look up)\n        private V value; // the value (corresponding to the key)\n\n        public Entry(K k, V v) { // constructor\n            key = k;\n            value = v;\n        }\n\n        /** Accessor method fvor the key **/\n        public K getKey() {\n            return key;\n        }\n\n        /** Accessor method for the value **/\n        public V getValue() {\n            return value;\n        }\n\n        /** Mutator method for the value **/\n        public void setValue(V v) {\n            this.value = v;\n        }\n\n        @Override\n        public String toString() {\n            return \"(`\" + key + \"`, `\" + value + \"`)\"; \n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    Entry&lt;K,V&gt;[] entry; // Dictionary\n    int nEntries; // number of entries in the dictionary\n\n    public ArrayMap(int N) { // Constructor\n        entry = new Entry[N];\n        nEntries = 0;\n    }\n\n    @Override\n    public int size() {\n        return nEntries;\n    }\n\n    @Override\n    public void put(K k, V v) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getkey().equals(k)) {\n                // Found\n                entry[i].setValue(v); // update the value\n                return;\n            }\n        }\n        // Key not found\n        entry[nEntries] = new Entry&lt;K,V&gt;(k, v); // insert (k,v)\n        nEntries++;\n    }\n\n    @Override\n    public V get(K k) {\n        for (int i = 0; i &lt; nEntries; i++) {\n            if (entry[i].getKey().equals(k)) {\n                // Found\n                return entry[i].getValue();\n            }\n        }\n        // Not found\n        return null;\n    }\n\n    @Override\n    public V remove(K k) {\n        boolean found = false; // Indicate key not found\n        int loc = -1; // contains index of key\n        V ret = null; // contains the return value\n\n        for (int i = 0; i &lt; nEntires; i++) {\n            if (entry[i].getKey().equals(k)) {\n                found = true; // indicates key k was found\n                loc = i; // remember the index of the entry\n                break;\n            }\n        }\n\n        if (found) {\n            // Key found\n            ret = entry[loc].getValue(); // update return value\n            for (int i = loc + 1; i &lt; nEntries; i++) {\n                // delete entry [loc]\n                entry[i-1] = entry[i]; // shift array\n            }\n            nEntries--;\n        }\n        return ret;\n    }\n}\n\nProblems with the ArrayMap implementation:\n\nA dictionary is used to look up information (=value) for a given key.\nThe loop up operation get() is \\(\\mathcal{O}(n)\\).\n\nCan we do better than \\(\\mathcal{O}(n)\\)?\n\nYes, we can sort the array and use binary search to reduce the runtime to \\(\\mathcal{O}(\\log n)\\).\n\nCan we do better than \\(\\mathcal{O}(\\log n)\\)?\n\nYes, we can use hashing to reduce the runtime to \\(\\mathcal{O}(1)\\)."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#the-hash-function",
    "href": "notes/cs171/14-Hashing/Hashing.html#the-hash-function",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "The Hash Function",
    "text": "The Hash Function\n\nInsight on how to improve the search performance of arrays.\n\nFact on arrays:\n\nArray access is very fast if access uses an array index.\n\nFact on dictionaries:\n\nEntries in a dictionary are looked up using its key.\n\nThe problem with the ArrayMap implementation of the dictionary is that entries of the dictionary are stored using an index that is not related to the key.\nTo improve the search operation for a dictionary stored in an array, we need to find a way to relate (=map) the key k to an index h of the array:\nh = hashFunction(k)\nThis way of storing data into an array is called hashing.\n\nHashing functions H():\n\nHash function is a function that maps a key k to a number h in the range [0, M-1], where M = length of the array. That is, \\(h=H(k)\\), where \\(h\\in[0,\\cdots,M-1]\\).\n\nH() is consistent: always gives the same answer for a given key.\nH() is uniform: the function values are distributed evenly across [0...M-1].\n\nA hash function is usually specified as the composition of 2 functions: \\(H(k)=H_2(H_1(k))\\), where\n\n\\(H_1(k)\\) is the hash code function that returns the integer value of the key k.\n\\(H_2(x)\\) is a compression function that maps a value \\(x\\) uniformly to the range \\([0, M-1]\\).\n\n\nThe hash code of a key:\n\nFact: all data inside a computer is stored as abinary number.\nThe Object class in Java contains a hashCode() method that returns the data stored in the Object as an integer.\nWe can use the hashCode() method as our \\(H_1(k)\\) function.\n\nThe compression function \\(H_2(x)\\)\n\nNotice from the previous discussion on the hash code \\(H_1(k)\\): \\(H_1(k)\\) uses the data stored in the key k to compute (deterministically) a hash code value.\nThe compression function \\(H_2(x)\\) has two purposes:\n\nMake sure that the return value is in the range \\([0, M-1]\\). (where \\(M\\) is the length of the array).\nScatter/randomize the input value \\(x=H_1(k)\\), so that the value \\(H_2(x)\\) is evenly/uniformly distributed over the range \\([0, M-1]\\).\n\nWhy do we use uniform randomization?\n\nThe array element used to stroe the diction entry is array index = H(k) = H2(H1(k)).\nUniform randomization will minimize the likelihoo/chance that 2 different keys being hashed to the same value (=array index) (a.k.a. collision).\n\nA commonly used compression function is the Multiply Add Divide (MAD) function:\nH2(x) = ( (ax + b) % p ) % M,   where p = some prime number\n           ^^^^^^^^^^^^\n            randomizes\n\nIn the MAD function, a and b are random numbers, and p is a prime number.\nIn the examples of this course, we will use p = 109345121 (a prime number), a = 123 and a = 456.\nNote: p must be greater than M (i.e., p &gt; M), otherwise, we will not use the full capacity of the array."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#hash-table",
    "href": "notes/cs171/14-Hashing/Hashing.html#hash-table",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "Hash Table",
    "text": "Hash Table\n\nTerminologies:\n\nHash function H(): maps a key k to an integer in the range [0, M-1]. H(k) = integer in [0, M-1].\nHash value h: the value returned by the hash function H(): h = H(k).\nBucket: the array element used to store an entry of the dictionary.\nCollision: A collision occurs when 2 different keys k1 and k2 have the same hash value. h1≠h2 but H(k1)=H(k2).\n\nIf there are n entries in a hash table of size M, how likely is it that 2 entries hash into the same bucket? \\[\n\\begin{aligned}\n\\mathbf{P}(\\text{all }n\\text{ entries use different buckets}) &= \\dfrac{M(M-1)\\cdots (M-n+1)}{M^n} \\\\\n&=\\dfrac{M!}{M^n(M-n)!}\\\\\n\\mathbf{P}(\\text{2 entries use the same buckt})&=1-\\dfrac{M!}{M^n(M-n)!}.\n\\end{aligned}\n\\]\n\nThere are 2 techniques to handle collision in hashing:\n\nClosed addressing (a.k.a. Separable Chaining):\n\nEntries are always stored in their hash bucket.\nEach bucket of the hash table is organized as a linked list.\n\n\nOpen addressing:\n\nEntries are stored in a different bucket than their hash buckets.\nA rehash algorithm is used to find an empty bucket.\n\n\n\n\n\nClosed Addressing (Separate Chaining)\n\nPreviously, we used the Entry&lt;K,V&gt; class in the ArrayMapo&lt;K,V&gt; implementation to store the dictionary entries.\n\nIn order to support separate chaining, the Entry&lt;K,V&gt; class must be modified to support a linked list.\n\npublic class HashTableSC&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n  /* ---------------- Nested Entry class ---------------- */\n  private class Entry&lt;K,V&gt; {\n      private K key; // key\n      private V value; // value\n      private Entry&lt;K,V&gt; next; // link to create a linked list\n\n      public Entry(K k, V V) { // constructor\n          key = k;\n          value = v;\n      }\n      /** Accessor method fvor the key **/\n      public K getKey() {\n          return key;\n      }\n      /** Accessor method for the value **/\n      public V getValue() {\n          return value;\n      }\n      /** Mutator method for the value **/\n      public void setValue(V v) {\n          this.value = v;\n      }\n      @Override\n      public String toString() {\n          return \"(`\" + key + \"`, `\" + value + \"`)\"; \n      }\n  }\n  /* ---------------- End of nested Entry class ---------------- */\n\n  public Entry&lt;K,V&gt;[] bucket; // The hash table\n  public int capacity; // capacity = bucket.length\n  int NItems; // number of entries in the hash table\n\n  // MAD formula: (Math.abs(a * HashCode + b) % p) % M\n  public int MAD_p; // prime number in the MAD alg\n  public int MAD_a; // multiplier in the MAD alg\n  public int MAD_b; // offset in the MAD alg\n\n  public HashTableSC(int M) { // create a hash table of size M\n      bucket = (Entry[]) new Entry[M]; // create hash table of size M\n      capacity = bucket.length; // capacity of has table\n      NItems = 0; // number of entries in the hash table\n\n      // Initialize MAD parameters\n      MAD_p = 109345121; // prime number\n      MAD_a = 123; // multiplier\n      MAD_b = 456; // offset\n  }\n\n  /** Hash function H(k) **/\n  public int hashValue(K key) {\n      int x = key.hashCode(); // hash code of the key\n      return (Math.abs(x * MAD_a + MAD_b) % MAD_p) % capacity;\n  }\n\n  /* ---------------------------------------------\n  The help method findEntry(k): find the Entry containing key in the hash table\n  return: Entry object containing key if found\n  return: null if not found\n  --------------------------------------------- */\n  public Entry findEntry(K k) {\n      int hashIdx = hashValue(k); // get hash index using key k\n      Entry&lt;K,V&gt; curr = bucket[hashIdx]; // curr = first of linked list\n\n      while (curr != null) {\n          if (curr.getKey().equals(k)) {\n              return curr;\n          }\n          curr = curr.next;\n      }\n      return null; // not found\n  }\n\n  @Override\n  public int size() {\n      return NItems;\n  }\n\n  @Override\n  public void put(K k, V v) {\n      int hashIdx = hashValue(k);\n      Entry&lt;K,V&gt; h = findEntry(k);\n      if (h != null) {\n          h.setValue(v); // update value with v\n      } else {\n          // Add newEntry as first element in the list at bucket[hashIdx]\n          Entry&lt;K,V&gt; newEntry = new Entry&lt;&gt;(k, v); // make new entry\n          newEntry.next = bucket[hashIdx]; // point to the first bucket\n          bucket[hashIdx] = newEntry; // make newEntry the first bucket\n          NItems++; // increment number of entries\n      }\n  }\n\n  @Override\n  public V get(K k) {\n      Entry&lt;K, V&gt; h = findEntry(k);\n      if (h != null) {\n          return h.getValue();\n      } else {\n          return null;\n      }\n  }\n\n  @Override\n  public V remove(K k) {\n      int hashIdx = hashValue(k);\n      // General case delete from linked list\n      Entry&lt;K,V&gt; previous = bucket[hashIdx];\n      Entry&lt;K,V&gt; current = bucket[hashIdx];\n\n      while (current != null && !current.getValue().equals(k)) {\n          previous = current;\n          current = current.next;\n      }\n\n      if (current != null) { // found\n          previous.next = current.next; // unlink current\n          NItems--; // decrement number of entries\n          return current.getValue();\n      } \n      return null; // not found\n  }\n}\n\n\n\n\n\n\n\nTip 1: Runtime Analysis of Closed Addressing\n\n\n\n\n\n\nConsider a hash table using separate chaining. Due to randomization of the hash value,\n\nSome entries in the hash table has no keys\nSome entries in the hash table has exactly 1 key.\nSome entries in the hash table has more than 1 key.\n\nOperations on a hash table always uses the hash value. The hash value will select one specific hash bucket.\n\nThe search key will be:\n\nFound in this hash bucket, or\nNot found in this hash bucket.\n\n\nTherefore, operations on a hash table will always examine all keys in one search bucket.\nTherefore, the running time of operations on a hash table is equal to the number of entries stored inside one bucket in the hash table.\n\nProblem: how many entries will be stored inside 1 bucket?\nFact: A search key that has hash value k is stored in the bucket k.\nTherefore, number of entries in bucket k is the number of keys where H(key) = k.\nNow, let’s estimate the number of entries stored in a bucket.\nBy the uniformity assumption, the random hash value H(key) is uniformly distributed over the range [0, M-1]. Then, each outcome is equally likely with probability of 1/M.\nSuppose there are a total of n items/entries hashed and stored in the hash table. According to the theory of probability, the number of items/entries in any bucket has a binomial probability distribution of \\(\\mathbf{BIN}\\left(n,p=\\dfrac{1}{M}\\right)\\).\nThen, the average number of entries in 1 bucket is \\(\\dfrac{n}{M}\\). So, the average running time for hash operations is \\(\\dfrac{n}{M}\\sim\\mathcal{O}(n)\\).\n\n\n\n\n\n\n\nOpen Addressing\n\nClosed addressing vs Open addressing:\n\nClosed addressing:\n\nIn closed addressing, each key is always stored in the hash bucket where the key is hashed to.\nClose addressing must use some data structure (e.g. linked list) to store multiple entries in the same bucket.\n\nOpen addressing:\n\nIn open addressing, each hash bucket will store at most one hash table entry.\nIn open addressing, a key may be stored in different bucket than where they key was hashed to.\nEntries used in open addressing:\n\nSince in open addressing, each hash bucket will store at most one hash table entry, the entries stored in open address do not have a link variable.\nTherefore, the Entry&lt;K,V&gt; class used in open addressing is different from the Entry&lt;K,V&gt; class used in closed addressing. In fact, we can use the Entry&lt;K,V&gt; defined the ArrayMap&lt;K,V&gt; implementation.\n\n\n\nCollision resolution in Open Addressing:\n\nIf a key is hashed to a bucket that is already occupied, we need to find another bucket to store the key. This process will be completed with an insert algorithm.\nThe insert algorithm will start at the hash index and find the next variable hash bucket that can be used to store the key.\nThe procedure to find the next available hash bucket is called rehashing.\n\nNote: rehashing is not random but deterministic (=computable).\n\n\nCommonly used Rehashing Algorithms to Resolve Collision in Open Addressing:\n\nLinear Probing: in linear probing, the hash table is searched sequentially starting from the hash index value.\n\nIn other words, the rehash function is Rehash(key) = (h + i)%M, where h = H(key) and i = 1, 2,...\n\nQuadratic Probing: uses the following rehash function: Rehash(key) = (h + i^2)%M, where h = H(key) and i = 1, 2,...\nDouble hashing: uses the following rehash function: Rehash(key) = (h + i*H2(key))%M, where h = H(key), h' = H'(key) is a second hash function, and i = 1, 2,...\n\nThe code for linear probing without remove():\n\npublic class HashTableLP&lt;K,V&gt; {\n    /* ---------------- Nested Entry class ---------------- */\n    private class Entry&lt;K,V&gt; {\n        private K key;   // The key (to loop up)\n        private V value; // The value (corresponding to the key)\n        public Entry(K k, V v) { // Constructor\n            key = k;\n            value = v;\n        }\n        public K getKey() { // Accessor method for the key\n            return key;\n        }\n        public V getValue() {  // Accessor method for the value\n            return value;\n        }\n        public void setValue(V value) {         // Mutator method for the value\n            this.value = value;\n        }\n        public String toString() {\n            return \"(\" + key + \",\" + value + \")\";\n        }\n    }\n    /* ---------------- End of nested Entry class ---------------- */\n\n    public Entry&lt;K,V&gt;[] bucket; // The Hash table\n    public int capacity;        // capacity == bucket.length\n    int    NItems;              // # items in hash table\n    // MAD formula: ( Math.abs(a * HashCode + b) % p ) % M\n    public int MAD_p;           // Prime number in the Multiply Add Divide alg\n    public int MAD_a;           // Multiplier   in the Multiply Add Divide alg\n    public int MAD_b;           // Offset       in the Multiply Add Divide alg\n\n    // Constructor\n    public HashTableLP(int M) {  // Create a hash table of size M\n        bucket = (Entry[]) new Entry[M]; // Create a hash table of size M\n        capacity = bucket.length;        // Capacity of this hash table\n        NItems = 0;                      // # items in hash table\n\n        MAD_p = 109345121;               // We pick this prime number...\n        MAD_a = 123;                     // a = non-zero random number\n        MAD_b = 456;                     // b = random number\n    }\n\n    // The hash function for the hash table\n    public int hashValue(K key) {\n        int x = key.hashCode(); // Uses Object.hashCode()\n        return ((Math.abs(x*MAD_a + MAD_b) % MAD_p) % capacity);\n    }\n    public int size() {\n        return NItems;\n    }\n\n    public void put(K k, V v) {\n        int hashIdx = hashValue(k); // find the hash index for key k\n        int i = hashIdx;\n        do {\n            if (bucket[i] == null) { // is entry empty?\n                bucket[i] = new Entry&lt;K,V&gt;(k, v);\n                return;\n            } else if (entry[i].getKey().equals(k)) { // is entry k?\n                entry[i].setValue(v); // update value\n                return;\n            } \n            i = (i + 1) % capacity; // rehash\n        } while (i != hashIdx); // all entires searched!\n        System.out.println(\"Full\");\n    }\n\n    public V get(K k) {\n        int hashIdx = hashValue(k); // find the hash index for key k\n        int i = hashIdx;\n        do {\n            if (bucket[i] == null) { // is entry empty?\n                return null;\n            } else if (entry[i].getKey().equals(k)) { // is entry k?\n                return entry[i].getValue(); // return value\n            } \n            i = (i + 1) % capacity; // rehash\n        } while (i != hashIdx); // all entires searched!\n        return null; // not found\n    }\n}\n\nNow, let’s consider the remove() method. If we remove the entry stored in bucket[i], then we will not be able to find the entry stored in bucket[i+1].\n\nTherefore, we need to move the entry stored in bucket[i+1] to bucket[i].\nHowever, if we move the entry stored in bucket[i+1] to bucket[i], then we will not be able to find the entry stored in bucket[i+2].\nThat means, instead of simply moving the entry stored in bucket[i+1] to bucket[i], we need alternative method to solve this problem.\n\nTo solve the deletion problem, a hash table using open addressing uses a special entry called AVAILABLE:\npublic Entry&lt;K,V&gt; AVAILABLE = new Entry&lt;&gt;(null, null);\n\nWhen an existing entry in the hash table is removed, the entry is replaced by the AVAILABLE entry.\nWhen we are searching for key k, then\n\nAVAILABLE must be treated as an empty bucket (i.e., it does not contain any key).\nThe rehash algorithm must continue with the next search location.\n\npublic class HashTableLP&lt;K,V&gt; implements Dictionary&lt;K,V&gt; {\n/* ---------------- Nested Entry class ---------------- */\nprivate class Entry&lt;K,V&gt; {\n    private K key;   // The key (to loop up)\n    private V value; // The value (corresponding to the key)\n    public Entry(K k, V v) { // Constructor\n        key = k;\n        value = v;\n    }\n    public K getKey() { // Accessor method for the key\n        return key;\n    }\n    public V getValue() {  // Accessor method for the value\n        return value;\n    }\n    public void setValue(V value) {         // Mutator method for the value\n        this.value = value;\n    }\n    public String toString() {\n        return \"(\" + key + \",\" + value + \")\";\n    }\n}\n/* ---------------- End of nested Entry class ---------------- */\n\npublic Entry&lt;K,V&gt;[] bucket; // The Hash table\npublic int capacity;        // capacity == bucket.length\nint    NItems;              // # items in hash table\n// MAD formula: ( Math.abs(a * HashCode + b) % p ) % M\npublic int MAD_p;           // Prime number in the Multiply Add Divide alg\npublic int MAD_a;           // Multiplier   in the Multiply Add Divide alg\npublic int MAD_b;           // Offset       in the Multiply Add Divide alg\n\npublic Entry&lt;K,V&gt; AVAILABLE = new Entry&lt;&gt;(null, null); // special entry for remove()\n\n// Constructor\npublic HashTableLP(int M) {  // Create a hash table of size M\n    bucket = (Entry[]) new Entry[M]; // Create a hash table of size M\n    capacity = bucket.length;        // Capacity of this hash table\n    NItems = 0;                      // # items in hash table\n\n    MAD_p = 109345121;               // We pick this prime number...\n    MAD_a = 123;                     // a = non-zero random number\n    MAD_b = 456;                     // b = random number\n}\n\n// The hash function for the hash table\npublic int hashValue(K key) {\n    int x = key.hashCode(); // Uses Object.hashCode()\n    return ((Math.abs(x*MAD_a + MAD_b) % MAD_p) % capacity);\n}\n\n@Override\npublic int size() {\n    return NItems;\n}\n\n@Override\npublic void put(K k, V v) {\n    int hashIdx = hashValue(k); // find the hash index for key k\n    int i = hashIdx;\n    int firstAvail = -1; // -1 means: no AVAILABLE entry found\n\n    do { // search for key k\n        if (bucket[i] == null) { // is entry empty?\n            if (firstAvail = -1 ) { // No AVAILABLE entry found\n                bucket[i] = new Entry&lt;K,V&gt;(k, v);\n                // insert (k,v) in this empty bucket\n            } else { // AVAILABLE entry found\n                bucket[firstAvail] = new Entry&lt;K,V&gt;(k, v);\n                // insert (k,v) in the first AVAILABLE bucket\n            }\n            return;\n        } else if (bucket[i] == AVAILABLE) {\n            if (firstAvail == -1) {\n                firstAvail = i; // remember the first AVAILABLE entry\n            }\n        } else if (entry[i].getKey().equals(k)) { // is entry k?\n            entry[i].setValue(v); // update value\n            return;\n        } \n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n\n    if (firstAvail == -1) {\n        System.out.println(\"Full\");\n    } else {\n        bucket[firatAvail] = new Entry&lt;&gt;(k,v);\n    }\n}\n\n@Override\npublic V get(K k) {\n    int hashIdx = hashValue(k); // find the hash index for key k\n    int i = hashIdx;\n    do {\n        if (bucket[i] == null) { // is entry empty?\n            return null;\n        } else if (bucket[i] == AVAILABLE) {\n            // Do NOT Test bucket[i]\n            // continue\n        } else if (entry[i].getKey().equals(k)) { // is entry k?\n            return entry[i].getValue(); // return value\n        } \n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n    return null; // not found\n}\n\n@Override\npublic V remove(K k) {\n    int hashIdx = hashValue(k);\n    int i = hashIdx;\n\n    do {\n        if (bucket[i] == null) { // Is bucket empty?\n            return null; // Not found\n        } else if (bucket[i] == AVAILABLE) {\n            // Do NOT Test bucket[i]\n            // continue\n        }  else if (bucket[i].getKey().equals(k)) { // does bucket contain k?\n            V retVal = bucekt[i].getValue();\n            bucket[i] = AVAILABLE; // mark as deleted\n            return retVal;\n        }\n        i = (i + 1) % capacity; // rehash\n    } while (i != hashIdx); // all entires searched!\n    return null; // not found\n}\n}\n\nClustering in Learning Hashing:\n\nSuppose the hash table currently stores the entries as follows:\n            0   1   2   3   4   5   6   7   8   9  \nentry[] = |   | A | B | C | D | E | F | G | H |   | \n\nThen, if we want to insert a key k with a hash value in the range [1...9]m we will have to store it in the bucket 9.\nThis is called clustering.\n\nTo alleviate clustering, other rehashing methods can be used:\n\nQuadratic Probing\nDouble hashing.\n\n\n\n\n\nRunning Time Analysis\n\nStrength and Weakness of a Hash Table\n\nA hash table is fast when entries are not clustered.\nIn this case, the running time of operations such as get(), put() and remove() is \\(\\mathcal{O}(1)\\).\n\nThe search will find the key immediately in the hash bucket.\nOr else, the search will terminate in the next step because it finds an empty (null) bucket.\n\nA hash table is slower when entries are clustered. In those cases, we need more comparison operations.\n\nWorse case running time of hashing with linear probing: when the hash table is full.\n\nThen, get(), put(), and remove() may need to scan the entire hash table to find the entry.\nTherefore, worse case running time of linear probing is n/2: The scan will examine approximately half of all the entries.\n\nAverage case running time analysis of linear probing:\n\nConsider the get() algorithm using linear probing. The get() method will return when it find\n\nan empty bucket, or\nthe key k\n\nConsider the put() algorithm using linear probing. The put() method will return when it find\n\nan empty bucket, or\nthe key k\n\nConsider the remove() algorithm using linear probing. The remove() method will return when it find\n\nan empty bucket, or\nthe key k\n\nSimplifying assumption: to keep the running time analysis simple, we will assume that where are no AVAILABLE entries in the hash table.\nFrom the observation of get(), put(), and remove() algorithms:\n\nThe running time of them depends on the number of entries we need to check in order to find the key k or an empty bucket.\nSo, the worse case running time is when the search ends by finding an empty bucket (takes longer time).\nTherefore, average running time of get(), put(), and remove() = average number of compare operations to find an empty bucket.\n\n\nLoad factor and the probability of finding an empty bucket.\n\n\n\n\n\n\n\nNote 2: Load Factor\n\n\n\nLoad factor (a.k.a. occupancy level) is defined as \\[\n\\alpha=\\dfrac{\\text{number of entries in hash table}}{\\text{size of the hash table}}=\\dfrac{n}{M}.\n\\]\n\nThe load factor \\(\\alpha\\) is a measure of how full the hash table is.\n\nThen, the probability (=likelihood) that a hash bucket is occuped is \\[\\begin{aligned}\\mathbf{P}(\\text{bucket }i\\text{ is occupied})&=\\dfrac{\\text{number of entries in the hash table}}{\\text{total number of buckets in the hash table}}\\\\&=\\alpha.\\end{aligned}\\]\nSo, the probability (=likelihood) that a hash bucket is empty is \\(\\mathbf{P}(\\text{buket }i\\text{ is empty})=1-\\alpha\\).\n\n\n\n\n\nThe average running time of get(), put(), and remove() is found by computing:\n\nHow often (frequent) do we need to check 1 entry to find an empty slot (=\\(f_1\\))? How many operations did we perform in this case? (=\\(c_1\\))\nHow often (frequent) do we need to check 2 entry to find an empty slot (=\\(f_2\\))? How many operations did we perform in this case? (=\\(c_2\\))\n…\nThe average running time of get(), put(), and remove() is equal to \\[\\text{Average running time}=f_1c_1+f_2c_2+f_3c_3+\\cdots\\]\n\nHow often do we need to check 1 entry to find an empty slot?\n\nThe probability of finding a bucket to be empty = \\(1-\\alpha\\).\nWe check 1 entry (=the hash bucekt) and fids an empty bucket. \\[\n\\mathbf{P}(\\text{check 1 bucket to find an empty bucket})=1-\\alpha=f_1\\] \\[\n\\text{number of check operations performed} = 1=c_1\n\\]\n\nSimilarly, in the case of checking 2 entries to find an empty bucket, we have: \\[\n\\mathbf{P}(\\text{check 2 bucket to find an empty bucket})=\\alpha(1-\\alpha=)f_2\\] \\[\n\\text{number of check operations performed} = 2=c_2\n\\]\nSo, we know the average running time of get(), put(), and remove() is equal to \\[\n\\begin{aligned}\\text{Average running time}&=f_1c_1+f_2c_2+\\cdots+f_nc_n\\\\\n&=(1-\\alpha)\\cdot1+\\alpha(1-\\alpha)\\cdot2+\\alpha^2(1-\\alpha)\\cdot3+\\cdots\\\\\n&=(1-\\alpha)[1+2\\alpha^1+3\\alpha^2+4\\alpha^3+\\cdots]\n\\end{aligned}\n\\]\n\nSuppose \\[S=1+2\\alpha^1+3\\alpha^2+4\\alpha^3+\\cdots.\\] To compute the sum, we used MATLAB\n\nsyms a k assume(a &gt; 0 & a &lt; 1) \nsymsum((k+1)*(a^k), k, 0, inf)\n\n&gt; &gt; &gt; ans = 1/(a - 1)\\^2\n\nSo, the average running time of get(), put(), and remove() is equal to \\[(1-\\alpha)\\cdot\\dfrac{1}{(1-\\alpha)^2}=\\dfrac{1}{1-\\alpha}.\\]\n\nSummary:\n\n\\(\\alpha\\) = the load factor or occupancy level.\nThe probability (=likelihood) of finding a bucket to be empty = \\(1-\\alpha\\).\nThe average runtime of get(), put(), and remove() is the average number of compare operations performed to find an empty bucket. This quantity is equal to \\(\\dfrac{1}{1-\\alpha}\\).\nExample: If \\(\\alpha=10\\%\\), then (because 90% of the time we find an empty bucket), average number bucekts searched is 1/(1-0.1) = 1/0.9 ~= 1.1."
  },
  {
    "objectID": "notes/cs171/14-Hashing/Hashing.html#double-hashing",
    "href": "notes/cs171/14-Hashing/Hashing.html#double-hashing",
    "title": "Lecture 13 Hashing (Hash Table): Implementation and Runtime Analysis",
    "section": "Double Hashing",
    "text": "Double Hashing\n\nConsequence of increasing/decreasing the hash table size:\n\nDue to the dependency of the hash function on the array size M, we have the following unfortunate consequence: Changing the array size will also change the hash function.\nThis means: the entries stored using the old hash function cannot be found using the new hash function.\nIn other words, when we increase/decrease the hash table size, we must rehash all the entries using the new hash function.\n\nNaïve way to increase/decrease the hash table size.\n\nBecause the hash function changes with the hash table size, we must rehash all the keys and insert them into the new hash table.\nA naïve way to do this is to create a new hash table with the new size, and then insert all the keys into the new hash table.\n\npublic void doubleHashTable() {\n  Entry[] oldBucket = bucket; // save the old hash table\n\n  // Double the size of the bucket\n  bucket = (Entry[]) new Entry[2 * oldBucket.length];\n  capacity = 2 * oldBucket.length;\n\n  // Rehash all the entries in the old hash table\n  for (int i = 0; i &lt; oldBucket.length; i++) {\n      if (oldBucket[i] != null && oldBucket[i] != AVAILABLE) {\n          this.put(oldBucket[i].getKey(), oldBucket[i].getValue());\n      }\n  }\n}"
  }
]