[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jiuru Lyu",
    "section": "",
    "text": "Hi! My name is Jiuru Lyu, and I am a junior at Emory University studying Applied Mathematics. In my leisure time, I enjoy coffee brewing, traveling, photograph, and commercial aviation.\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\nIB Math AA HL Notes\n\n\nCollege Level Math\n\nMath Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\n\n\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\n\n\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\n\n\n\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\n\n\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "about.html#high-school-level-math",
    "href": "about.html#high-school-level-math",
    "title": "Class Notes",
    "section": "",
    "text": "IB Math AA HL Notes\nCollege Level Math Math Fundamentals\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\nProof Practice\nApplied Mathematics\n(Ordinary) Differential Equations\nNonlinear Optimization\nNumerical Analysis\nData Science, Statistics, and Causal Inference\nIntroduction to Causal Inference\nMathematical Statistics I: Probability\nMathematical Statistics II: Statistical Inference\nGoogle Data Analytics Learning Notes\nComputer Science\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nOther Fields\nIntroduction to Sociology"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Class Notes",
    "section": "",
    "text": "High School Level Math\n\nIB Math AA HL Notes\n\n\n\nCollege Level Math\n\nMath Fundamentals\n\nCalculus II\nMultivariable Calculus/Advanced Calculus/Calculus III\nLinear Algebra\nMathematical Proofs\n\n\n\nApplied Mathematics\n\nOrdinary Differential Equations\nNonlinear Optimization\nUndergraduate-Level Numerical Analysis\n\n\n\nData Science, Statistics, and Causal Inference\n\nIntroduction to Causal Inference\nMathematical Statistics\nGoogle Data Analytics Learning Notes\n\n\n\n\nComputer Science\n\nObject-Oriented Programming & Introduction to Data Structures\nIntroduction to Data Structure and Algorithms\nDatabase Systems\n\n\n\nOther Fields\n\nIntroduction to Sociology\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/MathStats.html#statistical-inference",
    "href": "notes/MathStats.html#statistical-inference",
    "title": "Mathematical Statistics",
    "section": "Statistical Inference",
    "text": "Statistical Inference"
  },
  {
    "objectID": "notes/Proofs.html#proof-practice",
    "href": "notes/Proofs.html#proof-practice",
    "title": "IB Math AA HL Notes",
    "section": "Proof Practice",
    "text": "Proof Practice"
  },
  {
    "objectID": "notes/LA.html#linear-algebra-done-right",
    "href": "notes/LA.html#linear-algebra-done-right",
    "title": "Linear Algebra",
    "section": "Linear Algebra Done Right",
    "text": "Linear Algebra Done Right"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "My Blogs",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nblog post title\n\n\n\nQuarto\n\n\nTest\n\n\nBlog\n\n\n\nblog post description (appears underneath the title in smaller text) which is included on the listing page\n\n\n\nJiuru Lyu\n\n\nOct 26, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html",
    "href": "blogs/2024-10-26-test-blog/index.html",
    "title": "blog post title",
    "section": "",
    "text": "This is my test-blog to show case how to generate a blog post in Quarto.\n\n\nIt is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "href": "blogs/2024-10-26-test-blog/index.html#footnotes",
    "title": "blog post title",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAlso see other useful blogs as reference!↩︎"
  },
  {
    "objectID": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "href": "blogs/2024-10-26-test-blog/index.html#some-random-thoughts",
    "title": "blog post title",
    "section": "",
    "text": "It is important to note that the front matter of the blog post is different from the front matter of the index page, notes page, and blogs page. The front matter of the blog post is used to provide metadata about the blog post, such as the title, description, author, date, categories, image, and draft status. The content of the blog post is written in markdown and can include text, images, links, and other markdown elements."
  },
  {
    "objectID": "notes/cs171.html",
    "href": "notes/cs171.html",
    "title": "CS 171 Introduction to Computer Science II",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nLecture 1 Introduction & Review\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithm\n\n\nOOP\n\n\nData Structure\n\n\n\nThis lecture introduces the purpose of studying algorithms and data structures. It also does some review on Java and its code basics.\n\n\n\n\n\nAug 29, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 2 Objects and Classes\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nObjects\n\n\nClass\n\n\n\nThis lecture introduces the concepts of OOP in Java.\n\n\n\n\n\nSep 7, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 3 Packages\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nPakcage\n\n\n\nBased on Objects and Classes, this lecture extends the idea and introduces Packages and how it works in Java.\n\n\n\n\n\nSep 16, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 4 Inheritance and Polymorphism\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInhertiance\n\n\nPolymorphism\n\n\n\nThis lecture is a more detailed lecture on inheritance and polymorphism, two very essential concepts in OOP.\n\n\n\n\n\nSep 19, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 5 Abstract Classes and Interfaces\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nOOP\n\n\nInterface\n\n\nAbstract Class\n\n\n\nThis lecture touches on abstract classes and extends it to interfaces. It also introduces Iterator and Iterable interfaces in Java and how to use them in practice. \n\n\n\n\n\nOct 4, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 6 Generic Classes and Generic Methods\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nGenerics\n\n\n\nThis lecture discusses the use of generic class and generic methods in Java. It also touches on the use of generic classes in practice.\n\n\n\n\n\nOct 10, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 7 Array Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nArray\n\n\n\nStarting from this lecture, we discuss some data structures. The very basic data structure of discussion is the array data structure.\n\n\n\n\n\nOct 14, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 8 Stack\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nStack\n\n\n\nThis lecture discusses the stack data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 9 Queue Data Structure\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nQueue\n\n\n\nThis lecture discusses the queue data structure and its implementation in Java.\n\n\n\n\n\nOct 18, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 10 Linked List\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nData Structure\n\n\nLinked List\n\n\n\nThis lecture discusses the linked list data structure and its implementation in Java.\n\n\n\n\n\nNov 2, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\nLecture 11 Complexity Analysis\n\n\n\n\n\n\nCoding\n\n\nJava\n\n\nAlgorithms\n\n\nComplexity Analysis\n\n\n\nStarting from this lecture, we will discuss some sorting algorithms and their complexity analysis. This lecture offers an overview of running time analysis.\n\n\n\n\n\nNov 11, 2023\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#introduction-to-stack",
    "title": "Lecture 8 Stack",
    "section": "",
    "text": "There are 2 commonly used data structures:\n\nStack (LIFO)\nQueue (FIFO)\n\nA stack is a data structure that organize the stored data in a Last In First Out (LIFO) manner.\nTo achieve the LIFO behavior, the stack only provide the following 2 methods to access the data stored in a stack:\n\npush(x): add x to the “top” of the stack.\npop(): remove the item at the “top” of the stack and return it.\nThe item removed by pop() is always the last item that was pushed.\n\nMethod invocation/return:\n\nIf the order of method invocation is\n\nM1() --&gt; M2() --&gt; M3() --&gt; M4()\n\nThen the order in which the methods return form their invocation is the reverse order:\n\nM4() --&gt; M3() --&gt; M2() --&gt; M1()\n\nSome computer algorithms/processes with a natural LIFO behavior: undo algorithm in a text editor (it uses a stack to store the history of edit changes); back algorithm in a browser (it uses a stack to store the browser history)"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#the-stack-interface",
    "title": "Lecture 8 Stack",
    "section": "The Stack Interface",
    "text": "The Stack Interface\n\nThe stack interface definition:\n\nThe stack only defines a behavior on the access of the data stored in a stack: pop() must return the last item that was pushed\nThe stack does not specify how the data must be stored.\nThere are different ways to implement the same behavior\n\npublic interface MyStackInterface&lt;E&gt; {\n  boolean isEmpty(); // returns true if stack is empty\n  boolean isFull(); // returns true if stack is full\n  void push(E e); // pushes element e on the stack\n  E pop(); // Remove the element at the top of the stack and return it\n  E peek(); // Return the element at the top without removing it\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implementing-the-stack-with-a-fixed-size-array",
    "title": "Lecture 8 Stack",
    "section": "Implementing the Stack with a fixed size array",
    "text": "Implementing the Stack with a fixed size array\n\nThe basic implementation of a Stack is using:\n\nA fixed size array to store the data items\nA stackTop index variable to record the first open position in the array\n\nThe initial state of the stack when it is instantiated (=created): stackTop = 0 (can also use stackTop = -1)\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return; // Or: throw an exception\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        return item[stackTop]; // (2) return item\n    }\n}\n\nSee IntegerStack.java and TestIntegerStack.java."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#implement-the-stack-with-a-dynamic-array",
    "title": "Lecture 8 Stack",
    "section": "Implement the stack with a dynamic array",
    "text": "Implement the stack with a dynamic array\n\nThe stack can be implemented using a dynamic array\n\npublic class IntegerStack implements Stack&lt;Integer&gt; {\n    private Integer[] item;\n    private int stackTop;\n    private final double DELTA = 0.25;\n    \n    public IntegerStack(int N) { // Create a stack of size N\n        item = new Integer[N];\n        stackTop = 0;\n    }\n    public boolean isEmpty() { // Test if stack is empty\n        return stackTop == 0;\n    }\n    public boolean isFull() { // Test if stack is empty\n        return stackTop == item.length;\n    }\n    public void push(Integer e) {\n        if (isFull()) {\n            // Double the array size\n            Integer[] temp = new int[2 * item.length];\n            for (int i = 0; i &lt; item.length; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        item[stackTop] = e; // (1) store item\n        stackTop++; // (2) increment stackTop\n    }\n    public Integer pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // Or: throw an exception\n        }\n        stackTop--; // (1) decrement stackTop\n        Integer retVal = item[stackTop];\n        if (stackTop &lt; DELTA * item.length && item.length &gt;= 2) {\n            // Reduce the array by half\n            temp = new int[item.length / 2];\n            for (int i = 0; i &lt;= stackTop; i++) {\n                temp[i] = item[i];\n            }\n            item = temp;\n        }\n        return retVal; // (2) return item\n    }\n}\n\nThe value DELTA determines when we will reduce the size of the array: DELTA is a wastage threshold:\n\nWhen only the fraction of DELTA of the array is being used, we will reduce the wastage.\nSince we will reduce the array by half, DELTA must be at most 0.5. Otherwise, we will discard some valid entries in the stack.\nDELTA = 0.25 is actually better than 0.5\n\nRunning Time Analysis: Consider the push() algorithm using a dynamic array. On average, how many “store” statements are executed for each push() invocation?\n\nWhen the stack is not full, the push() invocation will execute 1 store statement.\nWhen the stack if full, the push() invocation will execute (1 + item.length) store statement.\nSuppose we execute \\(N\\) push() operations:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# times exec push()\n1\n2\n3\n4\n5\n6\n7\n8\n\\(\\cdots\\)\n\\(N\\)\n\n\n\n\n# store statements to store item pushed\n1\n1\n1\n1\n1\n1\n1\n1\n\\(\\cdots\\)\n1\n\n\n# store statements to double array\n1\n2\n0\n4\n0\n0\n0\n8\n\\(\\cdots\\)\n\\(M\\leq N\\)\n\n\n\n\nTherefore, total store statements executed for \\(N\\) push() invocations: \\[(1+1+\\cdots+1)+(1+2+4+\\cdots+M)\\text{ where }M\\le N\\]\n\nConsider \\(S=1+2+4+\\cdots+M\\): \\[\\begin{aligned}S=1+&2+4+\\cdots+M\\\\2S=\\quad\\ \\ &2+4+8+\\cdots+2M\\\\S=2S-S&=2M-1\\end{aligned}\\]\nTherefore, total store statements executed is \\[N+(2*M-1)\\leq N+2*N-1=3N-1\\]\nHence, average # store statement for 1 push() invocation is \\(\\dfrac{(3N-1)}{N}\\approx3\\)."
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#generic-stack",
    "title": "Lecture 8 Stack",
    "section": "Generic Stack",
    "text": "Generic Stack\n\nJava does not allow instantiation of a generic array, so the following code will cause error messages:\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = new T[N]; // Create an array of T objects --&gt; error\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nHowever, there’s a simple hack to work around this Java restriction.\n\npublic class ArrayStack&lt;T&gt; implements Stack&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public ArrayStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects, and casting\n        stackTop = 0;\n    }\n    // other methods...\n}\n\nIn this way, Java will report warning messages (not fatal errors), so our program will still compile and run.\n\npublic class GenericStack&lt;T&gt; implements MyStackInterface&lt;T&gt; {\n    private T[] item;\n    private int stackTop;\n\n    public GenericStack(int N) {\n        item = (T[]) new Object[N]; // Create an array of Object objects\n        // This will cause some warning, but it will compile (Java does not know if the casting will be successful)\n        // Why this will work: If we are working with unbounded generic types,\n        // we know T will be interpreted as Object by Java. Then we will create\n        // an array of Object, then cast it into our desired type T\n        stackTop = 0;\n    }\n    @Override\n    public boolean isEmpty() {\n        return stackTop == 0;\n    }\n\n    @Override\n    public boolean isFull() {\n        return stackTop == item.length;\n    }\n\n    @Override\n    public void push(T t) {\n        // if the array is full, then double the size of the array\n        if (isFull()) {\n            System.out.println(\"Full\");\n            return;\n        }\n        item[stackTop] = t;\n        stackTop++;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\");\n            return null; // or throw an exception\n        }\n        stackTop--; // (1) decrease stackTop\n        return item[stackTop]; // return item\n    }\n\n    @Override\n    public T peek() {\n        return item[stackTop - 1];\n    }\n\n    public String toString(){\n        String result = \"\";\n        for (int i = 0; i &lt; stackTop; i++) {\n            result += item[i] + \" \";\n        }\n        return result;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#javas-stack-library",
    "title": "Lecture 8 Stack",
    "section": "Java’s Stack Library",
    "text": "Java’s Stack Library\n\nThe Java library contains a generic Stack class: java.util.Stack\nTo instantiate Stack objects:\n\nStack&lt;Integer&gt; iStack = new Stack&lt;&gt;(); // Integer Stack\nStack&lt;String&gt; sStack = new Stack&lt;&gt;(); // String Stack\n\nThe Stack class contains the following instance methods: boolean empty(); E peek(); E push(E item); E pop().\nFor some reasons, the Stack class is a subclass of the Vector class, which can access the sotred data using an index.\n\nAs a subclass, Stack inherits those methods:\n\nget(int index); // Returns the element at the specified position\nremove(int index); // Removes the element at the specified position\n\nHowever, this inheritance makes the FIFO behavior not guaranteed. ## Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#application-of-stack-reverse-polish-expression-evaluation",
    "title": "Lecture 8 Stack",
    "section": "Application of Stack: Reverse Polish Expression Evaluation",
    "text": "Application of Stack: Reverse Polish Expression Evaluation\n\nThere are 3 ways to write arithmetic expressions:\n\nIn-fix: operators are placed between their operands: \\((A+B)\\times C=(A+B)\\times C\\).\nPre-fix: operators are placed before their operands: \\(\\times + A\\ B\\ C\\ =(A + B)\\times C\\).\nPost-fix: operators are placed after their operands: \\(A\\ B+C\\times=(A+B)\\times C\\).\nThe pre-fix and post-fix notations do no use parenthesis to write arithmetic expressions.\n\nReverse Polish Notation (RPN):\n\nThe operator always follows its (2) operands: 3 4 + ==&gt; 3 + 4 = 7\nWhen we evaluate an operation in RPN, the result is used an operand of another operation: 3 4 + 1 - ==&gt; 7 1 - ==&gt; 6\nConclusion:\n\nEach operator will operate on its proceeding 2 operands.\nEach operator will produce a result that will be the operand of some subsequent operator.\n\nWe use a stack to store the operands. Whenever we reach an operator, we evaluate the operation with the two operands at the top of the stack.\n\nimport java.util.Stack;\npublic class EavluatePRN {\n  public static void main(String[] args) {\n      System.out.println(evalRPN(args));\n  }\n\n  /**\n   * Reverse Polish Notation (RPN):\n   *      3 4 + ===&gt; 3 + 4 = 7\n   *      - Each operator will operate on its proceeding 2 operands\n   *      - Each operator will produce a result that will be the operand of some subsequent operator\n   * We will use a Stack to implement this algorithm\n   * @param inp = array of String representing an RPN expression (e.g.: \"3\" \"4\" \"+')\n   */\n  public static int evalRPN(String[] inp) {\n      Stack&lt;Integer&gt; opStack = new Stack&lt;&gt;(); // Stack containing the prior oprands\n      String s; // Help variable containg the next symbol\n      for (int i = 0; i &lt; inp.length; i++) {\n          s = inp[i]; // s = next item/symbol in input (as String !)\n          if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) {\n              // the next symbol is an operator\n              int o2 = opStack.pop(); // Get the last 2 operands\n              int o1 = opStack.pop();\n\n              int r = operate(s, o1, o2); // Perform operation\n              opStack.push(r); // Save result (operand) on stack\n\n          } else { // the next symbol is an oprands\n              opStack.push(Integer.parseInt(s)); // Save number as Integer\n          }\n      }\n      return opStack.pop(); // Return result (was saved on stack)\n  }\n\n  public static int operate(String op, int o1, int o2) {\n      if (op.equals(\"x\")) { // Multiply\n          return o1 * o2;\n      } else if (op.equals(\"/\")) {\n          return o1/o2;\n      } else if (op.equals(\"+\")) {\n          return o1 + o2;\n      }\n      else if (op.equals(\"-\")) {\n          return o1 - o2;\n      } else {\n          return 0;\n      }\n  }\n}"
  },
  {
    "objectID": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "href": "notes/cs171/09-Stack-Data-Structure/Stack Data Structure.html#stack-application-edsger-dijkstra-algorithm-for-fully-parenthesized-arithmetic-expression",
    "title": "Lecture 8 Stack",
    "section": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression",
    "text": "Stack Application: Edsger Dijkstra Algorithm for Fully Parenthesized Arithmetic Expression\n\nProblem description:\n\nWe are given a fully parenthesized arithmetic expression using only x, /, +, and - operations.\nWrite an algorithm to evaluate expressions in this form.\nWe will need 2 stakcs:\n\nAn operand stack that stores the operands in the input, and\nAn operator stack that stores the operators in the input.\n\n\nAlgorithm:\n\nFind the first occurrence of a right parenthesis ): observe the last 2 operands and the last operation prior to the right parenthesis.\n\nThis guarantees the most inner () will be the first to be evaluated.\nThe result of an operation must be pushed on to operand stack.\n\nThen, we can reduce the parenthesis and find the next earliest occurrence of the right parenthesis.\nRepeat the steps until the input array is exhausted.\nThe left parenthesis ( does not convey and information.\n\nimport java.util.Stack;\npublic class Dijkstra2Stackalg {\n  public static Integer eval(String[] inp) {\n      Stack&lt;Integer&gt; operandStck = new Stack&lt;&gt;();\n      Stack&lt;String&gt; operatorStck = new Stack&lt;&gt;();\n      String s;\n\n      for (int i = 0; i &lt; inp.lengthl i++) {\n          s = inp[i];\n          if (s.equals(\"(\")) {\n              // do nothing\n          } else if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"x\") || s.equals(\"/\")) { // s is an operator\n              operatorStck.push(s);\n          } else if (s.equals(\")\")) { // compute the must inner ()\n              int o2 = operandStck.pop();\n              int o1 = operandStck.pop();\n              String op = operatorStck.pop();\n              int r = operate(op, o1, o2);\n              operandStck.psuh(r);\n          } else { // s is a number\n              operandStck.push(s);\n          }\n      }\n      return operandStck.pop();\n  }\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "",
    "text": "Problem: we need to write a program (software) to solve a new problem (How to re-sue existing software to build more complex software prior to ~1995, invention of OOP)\n\nWe want to write a NewClass class to solve the problem\nWe find a program (SomeClass) that can be used as the starting point to build our more complex software.\nWe make a copy of the program.\nThen, we make changes to the copy of software, so the new software does what we want.\nHowever, we have the problem of:\n\nRedundancy: we can have multiple copies of the same method\nHard to maintain programs: when we update the original software (from which we made the new software), we may need to update our programs that are based on the existing software\n\n\nAfter the invention of OOP, we define (not copying!) the new class to inherit from the original class.\n\nThe new class will inherit(=receive) all the variables and (normal) methods from an existing class\n\n\n\n\n\n\n\n\nTip 1: Example of Inheritance\n\n\n\n\n\npublic class SomeClass{\n  public int x;\n  public SomeClass{ \n      x = 99;\n  }\n  public void method1() {\n      System.out.println(\"I am SomeClass.method1(). x = \" + x);\n  }\n  public void method2 () {\n      System.out.println(\"I am Someclass.method2(). x = \" + x);\n  }\n}\npublic class NewClass extends SomeClass{ \n  NewClass() { }\n  // No other methods defined\n}\npublic static void main(String[] args) {\n  NewClass b = new NewClass();\n  b.method1(); // Invokes SomeClass.method1()\n  b.method2(); // Invokes SomeClass.method2()\n}\n\n\n\n\nIf An inherited method is not appropriate (does not do what we want), we replace (override) that method with a new method with the same signature.\n\nMethods defined inside the NewClass will take priority over an inherited method with the same method signature (this mechanism is called overriding).\n\nIf original class does not have a suitable method for some task in the new class, we can add new methods to our NewClass to perform that task.\n\nThese new methods will only be defined in the NewClass (and will not be defined or inherit in the original class).\nSee Demo02.java and NewClass02.java\n\nAccessing an overridden method and an overriding method:\n\nNotice there are two different methods named method1() with the same signature if we override the method.\n\nThe original method1() is in SomeClasses (the overridden method)\nThe new method1() is in NewClass (the overriding method)\nWhen writing methods in NewClass, both methods are available for use (=accessible).\n\nTo access the overridden method, we use the super keyword, which always refers to the members in the super class.\n\nFor example, super.method1() refers to the method1() defined in SomeClass\n\n\nImportant note: Accessibility modifiers are enforced on inherited members.\n\nNote: the subclass and its superclass are separate class.\nTherefore, methods defined (written) inside a subclass cannot access private members in the super class.\nOnly the unmodified inherited methods in the subclass can access the inherited private members."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriented-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriented Thinking",
    "text": "Object-Oriented Thinking\n\nObject-Oriented Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriented Design methodology when developing the classes.\nThe Object-Oriented Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriented methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriented Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#overloading-vs.-overriding",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Overloading vs. Overriding",
    "text": "Overloading vs. Overriding\n\n\n\n\n\n\nNote 1: Overloading\n\n\n\nDefining different methods with the same (method) name but with different (method) signatures\n\n\n\n\n\n\n\n\nTip 2: Example of Overloading\n\n\n\n\n\npublic class SomeClass {\n  public int x;\n  public SomeClass (int a) {\n    x = a;\n  }\n  public void method1() {\n    System.out.println(\"SomeClass.method1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.method2()\");\n  }\n}\npublic class NewClass extends SomeClass {\n  NewClass (int a) {\n    super(a);\n  }\n  // Inherits: method1() and method2()\n  public void method1(int a) { // Overloads method1()\n    System.out.println(\"NewClass.m1(int)\");\n  }\n  public void method3() {\n    method1(); // Invokes SomeClass method1\n    method1(22); // Invokes NewClass method1(int)\n  }\n}\n\n\n\n\n\n\n\n\n\nNote 2: Overriding\n\n\n\nReplacing an inherited method by defining a method with the same (method) signature\n\n\n\n\n\n\n\n\nTip 3: Example of Overriding\n\n\n\n\n\npublic class NewClass extends SomeClass {\n  NewClass(int a) {\n    super(a);\n  }\n  // Inherites: method1() and method2()\n  public void method1() { // overrides method1()\n    System.out.println(\"NewClass.m1()\");\n  }\n  public void method3() {\n    method1(); // Invokes NewClass method1\n    super.method1(); // Invokes SomeClass method1\n  }\n}\n\n\n\n\nIn Java, we can add the special override annotation @Override before an overriding method for clarity: java     public class NewClass extends SomeClass {       // Inherits: method1(double)       @Override       public void method1(double x) {         System.out.println(\"x = \" + x);       }     }\n\nJava compiler will report an error if the defined method does not override any inherited methods.\n\nAdditional conditions on overriding methods\n\nThe overriding method must have the same return type as the overridden method. We will get a type incompatible error when we use different return types.\nThe overriding method should have the same accessibility modifier as the overridden method. Complicated errors can result when you do not use the same accessibility."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#things-that-the-java-compiler-does-automatically",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Things that the Java Compiler does automatically",
    "text": "Things that the Java Compiler does automatically\n\nEvery object must be initialized; therefore\n\nEvery class must have a constructor method\nif a class does not have one, the Java compiler will insert the default constructor\n\nEvery subclass object contains a superclass object (that must be initialized); therefore\n\nA subclass constructor must invoke super() as its first statement.\nIf not so, the Java compiler will insert super(); at the beginning.\n\nEvery class in Java is descended from one special class called the Object class. i.e., the Object class is the parent class of every class in any Java program\n\nIf no inheritance is specified when a class is defined, the Java compiler will automatically insert extends Object in the class definition.\nEvery class in Java inherits from the Object class.\nEvery object in Java will have all the methods defined in the Object class.\n\nOne important method in the Object class is toString()\n\ntoString() returns a string representation of this object.\nFurthermore, the System.out.println() method invokes the toString() method so it can print out any object.\nTherefore, we can control the print out of an object by overriding the toString() in a class."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#introduction-to-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Introduction to Polymorphism",
    "text": "Introduction to Polymorphism\n\nSo far, we have always used a reference variable to point to an object of the same class. Now, we will use a reference variable to point to an object of a different class.\n\n\n\n\n\n\n\nTip 4: Example of Polymorphism\n\n\n\n\n\npublic class SomeClass {\n  public int x = 44;\n  public void method1() {\n    System.out.println(\"SomeClass.m1()\");\n  }\n  public void method2() {\n    System.out.println(\"SomeClass.m2()\");\n  }\n}\n\nThen, the following are legal\n\nDefine a reference variable: SomeClass a;\nCreate a SomeClass object: a = new SomeClass();\na.x\na.method1()\na.method2()\n\n\n\n\n\n\nThe Correctness of Program Execution (Suppose a SomeClass variable a is referencing to some arbitrary object with a.x, a.method1(), and a.method2() defined)\n\nRule: a reference variable must refer to an object that contains all members in a legal request\n\nReason: the referred object must perform all acrtions in the class or else we can have a request error.\nThe simplest way to satisfy this rule is to refer to an object of the same class.\nHowever, there is another safe (=correct) way due to the inheritance relationship.\n\nA subclass object can perform all actions that a superclass object performs.\n\nTherefore, it is safe to use a superclass reference variable to request members in a subclass object.\nJava allows we to access members in a subclass object using a superclass reference variable.\n\n\nDynamic Dispatch (aka: late binding)\n\nThe request a.method() will execute the method in the object that a is currently pointing to.\nThis feature is called dynamic dispatch or late binding, which means decision on which method to run is at the last moment.\n\n\n\n\n\n\n\n\nTip 5\n\n\n\n\n\npublic class SomeClass {\n    public int x = 44;\n    public void method1() {\n      System.out.println(\"SomeClass.m1()\");\n    }\n    public void method2() {\n      System.out.println(\"SomeClass.m2()\");\n    }\n}\npublic class NewClass extends SomeClass {\n    @Override\n    public void method1() {\n      System.out.println(\"NewClass.m1()\");\n    }\n    public void method3() {\n      System.out.println(\"newClass.m3()\");\n    }\n}\npublic class myProg {\n    public class void main(String[] args) {\n      SomeClass a = new NewClass(); // allowed!\n      System.out.println(a.x);\n      a.method1(); // Invokes method1() in NewClass\n      a.method2();\n      a.method3(); // illegal\n    }\n  }\n\nBecause a is pointing to a NewClass object, a.method1() will execute NewClass’s method1() even though a is a SomeClass object.\n\n\n\n\n\nPolymorphism\n\nConsider the following program:\n\n  SomeClass a; // superclass reference variable\n  // Use superclass variable to access overridden method in superclass\n  a = new SomeClass(); // refer superclass object\n  a.method1(); // calls SomeClass.method1()\n  // Use superclass variable to access overridden method in subclass\n  a = new NewClass(); // refers subclass object\n  a.method1(); // class NewClass.method1()\n\nThe same expression a.method1() invokes different methods\n:::{#nte-polymorphism .callout-note} ## Polymorphism The phenomenon that the same expression (program code) can result in different actions. Polymorphism is caused by using a superclass reference variable to access overridden members in the superclass and their subclasses and late binding. :::\n\nA reverse case: a superclass object may perform fewer actions than a subclass object.\n\nTherefore, it is illegal to use a subclass reference variable to access members in a superclass object."
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#application-of-polymorphism-selection-sort-algorithm",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Application of Polymorphism: Selection Sort Algorithm",
    "text": "Application of Polymorphism: Selection Sort Algorithm\n\n\n\n\n\n\nNote 3: Sorting an array\n\n\n\nRe-arrange the values in an array so that the values are ordered.\n\n\n\nIn our discussion, we will sort the array in ascending order.\nThere are many array sorting algorithms, but we will first examine the selection sort algorithm.\n\nSelection sort finds the smallest number in the list and swaps it with the first element.\nIt then finds the smallest number remaining and swaps it with the second element.\nAnd so on, until only a single number remains (i.e., the last number in the list)\n\npublic static void selectionSort(int[] list) {\nfor (int i = 0; i &lt; list.length-1; i++) {\n  // Find the minimum in the list[i...list.length-1]\n  int min      = list[i]; // Assume the first element is min\n  int minIndex = i;       // Index where min is found\n  for (int k = minIndex+1; k &lt; list.lenght; k++) {\n    if (list[k] &lt; min) {  // Find a smaller element\n      min      = list[k]; // Update min value\n      minIndex = k;       // Update its index\n    }\n  }\n  // Swap list[i] with list[minIndex] if necessary\n  if (minIndex != i) {\n    // Swap list[minIndex] and list[i]\n    // Standard exchange alg\n    int help       = list[minIndex];\n    list[minIndex] = list[i];\n    list[i]        = help;\n  }\n}\n}\nDue to polymorphism, we can change the selection sort algorithm for integers to Circle, Rectangle, and even GeometricObject objects.\n\nIn order to do so, the superclass object must provide all the necessary actions used in the selectionSort() algorithm.\nTo be more specific, that is why we have defined getArea() { return 0 } in the GeometricObject previously.\n\npublic static void selectionSort(GeometricObject[] list) {\n  for (int i = 0; i &lt; list.length-1; i++) {\n    GeometricObject min = list[i]; \n    int minIndex        = i; \n    for (int k = minIndex+1; k &lt; list.lenght; k++) {\n      if (list[k].getArea() &lt; min.getArea()) {  \n        min      = list[k];\n        minIndex = k;\n      }\n    }\n    if (minIndex != i) {\n      GeometricObject help = list[minIndex];\n      list[minIndex]       = list[i];\n      list[i]              = help;\n    }\n  }\n}\npublic static void mian(String[] args) {\n  GeometricObject[] myList = new GeometricObject[4];\n  myList[0] = new Circle(\"red\", 2);\n  myList[1] = new Rectangle(\"blue\", 1, 1);\n  myList[2] = new Circle(\"white\", 5);\n  myList[3] = new Rectangle(\"black\", 4, 4);\n  selectionSort(myList)l\n  for (int i = 0; i &lt; myList.length; i++) {\n    System.out.println(myList[i]);\n  }\n}\nSummary\n\nA common technique to generalize code is to write methods with a superclass type as parameter type.\nSuch a method can receive objects of any subclass type as argument.\nRequirement:\n\nThe superclass type must provide all the actions necessary to code the method\n\nJava provides an interface mechanism that is similar to the inheritance mechanism for defining superclass type and subclass type relationship.\nUsing this interface mechanism, we can make a superclass type that can unite the String, the Circle, and the Rectangle classes"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#exception-handling-and-polymorphism",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Exception Handling and Polymorphism",
    "text": "Exception Handling and Polymorphism\n\nThe exception types in Java are also organized as an inheritance hierarchy. The root type is Exception\nWe can catch more general exceptions using types higher up in the exception hierarchy. java     public static void main(String[] args) {       int[] a = new int[10];       try {         a[99] = 1;       } catch (Exception e) { // higher up.         System.out.println(e);       }     }\n\nUse Exception, we will catch all types of exceptions\n\nWe can use multiple catch clauses, but the more specific exceptions should come first. java     public static void main(String[] args) {       int[] a = new int[10];       try {         if (Math.random() &lt; 0.5) {           a = null;         }         a[99] = 1;       } catch (ArrayIndexOutOfBoundsException e) {         System.out.println(e);       } catch (Exception e() {         System.out.println(e);       }     }"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#upcasting-downcasting-and-instanceof-operator",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Upcasting, Downcasting, and instanceof operator",
    "text": "Upcasting, Downcasting, and instanceof operator\n\n\n\n\n\n\nNote 4: Upcasting\n\n\n\nCasting (converting) a subclass reference into a superclass reference. - Upcasting is a safe operation because we can make fewer requests using a superclass variable than using a subclass variable.\n\n\n\n\n\n\n\n\nNote 5: Downcasting\n\n\n\nCasting (converting) a superclass reference into a subclass reference. - Downcasting is an unsafe operation because we may make an illegal request using a subclass variable.\n\n\n\nUnder some situations, downcasting can be safe and necessary:\n\nWe first perform an upcasting operation\nLater, we want to perform an action defined in the subclass\n\n\n\n\n\n\n\n\nTip 6: To Perform a Safe Downcasting Operation\n\n\n\n\n\npublic static void main(String[] args) {\n  GeometricObject a = new Circle(\"red\", 1); // Upcasting\n  System.out.println(a.getArea()); // safe\n  // System.out.println(a.getRadius()); // illegal -- getRadius() is not defined in GeometricObject\n  Circle b;\n  b = (Circle) a; // Explicit upcasting\n  System.out.println(b.getRadius()); // allowed\n}\n\n\n\n\nWe can also write similar codes for downcasting a GeometricObject object to a Rectangle object. However, how can we write a program to cast the superclass variable references to a subclass variable of non-specific subclass?\nThe instanceof boolean condition:\n\nobjectRefVar instanceof className;\n// returns true if the object referred to by objectRefVar\n// is an object of className type or a subclass type of\n// className. Otherwise, returns false\n\nUsing the instanceof, we can solve the problem:\n\npublic static void main(String\\[\\] args) { \n  GeometricObject a; if (Math.random() \\&lt; 0.5) { \n    a = new Circle(\"red\", 1); \n  } \n  a = new Rectangle(\"blue\", 2, 1);\n       \n  if (a instanceof Circle) {\n    Circle b = (Circle) a; // downcast to a circle\n    System.out.println(b.getRadius();)\n  } else if (a instanceof Rectangle) {\n    Circle b = (Rectangle) a; // downcast to a rectangle\n    Syste.out.println(b.getWidth());\n    Syste.out.println(b.getHeight());\n  } else {\n    System.out.println(\"Invalid subclass type\");\n  }\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#hiding-variables-and-multi-inheritance",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Hiding Variables and Multi-Inheritance",
    "text": "Hiding Variables and Multi-Inheritance\n\nIf a subclass defines a variable x with the same name as its superclass:\n\nthe name x will refer to the variable in the subclass:\n\nThe variable x in the subclass will overshadow (hide) the variable in the superclass.\n\nThe variable x in the superclass can be accessed in the subclass using super.x (or through a non-overridden method)\nHowever, it’s a terrible idea to override variables.\n\nMultiple-Inheritance\n\nJava allows a class to inherit from only one superclass, while other languages (such as C++) can inherit from multiple class and made things very complicated.\nJava does implement some features of multiple inheritance through interface:\n\nA class can have multiple parent interfaces\nBut these parent interfaces must be completely empty (=no variables and contains only method declarations)"
  },
  {
    "objectID": "notes/cs171/04-Packages/Packages.html",
    "href": "notes/cs171/04-Packages/Packages.html",
    "title": "Lecture 3 Packages",
    "section": "",
    "text": "Why do programming languages provide different accessibilities (i.e. private and public qualifiers):\n\nA large computer program has many methods stored in different classes\nMethods defined inside a class are used to solve the same problem\nMethods defined inside different classes usually do not solve the same problem\nA common cause for errors is accidental update of variable(s) by a method in a different class\nLimiting access to variables (with the private qualifiers) will reduce accidental update of variable(s) by a method from another class\n\nJava packages:\n\nSome problems are too complex that they cannot be solved by methods inside one single class\n\nWe may need to write multiple classes to solve such complex problems\n\nPrograms will run more efficiently if they can access variables directly\nI.e., Getter (getRadius()) and setter (setRadius()) will slow down a program\n\n\n\n\n\n\n\n\n\n\nNote 1: Package\n\n\n\nPackage in Java is used to organize multiple classes that cooperate and perform similar tasks\n\n\n\nIt facilitates (=make it easier) the cooperation: - Java can allow methods defined in classes inside the same package to access each other members (variables and methods) directly\nExample on using a package\n\npackage p1;\npublic class C1{\n    public int x1;\n           int x2; // Default (= package) access modifier\n           // \n    private int x3;\n\n    public void m1() { }\n           void m2() { } // Default (= package) access modifier\n    private void m3() { }\n}\n\nThe numbers x2 and m2() has no access modifier. In that case, they will be assigned with the default access modifier.\n\nA member with the default access can be accessed from methods in classes belong to the same package. - Class in a same package cooperate to perform a task\nA member with the default access is not accessible from methods in classes belong to a different package. - Class in different packages do not cooperate to perform a task\nSee Demo.java\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-abstract-classes-and-abstract-methods",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "",
    "text": "In the inheritance hierarchy (tree), classes become more specific and concrete with each new subclass. If we move from a subclass back up to a superclass, the classes become more general and less specific - i.e., more abstract.\nImportant class design principle:\n\nthe superclass contains common features of all subclasses\nSometimes, a common action (method) is not well-defined:\n\nWe know what the action is, but we cannot be specific about it.\n\nSometimes, a superclass is so abstract that it cannot be used to create any specific instances.\n\n\n\n\n\n\n\n\nNote 1: Abstract Class\n\n\n\nAn abstract class is a class that cannot be instantiated. That is, we cannot create instances of an abstract class.\n\n\npublic abstract class className {\n    // same as a normal class\n}\n\nAny class can be defined as abstract.\nWe can define (reference) variables of an abstract class type\nWe can also extend (derive a subclass from) an abstract class\nTherefore, an abstract class can serve as the superclass for polymorphic methods.\n\n\n\n\n\n\n\nNote 2: Abstract Methods\n\n\n\nAn abstract method consists of only the method declaration without the method body. The method declaration consists of only the method header (data types) information.\n\n\n\nDeclarations are used to convey data type information to the Java compiler.\n\npublic abstract returnType methodname(params);\n\nSee AbstractSort.java\nRelationship between abstract classes and abstract methods:\n\nabstract method:\n\nAn abstract method is an incomplete method. It cannot be executed (because it has no method body)\n\nRule: A class that contains an abstract method must be defined as an abstract class.\n\nThis is to prevent users from instantiating objects that contains incomplete methods\n\nSubclasses of abstract classes:\n\nA subclass that do not define all the abstract methods must be defined as an abstract class\nOtherwise, the class can be defined as a normal class.\n\n\nAn abstract class cannot be defined as a final class\n\nAn abstract class cannot be instantiated, so it needs to be extended (i.e., not final) into a concrete class to become instantiable.\nSimilarly, we can also not have abstract final methods. This is because an abstract method is incomplete (has no method body) and must be overridden (not final) so the method can become concrete.\nA class that contains an abstract method must be defined as an abstract class\n\nSome interesting features:\n\nA class can be abstract even if its superclass is non-abstract.\nAn abstract subclass can override a non-abstract method from its superclass with an abstract method.\n\nWhen the implementation of the method in the superclass becomes invalid in the subclass.\n\n\nPractical use of abstract classes:\n\nWhen we are unsure of how a method should be defined/implemented for that class.\nWhen we do not want objects of that type being instantiated (and used) - even when the class has no abstract methods."
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#introduction-to-interfaces",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Introduction to Interfaces",
    "text": "Introduction to Interfaces\n\n\n\n\n\n\nNote 3: Interface\n\n\n\nAn interface can be used to define common behavior for any classes (including unrelated classes). It is a similar mechanism as inheritance for unrelated class that share some behaviors (methods)\n\n\n\nAn interface is an abstract class-like construction that contains only\n\nmethod declarations and\nconstants (static and final)\n\nWe can define interface variables but cannot instantiate objects with an interface (just like an abstract class)\n\npublic interface myInterface {\n    public abstract void myMethod(); // abstract is optional\n    // other methods\n}\n\nAn interface cannot have a constructor method. We cannot create objects of an interface type (similar to an abstract class)\nWe can define variables of an interface type (to achieve polymorphism): myInterface a;\nWe implement an interface with an implementation class:\n\npublic class myClass implements myInterface {\n    // must override all methods decleared in the interface\n    public void myMethod(){\n        System.out.println(\"Running myMethod() in myClass\");\n    }\n}\n\nThe implementation class must override all methods declared in an interface.\n\n\n\n\n\n\n\nTip 1: Example to Use an Interface\n\n\n\n\n\n\nWe cannot instantiate an object with an interface type\nHence, we always upcast an object of its implementation class and assign it to an interface variable.\n\nWe upcast an object if the class implements the interface\nan interface is a superclass (of unrelated objects)\nSee InterfaceSort.java\n\n\n\n\n\n\nThe Comparable interface of the Java library\n\nIt is the superclass of all objects that can be compared.\n\npublic interface Comparable&lt;E&gt; {\n  public int compareTo(E o);\n}\n\nThe syntax &lt;T&gt; is called a generic type in Java.\n\n\n\n\n\n\n\n\nTip 2: Example to Use the Comparable Interface\n\n\n\n\n\npublic class Circle extends GeometricObject implements Comparable&lt;Circle&gt; {\n    private double radius;\n    // other method omitted\n    /**\n     * Arrays.sort() will only work with Comparable objects\n     * The Circle class must implement the Comparable interface\n     * in order to use Array.sort()\n     */\n    public int compareTo(Circle other) {\n        double diff = this.getArea() - other.getArea();\n        return (int) Math.signum(diff);\n    }\n}\n\n\n\n\nA class can inherit from only one class, but a class can implement multiple interfaces.\n\nEach interface defines a set of capabilities or “roles”.\nImplementing an interface allows a class to fulfill the role defined by an interface.\nTherefore: a class in java can fulfill multiple roles.\n\ninstanceof\n\nThe instanceof operator tells us whether a variable is a member of a class or an interface (i.e., an interface is similar to a class in Java)\n\nMethods with a default implementation in an interface\npublic interface InterfaceName {\n  public default returnType methodName(params) {\n      // method body\n  }\n}\n\nUsage: when the implementing class does not override a method with a default implementation, the Java compiler will use the default implementation as the overriding method.\n\nUnlike classes that can extend only 1 class, an interface can extend one or more interfaces\n\npublic interface Insurable extends Sellable, Transportable {\n    public int insuredValue();\n}\n\nThe interface Insurable will combine:\n\nAll methods in Sellable\nAll methods in Transportable\nThe insuredValue() method\n\n\n\n\n\n\n\n\n\nAbstract Class\nInterface\n\n\n\n\nCan have constructors, instance variables, constants, abstract methods, and non-abstract methods\nCan only have abstract methods and constants\n\n\nIs extended by a subclass that may implement the abstract methods, but does not have to. (If the subclass does not implement all abstract methods, it must be defined as an abstract class too)\nIs implemented by a subclass that must implement all the abstract methods"
  },
  {
    "objectID": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "href": "notes/cs171/06-Abstract-Classes-and-Interfaces/Abstract_Classes_and_Interfaces.html#review-of-oop-concepts",
    "title": "Lecture 5 Abstract Classes and Interfaces",
    "section": "Review of OOP Concepts",
    "text": "Review of OOP Concepts\n\nA class, is like a definition of a data type in Java.\nAn instance of an object of a given class is created (instantiated) using a constructor and the new operator.\nObject instances in Java are accessed through reference variables.\nA subclass can extend a superclass and use its methods and instance variables through inheritance and polymorphism.\nAbstract classes can contain 0 or more abstract methods. Classes containing at least one abstract method must be abstract. Abstract classes can not be used to instantiate objects. Abstract classes are extended by a subclass that defines the abstract methods.\nInterfaces contain only abstract methods and constants and provides a template for another class to implement all of the methods declared in the interface."
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html",
    "href": "notes/cs171/07-Generics/Generics.html",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-classes",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "",
    "text": "Note 1: Generic class\n\n\n\nA generic class is a parameterized class where the parameters are always object types.\n// T1, T2, ... are object type parameters\npublic class ClassName&lt;T1, T2, ...&gt; {\n    // we can use T1, T2, ... as type specifier here\n}\n\n\npublic class GenericStroe&lt;T&gt; {// T is the type parameter\n    private T data; // variable of the T type\n    public GenericStore(T data) {\n        this.data = data;\n    }\n    public T getData() { // return T type variable\n        return this.data;\n    }\n}\n\nThe Java compiler will remember the places where the generic type parameter T are used.\nThe generic type parameter T tells the Java compiler to place the correct cast operation at some result before using it.\nWhen the parameter type is &lt;T&gt;, the Java compiler will replace every occurrence of &lt;T&gt; by Object.\nWhen we define a variable of a generic class, we specify the object type parameter along with the class name:\n\nGenericsStore&lt;String&gt; a = new GenericsStore&lt;String&gt;();\nGenericsStore&lt;Integer&gt; b = new GenericsStore&lt;Integer&gt;();\n\nThe result will be:\n\nThe Java compiler will remember the parameter type of each variable, and\nInsert the proper casting operation before using the value returned by their methods.\n\nThe parameters of a generic class must be object (reference) types\n\nWe cannot define generic class variables using primitive types:\n\n  GenericsStore&lt;int&gt; a = new GenericsStore&lt;int&gt;(); // Illegal!\n\nUse a wrapper class if we need to use a primitive type.\n\nWe can use a short hand notation to define a generic class variable: java       GenericsStore&lt;Integer&gt; a = new GenericsStore&lt;&gt;();\n\nThe Java compiler can infer the second parameter\n\nCommonly parameter names used are: T (Type), E (Element), K (Key), and V (Value)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "href": "notes/cs171/07-Generics/Generics.html#intro-to-generic-methods",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Intro to Generic Methods",
    "text": "Intro to Generic Methods\n\nSyntax to define a generic (parameterized) method\n    public static &lt;T1, T2, ...&gt; returnType methodName(params) {\n      // method body\n    }\n    ```\n-   We can use the type parameters `T1, T1, ...` to declare parameter variables, local variables, and the return type of the method.\n``` java\npublic static &lt;T&gt; void print(T[] list) {\n  for (int i = 0; i &lt; list.length; i++) {\n      System.out.println(list[i]);\n  }   \n}\n\nThe generic method will be made specific (with a data type) in the invocation.\n\nWhen we write a generic method, the Java compiler will replace every occurrence of &lt;T&gt; by Object and will remember that list[] is a parameterized class variable.\n\nWhen the print() method is used, the Java compiler will insert the appropriate casting operator\n\nSyntax to invoke a generic (parameterized) method:\n\n    Classname.&lt;T1, T2, ...&gt;methodName(arguments)"
  },
  {
    "objectID": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "href": "notes/cs171/07-Generics/Generics.html#bounded-and-unbounded-parameter-type",
    "title": "Lecture 6 Generic Classes and Generic Methods",
    "section": "Bounded and Unbounded Parameter Type",
    "text": "Bounded and Unbounded Parameter Type\n\nAn unbounded generic type parameter T is specified as &lt;T&gt; or &lt;T extends Objects&gt;\n\nWe can use any object (reference) type to make the parameter type T into a specific type.\nWhen an unbounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by Object.\n\nWhen Object is inappropriate as the parent class: Object does not have certain required methods used in the code.\nA bounded generic type parameter T is specified as &lt;T extends SuperClass&gt;\n\nIn this way, we can only use a subtype of a superclass to make T into a specific type.\nWhen a bounded generic type parameter T is used in a generic class definition, the type parameter &lt;T&gt; is replaced by the bounding type, instead of Object.\n\nThe use of bounded type parameter is necessary when we have used a method in the code that is not defined in the Object class."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html",
    "href": "notes/cs171/02-Review/Review.html",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#introduction",
    "href": "notes/cs171/02-Review/Review.html#introduction",
    "title": "Lecture 1 Introduction & Review",
    "section": "",
    "text": "Note 1: Algorithm\n\n\n\nA method for solving a problem expressed as a sequence of steps that is suitable for execution by a computer(machine).\n\n\nDifferent ways to express algorithms:\n\nNatural languages (bad - ambiguous)\nFlow charts (good for conceptualization of the algorithm)\nPseudo code (good for algorithm development)\nProgramming languages (good for communicating the algorithm to a machine because it’s unambiguous)\n\n\n\n\n\n\n\nNote 2: Data structure\n\n\n\nA way to organize (insert, delete, and retrieve) the data used by an algorithm\n\n\n\n\n\n\n\n\nTip 1: Example of a data structure\n\n\n\n\n\nArrays\n\n\n\nEvery data structure has its strengths and its weaknesses:\n\nArray: The data is stored in consecutive array elements & The array elements are accessed efficiently using an index.\n\nStrength: efficient (low) storage cost\nWeakness: not dynamic (cannot increase in size easily)\n\n\nMetrics used to measure the goodness of algorithms:\n\nRunning time: how long does it take for the program to finish\nStorage requirement: how much memory does the program use to store its information."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "href": "notes/cs171/02-Review/Review.html#review---computer-architecture",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Computer Architecture",
    "text": "Review - Computer Architecture\n\nThe smallest unit of Computer Memory: bit\n\nComputers use memory devices built with electronics.\nThe smallest memory device used by the computer works like a switch. It can be in one of the 2 states:\n\nOff state (state 0)\nOn state (state 1)\n0 and 1 are called binary digits\n\nThe smallest memory device is called a bit (=binary digit)\nA row on \\(n\\) bits can be in one of \\(2^n\\) states: each switch can be in 2 states, and so the total number of combinations is \\(2\\times2\\times2\\times\\cdots\\times2=2^n\\)\nByte memory = 8 bits = a memory device that can retain (=remember) 8 binary digits. Since \\(2^8=256\\), each byte can store one of the 256 possible patterns of binary numbers.\nThough humans are very flexible in storing data (can use many different methods), computers can only store data/information as binary numbers.\n\n\n\nMemory address and Memory content\n\nEach memory cell is identified by a unique address (which is a number).\nEach memory cell stores a number (that is the data/information stored by the computer)."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "href": "notes/cs171/02-Review/Review.html#review---variables-in-java",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Variables in Java",
    "text": "Review - Variables in Java\n\nWhat happens inside the computer when we define a variable int a:\n\nThe computer will find some used memory cells and mark them as used (aka: allocate memory)\nThe computer equates(=records) the name a to the memory location of the reserved cells.\n\nEach variable has a data type\n\nThe data type specifies the kind of information.\nEach kind of information has its own way of representation. The way of representation is called a code.\n\nEncoding method of a data type:\n\nInformation of a data type are represented by binary numbers.\nThe encoding method defines the way to interpret a binary number.\n\nData type provide the context to interpret a number and obtain the meaning of the number.\n\nSee datatype.java for an example.\n\nJava’s primitive data types:\n\n\n\n\nData type\nEncoding method\n\n\n\n\nbyte\n2’s complement encoding using 8 bits\n\n\nshort\n2’s complement encoding using 16 bits\n\n\nint\n2’s complement encoding using 32 bits\n\n\nlong\n2’s complement encoding using 64 bits\n\n\nfloat\nIEEE 754 encoding using 32 bits\n\n\ndouble\nIEEE 754 encoding using 64 bits\n\n\nchar\nUnicode encoding using 16 bits\n\n\nboolean\nEnumeration encoding using 0=false and 1=true\n\n\n\n\nBesides the primitive data types, all other data types in Java are reference data types:\n\nReference: A reference in computer science is a memory address\nReference data type: A variable of a reference data type stores a memory address\n\nPrimitive and reference data types are stored differently:\n\nThe variable of primitive data types contains a value of that data type.\nThe variable of reference data types contains a reference to the location where the object is stored."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---programming-language",
    "href": "notes/cs171/02-Review/Review.html#review---programming-language",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Programming Language",
    "text": "Review - Programming Language\n\n\n\n\n\n\nNote 3: Programming Language\n\n\n\nAn artificial language designed to convey commands unambigously to a machine.\n\nA programming language has a set of syntax rules to construct commands.\n3 types of commands/statements in a procedural programming language:\n\nAssignment statement - Selection statement: if, if-else\nLoop statement: while, for, do-while\n\nThese 3 types of statements are necessary and sufficient to make a programming language Turing-complete (meaning the machine can solve any computational problem given enough time and memory, no matter how complex).\n\n\n\n\n\n\n\n\n\nNote 4: Operator\n\n\n\nA symbol that represents an operation.\n\n\n\n\n\nAssignment\nArithmetic\nRelational\nLogical\nSpecial\n\n\n\n\n=\n\n==\n&&\n++\n\n\n+=\n+\n!=\n||\n--\n\n\n-=\n-\n&lt;\n!\n\n\n\n*=\n*\n&lt;=\n\n\n\n\n/=\n/\n&gt;\n\n\n\n\n%=\n%\n&gt;=\n\n\n\n\n\n\n\n\n\n\n\nNote 5: Operand\n\n\n\nThe value used in an operation.\n\nAn operator performs an operation on its operands and produce some result value.\n\n\n\n\n\n\n\n\n\nNote 6: Expression\n\n\n\nA combination of one or more operators and operands that performs a computation.\n\nAn expression can be built up from other expressions.\n\n\n\ncore = score - 10 * lateDays;\n\nConsists of the arithmetic expression 10 * lateDays\nwhich itself is an operand of the arithmetic expression score - •\nwhich is an operand of the assignment expression score = •\n\n\n\n\n\n\n\nNote 7: Pre-operators and Post-operators\n\n\n\n\nPre-operators preforms the operation first and will return the new value of the variable.\nPost-operators performs the operation later and returns the old value of the variable.\n\n\n\nx = 4;\ny = ++x;   &lt;===&gt;   x = x + 1; y = x; (PRE increment)\n\nResult: x = 5  y = 5\nx = 4;\ny = x++;   &lt;===&gt;   y = x; x = x + 1; (POST increment)\n\nResult: x = 5  y = 4\n\n\n\n\n\n\nNote 8: Statement\n\n\n\nA command issued to the computer to do something.\n\nStatement is the unit of execution in a programming language.\nIn Java, a statement must be contained inside some method.\n\n\n\n\nAssignment statement:\n\nvariable = expression;\n\nx = 4; // Store the value 4 in variable x\nx = x + 1; // Read the value in variable x, add 1 to it, then store result in variable x\n\nVariables on the RHS of the = operator are read/accessed.\nThe variable on the LHS of the = operator is written/updated\nif statement\n\nif (condition)\n  one-statement;\n\nif (conditon) {\n  statement1;\n  statement2;\n  ...\n}\n\nif-else statement\n\nif (condition)\n  one-statement;\nelse\n  one-statement;\n\nif (condition) {\n  statement1;\n  statement2;\n  ...\n} else {\n  statement3;\n  statement4;\n  ...\n}\n\nSwitch statement\n\nSwitch (integer-expression) {\n  case intVal1: statement1-1;\n                statement1-2;\n                ...\n                break;\n  case intVal2: statement2-1;\n                statement2-2;\n                ...\n                break;\n  ...\n  default: statementD-1; //optional clause\n           statementD-2;\n           ...\n           break;\n}\n\nwhile loop\n\nwhile (condition)\n  one-statement;\n   \nwhile (condition) {\n  statement1;\n  statement2;\n  ...\n}\n\nfor loop\n\nfor (init; term-cond; incr) {\n  statement1;\n  statement2;\n  ...\n}\n\nSee LoopTracing.java"
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---array",
    "href": "notes/cs171/02-Review/Review.html#review---array",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Array",
    "text": "Review - Array\n\nSyntax to define an array (reference) variable:\n\ndataType[] arrayRefVar; // Defines an array reference variable\n\nSyntax to create an array object\n\nnew dataType[N]; // Create an array of N elements\n\nProperties of an array in Java:\n\nAll elements in the array have the same data type.\nArray elements are stored consecutively in memory\n\nint[] A; // A is a reference variable\nA = new int[10];\n\nint[] A will allocate (reserve memory) a reference variable A.\nnew int[10] will allocate for an int[10] array (=40 bytes) and return its base address.\nA = will assign the return value to the variable A.\n\nCopy an array:\n\nMake a duplicate of an array where the duplicate contains the same data as the original\nUpdating array elements in the duplicate must not affect the data in the original array.\n\n public static void main(String[] args) {\n    double[] myList = {34, 15, 66, 7};\n    double[] myListCopy = new double[ myList.length ];\n\n    for ( int i = 0; i &lt; myList.length; i++)\n       myListCopy[i] = myList[i];\n } \nSee (CopyArray.java)[CopyArray.java].\nVariables of primitive data types (such as int, double, etc.) can be copied with an assignment. However, in Java, the assignment operation will not copy objects of non-primitive data types.\n\ndouble[] myList = {34, 15, 66, 7};\ndouble[] myListCopy;\n\nmyListCopy = myList;   // Does not copy an array object \n// ** This copies the reference in myList to myListCopy\n\nThe assignment myListCopy = myList will copy the reference in myList to the myListCopy variable.\nBecause myListCopy and myList refer to the same array object, updates made with myListCopy[i] will also affect myList[i] and vice versa. &gt; Alias: When a difference variable names can be used to reference the same variable, they are called aliases in computer science.\nSee Alias.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---methods",
    "href": "notes/cs171/02-Review/Review.html#review---methods",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Methods",
    "text": "Review - Methods\n\n\n\n\n\n\nNote 9: Methods\n\n\n\nMethods are used to encapsulate(=put in a capsule) a series of operations used to solve a complex problem.\n\nMethods allow programmers to work with higher level of abstraction.\n\nLow level of abstraction = when we can see a log of detail\nHigh level of abstraction = when we can see less detail and the big picture\n\nAbstraction is a commonly used technique to solve complex problems.\nComponents in a method definition\n\naccess specifier: public/private\nclass variable modifier: static\nreturn value data type: int/double/etc.\nmethod name\nparameter variables\nlocal variable\nreturn value\n\n\n\n\n/**\n * This method returns the summation of integers from the start integer to the end integer.\n * @param start the start integer\n * @param end the final integer\n * @return the summation\n */\npublic static int sum(int start, int end) {\n  int s = 0;\n  for (int i = start; i &lt;= end; i++) {\n      s += i;\n  }\n  return s;\n}\n\nInvoking a method: The values of the actual parameters(=arguments) are passed(=copied) to the parameter variables of the method.\nThe signature of a method = method name + data type of the parameters.\n\nJava uses the method signature to select which method to invoke.\nOverloaded method = when there are multiple method in the class with the same method name but different signatures.\n\npublic class Overload {\n public static void meth(int x) {\n    System.out.println(\"Running: meth(int x)\");\n }\n\n public static void meth(double x) {\n    System.out.println(\"Running: meth(double x)\");\n }\n\n public static void meth(int x, int y) {\n    System.out.println(\"Running: meth(int x, int y)\");\n }\n}\nAlso see Overload.java.\nParameter passing = conveying some information(=parameter) to a method.\nThe most commonly used parameter passing mechanisms are:\n\nPass-by-value: The value of the argument is passed(=assigned) to the parameter variable. The method will use the copy of the argument’s value in its computations.\nPass-by-reference: the address of the argument is passed(=assigned) to the parameter variable. The method will retrieve the value using the address in computations.\n\nOne key to remember: The parameter variables are local variables to the method. Arguments and parameter variables are different variables.\nJava always passes the arguments by-value to a method. However, because primitive typed variables and reference typed variables are stored differently, the outcome of the pass-by-value mechanism is different for primitive typed variables and reference typed variables.\n\nA primitive typed argument passed to a method cannot be modified:\n\nSee PassPrimitive.java.\n\nA reference typed argument passed to a method will be modified.\n\nSee PassReference.java."
  },
  {
    "objectID": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "href": "notes/cs171/02-Review/Review.html#review---exception-handling",
    "title": "Lecture 1 Introduction & Review",
    "section": "Review - Exception Handling",
    "text": "Review - Exception Handling\n\nWhen a method execution encounters an error, the method would return an error code: See ErrorCode.java.\nIn newer programming languages, the method will “throw an exception” when ti encounters an error: See ThrowException.java.\nYou can text(=catch) for the “error code” (exception type) and execute a block when the error code is detected: See CatchException.java."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#linear-search-and-the-binary-search-algorithms-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "",
    "text": "Searching:\n\nSearching is a very common task in computer programming.\nMany algorithms and data structures are invented to support fast searching.\n\nSearching arrays:\n\nArrays are often used to store a large amount of data.\nSearching is the process of looking for a specific element in an array.\nThere are two search techniques for arrays: linear search and binary search.\n\n\n\n\n\n\n\n\nThe Search Problem for Arrays\n\n\n\nFor a given search value key, find the index of the first array element that contains the search value key.\n\nReturn -1 when the key is not found in the array.\n\n\n\n\nLinear Search algorithm:\n\nThe linear search algorithm compares the search value key sequentially with each element in the array.\nThe linear search algorithm continues to do so until the key matches an element in the array or the array is exhausted without a match being found.\nIf a match is made, the linear search returns the index of the element in the array that matches the key.\nIf no match is found, the search returns -1.\n\n\n/**\n * The linear search algorithm to find key in the array list\n */ \npublic static int linearSearch(int[] list, int key) {\n    for (int i = 0; i &lt; list.length, i++&gt;) {\n        if (list[i] == key) {\n            return i;\n        }\n    }\n    // key is not found in list[]\n    return -1;\n}\n\nComplexity Analysis:\n\nBest case scenario: the first element in the array contains the search key. Running time = 1 step (iteration)\nWorst case scenario: array does not contain the search key. We run through the whole array. Running time = \\(N\\) steps.\nAverage case scenario: on average, we will probe half of the array elements. Running time = \\(\\dfrac{N}{2}\\) steps.\n\nBinary search is a more efficient (faster) search algorithm for arrays.\n\nFor binary search to work, the elements in the array must already be ordered.\n\nFor the presentation of the binary search, we assume that the array is in ascending order.\n\nThe binary search compares the key with the element in the middle of the array.\n\n\n/**\n * The binary search algorithm for arrays\n */\npublic static int binarySearch(int[] list, int key) {\n    int low = 0;\n    int high = list.length - 1;\n\n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid;\n        } else if (list[mid] &lt; key) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    // If key is not found in the list[]\n    return -1;\n} \n\nComplexity Analysis:\n\nBest case scenario: the middle element in the array contains the search key. Running time = 1 step (iteration).\nWorse case scenario: Suppose the binary search takes \\(k\\) iterations to complete, then \\(\\dfrac{N}{2^k}=1\\) (after halving \\(N\\) elements for \\(k\\) times, we get 1). Solving the equation, we get \\(k=\\log(N)+1\\). So, running time \\(\\approx\\log(N)\\) steps.\nAverage case scenario: it is very hard to estimate, but we can use the worse case scenario as an upper bound for the running time in average."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#adding-or-deleting-elements-from-an-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "Adding or Deleting Elements from an Array.",
    "text": "Adding or Deleting Elements from an Array.\n\nAdding an element at the end of an array\n\nThe array size is fixed after its creation.\nTo add a new element to the end of an array:\n\nCreate a new array with the 1 more element\nCopy the elements in the original array to the new array.\nCopy the new value in the last element of the new array.\nChange the array reference to point to the new array.\n\npublic static int[] addElement(int[] x, int e) {\n    int[] temp = new int[x.length + 1];\n    for (int i = 0; i &lt; x.length; i++) {// copying\n        temp[i] = x[i];\n    } \n    temp[temp.length - 1] = e;\n    return temp;\n}\n\nThe algorithm executes \\(\\texttt{x.length}+1\\) data copy statements per addition.\nDeleting the last element from an array.\n\nThe array size is fixed after its creation.\nTo delete the last element from an array:\n\nCreate a new array with the 1 less element.\nCopy all except the last elements in the original array to the new array.\nChange the array reference to point to the new array.\n\npublic static int[] deleteElement(int[] x) {\n    int[] temp = new int[x.lenght - 1];\n    for (int i = 0; i &lt; temp.length; i++) {\n        temp[i] = x[i];\n    }\n    return temp;\n}\n\nWe can delete an element at a different location with a similar algorithm.\nA better way to add and delete elements in arrays: Dynamic arrays (aka. ArrayList in Java). It consists of\n\nA (fixed size) array\nA count of the actual number of elements stored in the array.\nThe array is increased only when the add() operation encounters a full array.\nThe array is reduced when the occupancy drops below a certain threshold.\nInserting a new value will increase the count. If the array is not full, we do not need to increase its size.\nThe array is increased only when the add() operation encounters a full array.\n\nThe add() method will increase the array size by approximately twice the original size. This will avoid frequent copy operations.\n\nThe array is reduced when the occupancy drops below a certain threshold.\n\nA commonly used algorithm to implement dynamic array is array doubling:\ntemp = new int[2 * x.length];\nfor (int i = 0; i &lt; x.length; i++) {\n  temp[i] = x[i];\n}\nx = temp;\nThe ArrayList class in Java implements a dynamic (resizable) array\n\nTo use it, we import java.util.ArrayList;\nSyntax to define an ArrayList (reference) variable:\n\nArrayList&lt;ObjectType&gt; varName\n\nSyntax to create an ArrayList object\n\nnew ArrayList&lt;Object Type&gt; ();\n\nThe ArrayList object will start with an array of limited size (about 10).\n\nSee DynamicArray.java\n\n\nCommonly used methods in the ArrayList class\n\nsize(): returns the actual number of elements in the ArrayList\ntoString() returns a String representation of all elements stored in the ArrayList\nadd(E e): appends the element e to the end of the ArrayList (E is the declared data type of the ArrayList elements)\nadd(int index, E elem): inserts the element e at index index and shifts and subsequent items to the right\nremove(int index): removes the element at index index and shifts all remaining items to the left.\nget(int index): returns the element stored at the index index\nset(int index, E elem): replaces the element at index index with the element elem\nIf the element at the index does not exist, get() and set() will throw IndexOutOfBoundsException.\n\nIterating through an ArrayList:\n\nUse a regular for-loop and get(index):\n\n  for (int i = 0; i &lt; numbers.size(); i++) {\n    System.out.println(numbers.get(i));\n  }\n\nUse a foreach loop:\n\n  for (int item: numbers) {\n    System.out.println(item);\n  }\n\nNote: a foreach loop cannot be used to update array elements\nUsing an iterator object:\n\nIterator&lt;Integer&gt; numItr = numbers.iterator();\nwhile (numItr.hasNext()) {\n  System.out.println(numItr.next());\n}\nJava Iterator interface and Iterable interface\n\nIterator is an interface (class containing all virtual methods) in java.util.Iterator.\nAn object that implements the Iterator interface must provide at least the following methods:\n\nhasNext(): returns true if the iteration has more elements\nnext(): return the next element in the iteration\n\nAn Iterator allows the user to iterate over the elements stored in an Iterable interface.\nAn object is Iterable if it implements the java.util.Iterable interface.\n\nIt must implement the iterator() method that returns a Iterator object.\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nArrayList\n\n\n\n\nPros\nUses less memory; can store primitive types; can be multi-dimensional\nSize is dynamic; easy to add/remove elements\n\n\nCons\nSize cannot change;hard to add/remove elements\nUses more memory; cannot store primitive types; can only be one-dimensional"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#introduction-to-object-oriented-programming-oop",
    "title": "Lecture 2 Objects and Classes",
    "section": "",
    "text": "Class in Java contains variables and methods.\nThe real purpose of a class in Java is to implement/model an object that contribute to the solution of the problem.\nProgramming methodology before ~1980: use the modular programming technique to help build large-scale complex computer programs.\nToday’s methodology: use the object concept to build large-scale complex computer programs. This style of programming using object is called the Object-Oriented Programming (OOP)\nHow OOP help us write complex programs:\n\nAbstraction: OOP provides abstract classes to help reduce(=hide) details\nInheritance: allows existing code to be re-used.\nPolymorphism: allows existing code to be modified/enhanced.\nEncapsulation: prevents code in other classes from accessing/modifying important variables to localize debugging.\n\n\n\n\n\n\n\n\nNote 1: Object\n\n\n\nAn object represents an entity in the real world that can be distinctly identified.\n\n\n\nAn object has:\n\nA unique identity\nA state\nA behavior\n\n\n\n\n\n\n\n\nNote 2: State of an object\n\n\n\nThe state of an object (also known as its properties or attributes) is represented by data fields with their current values.\n\nA Java class represents the state/properties of objects using:\n\nThe instance variables inside a class\nEach object will have its own instance variables.\n\n\n\n\n\n\n\n\n\n\nNote 3: Behavior of an Object\n\n\n\nThe behavior of an object (also known as its actions) is defined by methods. To invoke a method on an object is to tell the object to perform an action.\n\nA Java class defines the behavior of objects using:\n\nThe instance methods inside a class\nAll objects of a class share the instance methods (because they have the same behavior).\n\n\n\n\n\nA class is used as a template(=description) to construct the object’s data fields and to define its methods:\n\nWhen we create objects of a class, Java will use the class definition to allocate the instance variables for that object.\nWhen you invoke some method on an object, Java will run the code in the method definition on the instance variables of the object.\nWe can create as many instances(=objects) of a class as we need:\n\nEach object will have its own properties(=instance variables).\nBut all objects will share the same actions(=instance methods)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#defining-a-class-creating-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Defining a Class & Creating Objects",
    "text": "Defining a Class & Creating Objects\npublic class Circle {\n    public double radius = 1; // The radius of this circle\n\n    public Circle() { } // constructor 1 for a circle object\n    public Circle(double newRadius) { // constructor 2 for a circle object\n        radius = newRadius;\n    }\n\n    public double getArea() { // return the area of this circle\n        return 3.14159 * radius * radius;\n    }\n\n    public void setRadius(double newRadius) { // set new radius for this circle\n        radius = newRadius;\n    }\n}\nWe use the Circle class to create two Circle objects:\npublic static void main() {\n    Circle circle1 = new Circle(); // Invokes Circle() to make this circle\n\n    Circle circle2 = new Circle(2); // Invokes Circle(double) to make this circle\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n\n    double area2 = circle2.getArea(); // Tell circle2 to run getArea()\n    System.out.println(\"Area2: \" + area2);\n\n    circle1.setRaius(5); // Tell circle1 to run setRadius()\n\n    double area1 = circle1.getArea(); // Tell circle1 to run getArea()\n    System.out.println(\"Area1: \" + area1);\n}\n\nSee TestCircle.java and Cirlce.java\n\n\n\n\n\n\n\nNote 4: Unified Modeling Language (UML)\n\n\n\nA standardized modeling representation description of classes and objects.\n\n\n\nA Java class uses variables to define data fields (properties) of objects.\nA Java class uses methods to define the actions/behaviors of objects.\n\nMethods to define the actions of objects DO NOT have the static qualifier\n\nA class provides special method called constructors which are invoked only to create a new object.\n\nConstructors are designed to perform initializing actions, such as initializing the data fields of objects.\n\nA class that represents real world objects usually does not need a main() method. Without a main() method, such class cannot be run as a Java program.\n\nThough we may include a main() method in the class to test the methods, but it is preferred to write a separate class to do the testing.\n\nPreventing undesirable behavior in objects:\n\nThe Circle class implementation allows a user to access the object variables directly because we did not define radius to be private.\n\npublic class Circle {\n  public double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // changes the value of radius directlly\n  }\n}\n\nWe prevent direct access to variables in a class by using the private qualifier.\n\npublic class Circle {\n  private double radius = 1; // Then radius cannot be modified outside the class\n\n  public static void main() {\n      Circle circle1 = new Circle();\n      circle1.radius = 10; // complie error\n  }\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#constructors-of-a-class",
    "title": "Lecture 2 Objects and Classes",
    "section": "Constructors of a Class",
    "text": "Constructors of a Class\n\n\n\n\n\n\nNote 5: Constructor\n\n\n\nConstructors are special methods in a class that is only invoked when an object is created using the new operator:\nClassName objVar = new ClassName(...);\n\nConstructors have 3 special properties:\n\nA constructor must have the same name as the class itself.\nConstructors do not have a return type - not even void.\nIf we include a void return type, then the method is not a constructor, but a behavior that the object can take.\n\nConstructors cannot be invoked like an ordinary method.\nLike regular methods, constructors can be overloads (i.e., multiple constructors can be defined with different signatures).\nRules on constructors and the default constructor:\n\nEvery class must have at least one constructor.\nIf a class does not have any constructor, then the Java compiler will automatically insert this constructor: className() { }. This constructor is called the default constructor.\nHowever, the Java compiler will not insert the default constructor if there is a constructor defined in the class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#objects-as-reference-data-types",
    "title": "Lecture 2 Objects and Classes",
    "section": "Objects as Reference Data Types",
    "text": "Objects as Reference Data Types\nCircle  is a reference data type\ncircle1 is a reference variable\ncircle1 references (points to) a Circle object\n\nWe create variables to store the properties of a new object when we create the object\nThe behavior of an object (=program instructions) is stored when Java compiles the class definition.\nAn object’s member can refer to:\n\nA data field in the object\nA method in the object\n\nAfter an object is created, its data can be accessed, and its methods can be invoked using the dot operator.\nobjectRefVar.dataField  references a data field in the object\nobjectRefVar.method(arguments)  invokes a method on the object\nThe dot operator is also known as the object member access operator.\nWhy Java have reference typed variables and primitive typed variables?\n\nVariables of a primitive data type can only store 1 value but can be accessed quickly – such variables are mainly used in computations.\nObjects can have many data fields and can allow the programmer to represent complex things in the real world.\n\nObjects are mainly used for data representation\nAccessing to data in an object is slower (need 2 memory accesses)\n\n\nWe can access the member variable without using any reference variable:\n\nAn instance method is always invoked using an object reference variable: objectRefVar.method(arguments)\nThe variable objectRefVar is also passed to an instance method as an implicit (=hidden) parameter. The name of the implicit parameter is called this.\nSee Circle.java\n\nThis implicit parameter this is almost never necessary to write in a Java class. There is only 1 case that it is necessary:\n\nwhen a parameter variable has the same name as an instance variable in the class.\nSee Circle.java\n\nThe this keyword is can also be used to invoke another constructor of the same class."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#copying-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Copying Objects",
    "text": "Copying Objects\n\nCopy an object means:\n\nMake a duplicate of an object where the duplicated object contains the same data as the original object.\nUpdating the instance variables in the duplicate object must not affect the values in the original object.\n\nOne way is to create a new object and then copy the data fields.\npublic static void main() {\n  Circle circle1 = new Circle(4);\n\n  // Make a COPY of circle1\n  Circle circle2 = new Circle();\n  circle2.radius = circle1.radius;\n}\n\nSee CircleCopy.java. This method only works when the data fields are defined in public.\n\nAnother way is through a copy constructor:\npublic class Circle{\n  private double radius = 1;\n  public Circle() { } // constructor for a circle object\n\n  public Circle(Circle c) { // copy constructor that copies circle c\n    radius = c.radius; \n  }\n}\n\nTo invoke the copy constructor:\n\npublic static void main() {\n  Circle circle1 = new Circle(4);\n  Circile circle2 = new Circle(circle1);\n}\n\nSee CircleCopy.java."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#arrays-of-objects",
    "title": "Lecture 2 Objects and Classes",
    "section": "Arrays of Objects",
    "text": "Arrays of Objects\n\nSimilar to doubles and integers, we also have arrays of objects in Java. They are also defined in a similar way.\nIn other words, we can create a Circle object with new and assign it to an array element java     Circle[] circleArray = new Circle[10];     circleArray[0] = new Circle(4);\nHowever, an array of primitive variables is different from an array of reference variables.\n\nPrimitive:\n\nAfter creating an array of primitive variables, each array element can store a value.\nPrimitive type array variables (number[k]) contains values and is used in computations\n\nReference:\n\nAfter creating an array of reference variables, each array element can store a reference of an object.\nReference array variables (circleArray[k]) contains references and is used with the member selection operator . (the dot operator)."
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#data-field-encapsulation",
    "title": "Lecture 2 Objects and Classes",
    "section": "Data Field Encapsulation",
    "text": "Data Field Encapsulation\n\nThe most important application of visibility(=accessibility) modifiers is: data field encapsulation.\n\n\n\n\n\n\n\nNote 6: Data Field Encapsulation Data Field Encapsulation is making data fields in an object inaccessible (=private) to other classes (which will disallow other classes from using the data fields directly).\n\n\n\n\n\n\n\nEncapsulation is important because\n\nIf a data field is not private, program written by other programmers can tamper with the data fields.\nWhen other programs use a data field in an object directly, changing the implementation of the object is more difficult.\n\nChanging the implementation of the object means change the way we present the properties of an object.\n\nFor example, we can use String to represent suit as {\"Spades\", \"Hearts\", \"Diamonds\", \"Clubs\"}. Meanwhile, we can also use int to represent it as {0 = \"Spades\", 1 = \"Hearts\", 2 = \"Diamonds\", 3 = \"Clubs}.\nWhen we use String, we can use card.suit.compareTo(\"Spades\") == 0 to test if the suit of the card is spade. However, if we change the implementation of card to int, the same code card.suit.compareTo(\"Spades\") == 0 will cause an error because we do not have a .compareTo() method for an integer.\n\n\n\nSo, data field encapsulation requires that data fields are defined as private.\nWhen other classes need to read a data field, we must provide a public mutator method. - See CardPrivate.java and TestCardPrivate.java.\n\nWhen we change the implementation of an object, we can still maintain compatibility with existing Java program by providing updated accessor/mutator methods that achieve the same effect as the old implementation.\n\n\n\n\n\n\n\n\nNote 7: Immutable Objects\n\n\n\nAn immutable object is an object where its properties cannot be changed after it is created.\n\n\n\nWhy we what to have immutable objects:\n\nSome computer applications are used to record a history of events which are represented by objects\nThe “historical objects” must not be changed.\n\nTo prevent the data fields of the objects being updated:\n\nPrevent the variables being updated with direct access (e.g. circle1.radius = newRadius):\n\nDefine all distance variables as private.\n\nPrevent the variables being updated with a mutator method:\n\nImmutable objects must not have any mutator methods.\n\nPrevent the variables being updated with a reference variable:\n\nImmutable objects should not have accessor methods that return a reference to an object that has public data fields.\n\n\n\n\n\n\n\n\n\nTip 1: An Example of Immutable Object:\n\n\n\n\n\nThe String class in Java will create immutable String objects: - The String class only has methods that construct a new String from an input string, and the input string is not updated.\npublic static void main(String[] args) { \n  String s1 = \"abc\"; String s2 = s1.toUpperCase();\n\n  System.out.println(s1); // \"abc\", unchanged\n  System.out.println(s2); // \"ABC\"\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#passing-objects-as-parameters-to-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Passing Objects as Parameters to Methods",
    "text": "Passing Objects as Parameters to Methods\n\nMethods can have reference type parameter variables.\n\nSee TestCircle.java\n\nHowever, the following code will change the properties of the object directly:\npublic static void incrementRadius(Circle c) {\n  c.radius++; // Increment radius by 1\n}\n\npublic static void main(String[] args) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4\n  incrementRadius(circle1); // radius of circle1 increases by 1\n  System.out.println(circle1.getRadius()); // 5\n}\n\nIn Java, the formal parameter c is an alias of the actual parameter circle1. So, c.circle++ will also update circle1.radius.\n\nSee CopyReference.java\n\n\nReview: Passing primitive variables to methods\n\nIn Java, the value of the argument copied (=assigned) to the parameter variable. So, x in main() and c in increment() are different variables.\nWhen increment() executes c++, it updates the parameter variable c.\nThe variable x in main() is not affected.\n\nPassing reference variables to methods\n\nThe reference type Cricle variable x contains a reference to a Circle object.\nIn Java, the value of the argument copied(=assigned) to the parameter variable. x in main() and c in increment() both reference to the same Circle object.\nWhen increment() executes c.radius++, it updates the radius variable through the referencec.\nThe variable x.radius in main() is ALSO affected because it is the same object.\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  updateCircle(circle1);\n  System.out.println(circle1.getRadius()); // 4.0\n}\npublic static void updateCircle(Circle c) {\n  c = new Circle(99);\n}\n\nThe reference type Circle variable circle1 contains a reference to a Circle object.\ncircle1 in main() and c in update() both refer to the same Circle object.\nWhen update() executes c = new Circle(99), it creates another Circle object and assign its address to reference variable c.\nThe variable circle1.radius in main() is not affected.\nThrough this example, we know: we can never make x in main() refer to a different object using a method call. This is because x is passed-by-value, we cannot update x and make it refer to a different object.\nIf we really want to write a method to update the reference of x, here’s an example to do so:\n\npublic static void main(String[] arg) {\n  Circle circle1 = new Circle(4);\n  System.out.println(circle1.getRadius()); // 4.0\n  circle1 = updateCircle(circle1); // Step 2\n  System.out.println(circle1.getRadius()); // 99.0\n}\npublic static Circle updateCircle(Circle c) {\n  c = new Circle(99);\n  return c; // Step 1\n}"
  },
  {
    "objectID": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "href": "notes/cs171/03-Objects_and_Classes/Objects_and_Classes.html#static-variables-and-constants-and-static-methods",
    "title": "Lecture 2 Objects and Classes",
    "section": "Static Variables (and Constants) and Static Methods",
    "text": "Static Variables (and Constants) and Static Methods\n\nThere are 2 kinds of variables that can be defined inside a class (that is outside any method): java     public class Circle{        public double radius; // (1) an instance variable       public static int count; // (2) a \"static\" variable     }\nInstance variables and static variables of objects are different:\n\nEach object has its own copy of an instance variable.\nstatic variable belongs to the class and all objects of that class share the same copy of a static variable.\nIn other words, there is only 1 only of a static variable in a Java program.\n\npublic static void main(String[] args) {\n  CircleCount circle1 = new CircleCount(2);\n      CircleCount circle2 = new CircleCount(4);\n\n      circle1.count = 99;\n\n      System.out.println(circle1.radius); // 2.0\n      System.out.println(circle1.count); // 99\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 99 \n\n      circle1.radius++; // Updates an instance variable\n      circle1.count++; // Updates a static variable\n      System.out.println(circle1.radius); // 3.0\n      System.out.println(circle1.count); // 100\n      System.out.println(circle2.radius); // 4.0\n      System.out.println(circle2.count); // 100\n}\n\ncircle1.count and circle2.count are always the same because static variables are shared\ncircle1.radius and circle2.radius are independent to each other because instance variables are not shared.\n\nApplications of static variables:\n\nThe most common application where we need to use a static variable in a class is when writing a class that can keep a count on the number of objects that has been created by a Java program.\nHow to implement?\n\nDefine a static variable named count and initialize it to zero.\nEach constructor of the class must increase the count variable by one.\n\nWhy it works?\n\nBecause when an object is created, some constructor method is invoked once, and this algorithm will keep track on the number of objects created.\n\nExample:\npublic class Circle{\n  public double radius = 1;\n  public int count = 0;\n\n  public Circle() {\n    count++;\n  }\n  public Circle(double newRadius) {\n    radius = newRadius;\n    count++;\n  }\n}\n\nThere are also two kinds of methods that can be defined inside a class: instance method and static method.\n\nInstance methods always have an implicit(=hidden) object reference parameter (this) and can access instance variables.\nstatic method do not have an implicit(=hidden) object reference parameter and cannot access instance variables.\n\nProperties of static methods:\n\nA static method belongs to a class. For this reason, static methods are also known as class methods.\nA static method can be invoked without using an object instance: Math.pow(x, n)\nstatic methods can only access static members:\n\nInvoke other static methods\nAccess static variables\nstatic methods cannot access any instance variables nor invoke instance methods.\n\n\nstatic methods are used to perform a task that is not associated with a particular object.\nInstance methods are used to perform a task using data in a specific object.\nstatic methods can be invoked in 2 different ways:\n\ninstanceVar.staticMethod(...)\nClassName.staticMethod(...)  &lt;-- Preferred\n\nSome classes may have useful constants defined in them (such as \\(\\pi\\) and \\(e\\)). Since a constant cannot change its value, we will only need one copy of it, and so a constant can always be defined as static.\nThe static block\n\nA static block is a nameless and parameterless static method in a class:\n\npublic class myClass {\n  ...  (other memebers omitted for brevity)\n\n  // A static block    \n  static\n  {\n    ... (statements)\n  }\n}\n\nUse of a static block:\n\nstatic blocks are executed before the main() method\nstatic blocks are used to initialize static variables in a class."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html",
    "href": "notes/cs171/11-Linked-List/Linked List.html",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "href": "notes/cs171/11-Linked-List/Linked List.html#introduction",
    "title": "Lecture 10 Linked List",
    "section": "",
    "text": "Note 1: Data Structure\n\n\n\nVariables that store information used by algorithms\n\n\n\nIdeal data structure:\n\nFast insertion (when adding a new item to data structure)\nFast deletion (when removing an item from the data structure)\nFast lookup\nMinimum memory usage\n\nUnfortunately: there is no ideal data structure.\nTwo basic data structures:\n\nArray\nLinked List\n\nArray:\n\nArray is a series of variable that\n\nare of the same data type and\nare stored in consecutive memory locations\n\nThe memory used to store an array must be allocated up front\nStrength: Fast access using an array index (because the memory address of x[i] can be computed easily).\n\nWeakness of an array: cannot increase the array size\n\nTo increase the array, we must use memory cells that follows the last element of the array.\nHowever, these memory cells may not be available (since they are used by another variable).\n\nWeakness of an array: it takes a long time to insert a value in the middle of an array.\n\nWe have to shift many elements over.\n\nThe linked list data structure:\n\nThe linked list and array are complementary to each other.\nCharacteristics of a linked list:\n\nEach list element is allocated individually (and then linked into the list)\n\n\nComparison of Arrays and Linked Lists:\n\nIt’s easy to insert/delete elements from a linked list\nIt’s hard to insert/delete elements from an array\nIt is slow to look up elements in a linked list by its index\nIt is fast to look up elements in an array by its index\n\nA linked list consists of a chain of list objects. A list object is often called a node.\nEvery node consists of two parts:\n\nOne of more data fields (contain the information stored in the linked list)\nA link (reference variable) (contains the reference (=address) of the next node/list element).\n\nThe link in the last node is null (=end of the list).\nA Java program will have a reference variable (commonly named as head or first) that contains the reference to the first node (=list element).\nConsequently, only the data stored in the first node is immediately accessible.\nAccessing the data stored in the other nodes will reply on the reference stored in the first node.\n\npublic class Node{\n    int item; // int data stored in the Node\n    Node next; // Link that reference to the next node\n}\n\nDefine a Node class for a linked list:\n\nThe class Node contains a reference variable next that references to a Node (same class) object.\nThe next variable is used to create a chain of Nodes\nWe can define other data field depending on what we want to store in a Node.\n\n\n\n\n\n\n\n\n\nArray\nLinked List\n\n\n\n\nArray elements are stored contiguously in memory\nList elements (=nodes) do not need to be stored contiguously in memory\n\n\nAll array elements are allocated at once\nNodes can be allocated piece meal when needed\n\n\nOnce allocated, the number of elements in the array is fixed\nWe can increase the number of elements in a list easily by increasing the length of the chain\n\n\nOnly store data fields, do not need to store non-data fields\nRequires the use of a linking field (next) to create a chain\n\n\nAccessing the k-th element in an array is fast\nNeed to traverse the chain to reach the k-th element - slow\n\n\nInserting a value in the middle of an array is difficult (need to shift elements over)\nInserting a node in the middle of a linked list is easy"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing a Simple Linked List",
    "text": "Implementing a Simple Linked List\n\nOperations on a Linked List\n\nThe linked list is a data structure used to store information.\nTo be useful as a data structure, the linked list must support the following operaqtions:\n\nCreate an empty linked list\nInsert a data item into the linked list\n\nInsert it at the beginning of the linked list\nInsert it at the end of the linked list\n\nDelete a data item from the linked list\n\nInsert the element at the beginning of the linked list\nInsert the element at the end of the linked list\n\nSearching for some data item in the linked list\n\nSearch by its index\nSearch by its key value\n\n\n\nConstructing a linked list using explicit helper reference variables\n\npublic class Demo {\n    public static Node first; // Define the first variable\n    \n    public static void main(String[] args) {\n        Node help1 = new Node();\n        Node help2 = new Node();\n        Node help3 = new Node();\n\n        help1.item = \"to\";\n        help2.item = \"be\";\n        help3.item = \"or\";\n\n        // Create the chain\n        help1.next = help2;\n        help2.next = help3;\n        help3.next = null;\n\n        first = help1;\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "href": "notes/cs171/11-Linked-List/Linked List.html#standard-list-traversal-algorithm",
    "title": "Lecture 10 Linked List",
    "section": "Standard List Traversal Algorithm",
    "text": "Standard List Traversal Algorithm\n// The standard list raversal algorithm\nNode p;\np = first; // p now points to the first node\n\nwhile (p != null) {\n    // process data p.item in node p\n    p = p.next; // advances p to next node\n}\n\n\n\n\n\n\nTip 1: Use the list traversal algorithm to print out all items in a list\n\n\n\n\n\nNode current;\ncurrent = first; // initialize current to the first node\nwhile (p != null) {\n    System.out.println(current.item);\n    current = current.next;\n}\n\n\n\n\nEnhancements of the list traversal algorithm: find a node that contains X.\n\nNode current = first;\nwhile (current != null && !current.item.equals(\"X\")) {\n    current = current.next;\n}\n\nUse the list traversal algorithm to find a list element that contains a certain key\n\n/**\n * This method returns a list element that contains a certain value\n * @param f the linked list to be searched\n * @param s the value of searching\n * @return the node containing s\n */\npublic static Node findNode(Node f, String s) {\n    Node current = f;\n    while (current != null) {\n        if (current.item.equals(s)) { // found! \n            return current;\n        }\n        current  = current.next;\n    }\n    return null; // not found\n} \n\nList traversal using a for-loop: print out item in the linked list using a for-loop:\n\nfor (Node p = first; p != null; p = p.next) {\n    System.out.println(p.item);\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-the-standard-operations-on-a-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing the Standard Operations on a Simple Linked List",
    "text": "Implementing the Standard Operations on a Simple Linked List\n\nOperations on a linked list:\n\nTest if a list is empty\nGet the item at the start\nGet the item at the end\nInsert an item at the start\nInsert an item at the end\nDelete the item at the start\nDelete item at the end\nGet the item at position k in the linked list\nRemove the first item that contains the value key from the linked list\n\npublic interface SimpleList&lt;T&gt; { // A list that store objects of type T\n  public boolean isEmpty(); // check if the list is empty\n\n  public T getFirst(); // get the first item in the list\n  public T getLast(); // get the last item in the list\n\n  public void addFirst(T item); // add an item to the beginning of the list\n  public T removeFirst(); // remove the first item from the list\n\n  public voild addLast(T item); // add an item to the end of the list\n  public T removeLast(); // remove the last item from the list\n\n  public T get(int pos); // get the item at position pos in the list\n  public void remove(T key); // remove the first item that contains the value key from the list\n}\n\nimport java.util.NoSuchElementException;\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt; {\n    // Start of the inner class Node\n    public class Node&lt;T&gt; {\n        // Node instance variables\n        private T item; // the data stored in the node\n        private Node&lt;T&gt; next; // the link to the next node\n\n        // Constructor for Node\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the inner class Node\n\n    // The list starts at first\n    private Node&lt;T&gt; first;\n\n    // Contructs an empty list\n    public GenericLinkedList() {\n        first = null;\n    }\n\n    // check if the list is empty\n    public boolean isEmpty(){ \n        return first == null;\n    }\n\n    // get the first item in the list\n    public T getFirst() {\n        // Edge case: list is empty\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item; // retrieves item in first node\n    }\n    // get the last item in the list\n    public T getLast() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // (1) Find the last node\n        Node&lt;T&gt; current = first;\n        while (current.next != null) {\n            current = current.next;\n        }\n        // (2) Return item stored in this node\n        return current.item;\n    }\n\n    // add an item to the beginning of the list\n    public void addFirst(T item) {\n        Node&lt;T&gt; = newNode = new Node&lt;&gt;(item, first);\n        first = newNode;\n    }\n    // remove the first item from the list\n    public T removeFirst() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.tiem // first = null -&gt; crash\n        first = first.next;\n        return toReturn;\n    } \n\n    // add an item to the end of the list\n    public voild addLast(T item) {\n        if (isEmpty()) { // edge case\n            first = new Node&lt;&gt;(item, null);\n            // equivalent to: addFirst(item)\n        } else {\n            // (1) Find the last element in the linked list\n            Node&lt;T&gt; current = first; // if first = null -&gt; crash\n            while (current.next != null) { // Find the last element -&gt; list traversal\n                current = current.next;\n        }\n        // (2) Mkae a new Node with data to linke to the last element \n        current.next = new Node&lt;&gt;(item, null);\n        }\n    }\n    // remove the last item from the list\n    public T removeLast() {\n        // Edge case 1: list is empty\n        if (isEmpty()) { // empty list cannot remove anything\n            throw new NoSuchElementException();\n        }\n        // Edge case 2: list only contain one element\n        if (first.next == null) {\n            Node&lt;T&gt; ret = firtst; // save for return\n            first = null; // unlink by updating first\n            return ret.item;\n        }\n        //General Case: list not empty and have at least 2 elements\n        // to remove last, we need information of the second last element\n        Node&lt;T&gt; previous = first;\n        Node&lt;T&gt; current = first;\n\n        while (current.next != null) { // find the last list element\n            previous = current; // keep track of the previous node\n            current = current.next;\n        }\n        // previous points to the predecessor node of the last node\n        // current points to the last node\n        // Unlink the last node\n        previous.next = null;\n        // return item in the last node\n        return current.item;\n    } \n\n    // get the item at position pos in the list\n    public T get(int pos) {\n        // Edge case\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        // General case\n        int i = 0;\n        Node&lt;T&gt; current = first;\n        while (current != null) {\n            if (i == pos) {\n                break;\n            }\n            i++;\n            current = current.next;\n        }\n        if (current == null) {\n            throw new IndexOutOfBoundsException();\n        \n        }\n        return current.item;\n    }\n    // remove the first item that contains the value key from the list\n    public void remove(T key) {\n       // Edge case 1: list is empty\n       if (first == null) { \n           throw new NoSuchElementException();\n       } else if (first.item.equals(key)) {\n           // Edge case 2: the first item is the key\n           first = first.next\n       } else {\n           // General case\n           // (1) Find the predecessor node of the node containing item == key\n           Node&lt;T&gt; = current = first; // Initialize\n           Node&lt;T&gt; = previous = first;\n           while (current != null && !current.item.equals(key)) {\n               previous = current;\n               current = current.next;\n           }\n           if (current == null) {\n               // key not found\n               throw new NoSuchElementException ();\n           }\n           // (2) Unlink the targeted node from its predecessor node \n           previous. next = current.next;\n       }\n    }\n}\n\nIt is important to consider edge cases when defining methods.\n\nOften, the edge cases are:\n\nThe empty list: first == null\nA list contains onlly 1 element: first == null\n\n\nGarbage: Note that we origianl first node is not referenced to by any permanent variables after the operation removeFirst()\n\nSuch objects are known as garbage\nObjects that become garbage are inaccessible and unusable in the program"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#other-types-of-simple-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Other types of Simple Linked List",
    "text": "Other types of Simple Linked List\n\nSimple Linked List\n\nThe simple (or singly-cahined) linked list is chained linearly and without a loop\nA variant of the simple linked list is double-ended list. It uses a last reference to help find the last element quickly.\nThe simple circular linked list is chained linearly and contains a loop.\n\nDoubly Linked List\n\nThe doubly linked list is a chained linearly using forward and backward links without a loop.\nThe doubly linked circular list is chained using forward and backward links and contains two loops"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "href": "notes/cs171/11-Linked-List/Linked List.html#using-a-linked-list-in-a-for-each-loop---implementing-the-iterable-interface-and-the-iterator-interface",
    "title": "Lecture 10 Linked List",
    "section": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface",
    "text": "Using a Linked List in a for-each Loop - Implementing the Iterable Interface and the Iterator Interface\n\nJava has a for-each loop that iterates over collection objects:\n\nfor (dataType x : Collection) {\n    // operations on x\n}\n\nFor example, an ArrayList is an iterable collection\n\nArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;();\na.add(1); a.add(2); a.add(3);\n\nfor (Integer i : a) {\n    System.out.println(i);\n}\n\nWe can use an ArrayList in the for-each loop because the ArrayList is Iterable. Our previous implementation of the GenericLinkedList class is not iterable, so we cannot use it in the for-each loop.\nNow, we make some changes to the GenericLinkedList class so that it is iterable:\n\npublic class GenericLinkedList&lt;T&gt; implements SimpleList&lt;T&gt;, Iterable&lt;T&gt; {\n    // Private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        // ...\n    }\n\n    // Private inner class MyLinkedListIterator\n    private class MyLinkedListIterator&lt;T&gt; implements Interator&lt;T&gt; {\n        private Node&lt;T&gt; current; // current position in the iteration\n\n        public MyLinkedListInterator(Node&lt;T&gt; f) { // contructor\n            current = f; // initialize\n        }\n\n        public boolean hasNext() {\n            // returns true if there are more nodes\n            return current != null;\n        }\n\n        public T next() {\n            // return the next element in the iteration\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            T res = current.item; // get the current item\n            current = current.next; // advance to the next node\n            return res;\n        }\n    }\n    private Node&lt;T&gt; first;\n    public GenericLinkedList() {\n        first = null;\n    }\n    // ... Other methods\n    public Iterator&lt;T&gt; iterator() { // implements the Iterable interface\n        return new LinkedListIterator&lt;T&gt;(first);\n    }\n}"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "href": "notes/cs171/11-Linked-List/Linked List.html#use-linked-list-to-implement-a-stack",
    "title": "Lecture 10 Linked List",
    "section": "Use Linked List to Implement a Stack",
    "text": "Use Linked List to Implement a Stack\npublic class ListStack&lt;T&gt; implements MyStack&lt;T&gt; {\n    // private inner class Node\n    prviate class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of the private inner class Node\n\n    private Node&lt;T&gt; frist;\n\n    public ListStack() { // constructor\n        first = null; //empty list = empty stack\n    }\n\n    // returns true is stack is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if stack is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // push(item) -&gt; insert at the front of the list\n    public void push(T item) {\n        Node&lt;T&gt; newNode = new Node&lt;T&gt;(item, first);\n        first = newNode;\n    }\n\n    // pop() -&gt; remove the first item and return it\n    public T pop() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nProperties of the stack implementation using a linked list\n\nThe push() and pop() does not have any loops!\n\nWe say that the push() and pop() runs in constant time\n\nWe can also implement a stack using push(item)=addLast(item) and pop()=removeLast().\n\nHowever, this is not preferred because addLast() and removeLast() requires the use of the list traversal algorithm and will run slower."
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "href": "notes/cs171/11-Linked-List/Linked List.html#implementing-queue-using-a-linked-list",
    "title": "Lecture 10 Linked List",
    "section": "Implementing Queue Using a Linked List",
    "text": "Implementing Queue Using a Linked List\npublic class ListQueue&lt;T&gt; implements MyQueue&lt;T&gt; {\n    // private inner class Node\n    private class Node&lt;T&gt; {\n        private T item;\n        private Node&lt;T&gt; next;\n\n        public Node(T item, Node&lt;T&gt; next) {\n            this.item = item;\n            this.next = next;\n        }\n\n        public String toString() {\n            return \"\" + this.item;\n        }\n    } // End of private inner class\n\n    private Node&lt;T&gt; first;\n\n    public ListQueue() { // constructor\n        first = null; // empty list = empty queue\n    }\n\n    // returns true if queue is empty\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    // returns true if queue is full\n    public boolean isFull() {\n        return false; // linked list is not fixed size\n    }\n\n    // enqueue(item) -&gt; insert at the end of the list\n    public void enqueue(T item) {\n        if (isEmpty()) {\n            first = new Node&lt;T&gt;(item, null);\n        } else {\n            Node&lt;T&gt; current = first;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = new Node&lt;T&gt;(item, null);\n        }\n    }\n\n    // dequeue() -&gt; remove the first item and return it\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        T toReturn = first.item;\n        first = first.next;\n        return toReturn;\n    }\n\n    // peek() -&gt; return the first item\n    public T peek() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return first.item;\n    }\n}\n\nPostscript:\n\nWe can also implement a queue using:\n\nenqueue(item) = addFirst(item)\ndequeue() = removeLast()"
  },
  {
    "objectID": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "href": "notes/cs171/11-Linked-List/Linked List.html#javas-linkedliste-class",
    "title": "Lecture 10 Linked List",
    "section": "Java’s LinkedList<E> Class",
    "text": "Java’s LinkedList&lt;E&gt; Class\n\nJava’s LinkedList&lt;E&gt; class implemented as a doubly-linked list\nSample methods:\n\nsize() // returns the number of elements in this list\n\naddFirst(E e);\naddLast(E e);\nadd(int index, E element)\n\nremoveFirst();\nremoveLasT();\nremove(int index)\n\ngetFirst();\ngetLast();\nget(int index)"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#introduction-to-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "",
    "text": "Recall: there are two commonly used data structures in computer science:\n\nStack (LIFO)\nQueue (FIFO)\n\n\n\n\n\n\n\n\nNote 1: Queue data structure\n\n\n\nA queue is a data structure that organizes the stored data in a First In First Out (FIFO) manner.\n\n\n\nTo achieve the FIFO behavior, the queue only provide the following two methods to access the data stored in a queue:\n\nenqueue(x): add x to the tail/back of the queue\ndequeue(): remove the item at the head/front of the queue and return it.\n\nSome computer algorithms/processes with a natural LIFO behavior:\n\nScheduling for fairness:\n\nFIFO is a service ordering that is fair.\nScheduling algorithms that serve requests from different clients often implement a FIFO service policy using a queue.\n\nThe Breath First Search (BFS) algorithm in graph applications:\n\nThe BFS algorithm will probe nodes that are nearest to the source nodes first.\nTo implement the “search the nearest nodes first” behavior, the BFS algorithm use a queue to store nodes to visit next."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#the-queue-interface",
    "title": "Lecture 9 Queue Data Structure",
    "section": "The Queue Interface",
    "text": "The Queue Interface\npublic interface MyQueueInterface&lt;E&gt; {\n    boolean isEmpty(); // returns true if the queue is empty\n    boolean isFull(); // returns true if the queue is full\n\n    void enqueue(E e); // insert the element e at the back of the queue\n    \n    E dequeue(); // remove the element at the front of the queue and return it\n\n    E peek(); // return the element at the front without removing it. \n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#implementing-a-queue-using-a-circular-array",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Implementing a Queue using a (Circular) Array",
    "text": "Implementing a Queue using a (Circular) Array\n\nWe can implement a queue with a fixed size array and 2 indices head and tail, where\n\nhead = location of the front (first position) of the queue\ntail = location of the open spot at the tail (last position) of the queue\n\nThe enqueue(x) method will append the element x at the tail of the queue.\nHowever, elements dequeued from the front of the array will cause some spaces unused. To solve it, we need to copy the elements to the front of the array, which requires many copy operations.\nThen, to avoid frequently copying arrays to save spaces, we will use a circular array instead.\n\n\n\n\n\n\n\nNote 2: Circular Buffer\n\n\n\nAlso known as circular array or ring buffer, is a data structure that uses an array as if it were connected end-to-end.\n\n\n\nThe circular buffer data structure consists of an array with 2 pointers or indices:\n\nread pointer = the index of the read position in the array\nwrite pointer = the index of the write position in the array\n\nWhen the write (or read) pointer reaches the end of the array/buffer, the write (or read) will wrap around and reset to 0. To achieve the wrap around effect, the read (or write) pointer variables is updated using modulo arithmetic.\n\n// Normal increment operation:\nwrite = wrtie + 1;\nread = read + 1;\n\n// Increatment operation with modulo arithmetic:\nwrite = (write + 1) % buf.length;\n\n// Suppose writhe = 15 and buf.length = 16, then\n// write = (write+1)%buf.length = (15+1)%16 = 16%16 = 0\n\nThe write() operation on a circular buffer will store the data at the write pointer and advance it. The basic implementation of the write() operation (without checking if buffer is full):\n\nvoid write(T e) {\n    buf[write] = e;\n    write = (write + 1) % buf.length;\n}\n\nThe read() operation will return the data at the read pointer and advance it. The basic implementation of the read() operation (without checking if buffer is empty):\n\nT read() {\n    T retVal = but[read];\n    read = (read + 1) % buf.length;\n    return retVal;\n}\n\nHow to tell if a circular buffer if empty or full:\n\nThe circular buffer is not empty when read != write\nThe circular buffer is empty when read == write\nThe circular buffer is not full when read != write\nThe circular buffer is full when read == write. –&gt; This causes problem: this also means empty.\nTo avoid ambiguity, we define the circular buffer to be full when there is 1 empty slot left.\n\nThe implementation of the queue data structure using a circular buffer:\n\npublic class IntegerQueue implements MyQueueInterface&lt;Integer&gt; {\n    private Integer[] buf; // Array of the circular buffer\n    private int read; // read pointer (= head index of queue)\n    private int write; // write pointer (= tail index of queue)\n\n    // Constructor\n    public IntegerQueue(int N) {\n        // Variable of the circular buffer\n        buf = new Integer[N]; // Create new array\n        read = 0; // initialize read pointer\n        write = 0; // initialize write pointer\n    }\n\n    /**\n     * The queue is empty when read pointer == write pointer\n     * @return true if the queue is empty\n     */ \n    public boolean isEmpty() {\n        return read == write;\n    }\n\n    /**\n     * The queue is full when there is one open spot left\n     * @return true if the queue is full\n     */\n    public boolean isFull() {\n        // buffer has 1 open spot\n        // &lt;==&gt; write 1 item into the buffer and it's full\n        return (write + 1) % buf.length == read;\n    } \n\n    public void enqueue(Integer e) {\n        if (isFull()) {\n            System.out.println(\"Full\"); // or throw exception\n            return;\n        }\n        buf[write] = e;\n        write = (write + 1) % buf.length;\n    }\n\n    public Integer dequeue() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        Integer retVal = buf[read];\n        read = (read + 1) % buf.length;\n        return retVal;\n    }\n\n    public Integer peek() {\n        if (isEmpty()) {\n            System.out.println(\"Empty\"); // or throw exception\n            return null;\n        }\n        return buf[read];\n    }\n}"
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---double-ended-de-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Double Ended (DE) Queue",
    "text": "Other Kinds of Queues - Double Ended (DE) Queue\n\n\n\n\n\n\nNote 3: Double Ended Queue\n\n\n\nA double ended queue is a data structure where we can insert or delete elements from either end\n\nThe operations on a Deque are:\n\naddFirst(x): insert x at the front of the Deque\naddLast(x): insert x at the tail of the Deque\nremoveFirst(x): remove the element at the front of the Deque and return it\nremoveLast(x): remove the element at the tail of the Deque and return it -\n\nA Double Ended Queue can work/operate like a stack. It can also work/operate like a queue."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#other-kinds-of-queues---priority-queue",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Other Kinds of Queues - Priority Queue",
    "text": "Other Kinds of Queues - Priority Queue\n\n\n\n\n\n\nNote 4: Priority Queue\n\n\n\nA priority queue is a data structure where\n\nThe stored data items can be ranked by some field rank in the data\nThe dequeue() operation will always remove the item in the priority queue that has the highest value in the rank field.\n\n\n\n\nThe priority queue is important in time cricical applications:\n\nSelect the next job to run (pick the most urgent one)\nSelect the next patient to treat, etc.\n\nA native implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) must make sure the array is sorted all the time (from large to small)\ndequeue(x) removes the first element in the array\n\nAnother naive implementation of the priority queue:\n\nUse a fixed size array\nenqueue(x) insert the element at the end\ndequeue(x) search the array for the largest element and remove it\n\nAn efficient implementation of the priority queue:\n\nThe heat data structure\nA heap is a complete binary tree data structure where the largest value is always stored in the root of the tree."
  },
  {
    "objectID": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "href": "notes/cs171/10-Queue-Data-Structure/Queue Data Structure.html#use-a-queue-in-javas-library",
    "title": "Lecture 9 Queue Data Structure",
    "section": "Use a Queue in Java’s Library",
    "text": "Use a Queue in Java’s Library\n\nUnlike the Stack (which is a class), the Queue is an interface in Java’s library.\nThe Queue interface is implemented by several classes, including\n\nArrayDeque\nPriorityQueue\n\nSome basic methods in the Queue interface:\n\nadd(E e): Inserts the specified element into this queue\nremove(): retrieves and removes the head of this queue\n\nExample:\n\npublic static void main(String[] args) {\n    Queue&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();\n\n    s.add(1);\n    System.out.println(s); // [1]\n    s.add(2);\n    System.out.println(s); // [1, 2]\n\n    System.out.println(s.remove()); // 1\n    System.out.println(s); // [2]\n}"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#object-oriente-d-thinking",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "Object-Oriente-d Thinking",
    "text": "Object-Oriente-d Thinking\n\nObject-Oriente-d Thinking\n\nIn order to maximize the inheritance mechanism to re-use existing software, we need to adopt the Object-Oriente-d Design methodology when developing the classes.\nThe Object-Oriente-d Design methodology organizes object class in a hierarchy according to common properties and actions\nThe Object-Oriente-d methodology can minimize the re-use of variables and methods.\n\nHow to maximize the sharing of properties and/or actions among classes\n\nWe use a class to model objects of the same type\nDifferent classes can have common properties and/or behaviors\nTo maximize sharing of common properties/behaviors, we generalize different classes into a large (super) class.\n\nThe is-a generalization method will give us the maximum sharing of properties and actions\n\n\nThe Object-Oriente-d Design methodology uses the is-a generalization technique to achieve maximal sharing of properties and actions between classes.\nHow to design the class hierarchy using the is-a generalization technique\n\nFirst, determine all the program classes that we will need to solve the problem. Determine the properties and actions that are needed in each class.\nThen, generalize similar program classes using the is-a generalization. Use the properties and actions in each class to find the more general classes.\nIf possible, generalize further. Use the final hierarchy to determine the properties and actions of each class. &gt; Superclass: the more general class in the is-a relationship (aka, parent class)\nA super class has a number of properties and actions. &gt; Subclass: the more specific class in the is-a relationship (aka, child class)\nEvery object of the subclass will have all the properties and actions in the superclass.\nIn addition, the subclass object can have other properties and actions not found in the superclass.\n\nSee TestGeometricObject.java\n\n\nThe OOP design allows us to avoid duplications of codes when solving a problem. - See TestOldWay.java\n\nWe define a superclass that contains the common (shared) properties and actions in all classes\n\nSome methods in the superclass may not have a useful method body - it’s OK. This is very useful for the polymorphism mechanism.\n\nWe create subclasses that extend the superclass.\n\nFor private instance variables, we must use its accessor/mutator methods to use the variables.\nFor public instance variables, we can access them directly.\n\nWe can override some methods in the subclass.\n\nRelationship between a subclass and its superclass\n\nA subclass inherits all variables and (normal) methods from its superclass.\nA subclass do not inherit any constructor method from its superclass.\n\nA constructor in the subclass must invoke a constructor in the superclass\nA subclass object always contains a superclass object.\nObjects are initialized using its constructor\n\nRule: a constructor in the subclass must invoke some constructor in its superclass as its first statement.\n\nThe keyword super(...) is used to invoke a constructor in its superclass.\n\nRule: if a constructor in the subclass does not invoke any constructor in its superclass, then, the Java compiler will automatically insert the call super() as the first statement. That is, when the first statement in a constructor is not super(...), the Java compiler will call the default constructor.\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    // Compile error -- why?\n  }\n}\n\npublic class SomeClass {\n  public int x;\n  public SomeClass(int a) {\n    x = a;\n  }\n}\n\nThe compile error is because the constructor NewClass() does not contain any super(...) calls, so Java compile will insert super(...):\n\npublic class NewClass extends SomeClass{\n  NewClass() {\n    super();\n  }\n}\n\nHowever, there is not matching constructor (SomeClass()) defined in the supercalss, which causes the error.\n\nConsequences of the constructor invocation rule in Java:\n\nConstructor invocation rule in Java:\n\nIf a class B inherits from class A, then every constructor in class B must invoke some constructor in class A.\n\nConsequence:\n\nIf another class C inherits from the class B, then every constructor in class C must invoke some constructor in class B and in class A.\nThis phenomenon is called constructor chaining.\n\n\nSummary:\n\nA subclass inherits all normal members (including private members) from its superclass\nMethods in the subclass cannot access the private inherited members directly.\nA subclass object contains (all members in) a supercalss object.\nA subclass do not inherit any constructors from its superclass.\nBecause a subclass object contains (All members in) a superclass object, every constructor in the subclass must invoke a constructor in the superclass.\n\nSometimes, we must use the overridden method inside the super class (i.e., use super.methodName())\nSee 05-bank-account:\n\nBankAccount.java\nSavingAccount.java\nTestSavingAccount.java"
  },
  {
    "objectID": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "href": "notes/cs171/05-Inheritance-and-Polymorphism/Inheritance_and_Polymorphism.html#the-protected-modifier-and-the-final-modifier",
    "title": "Lecture 4 Inheritance and Polymorphism",
    "section": "The protected Modifier and the final Modifier",
    "text": "The protected Modifier and the final Modifier\n\nThe accessibility modifiers indicates the degree of trust (closeness) of program code written by different people.\n\nHighest level of trust: Code inside a class\n2nd highest level of trust: code inside a package\nLowest level of trust: code inside a different package.\nThe protected modifier will allow subclasses inside a different package to access data fields or methods in the superclass.\nSyntax to define a member with protected accessibility:\n\n  protected memberDefinition;\n\nWhere we can access with protected accessibility:\n\nfrom inside a method in the same class (closest association)\nfrom inside a method in the same package (2nd closest association)\nfrom inside a method in a subclass defined outside the package\nbut not from inside a method in an unrelated class defined outside the package\n\n\n\n\n\n\n\n\n\n\n\n\nModifier on Members\nfrom the same class\nfrom the same package\nfrom subclass in different package\nfrom a different package\n\n\n\n\npublic\nOK\nOK\nOK\nOK\n\n\nprotectd\nOK\nOK\nOK\nNo\n\n\ndefault\nOK\nOK\nNo\nNo\n\n\nprivate\nOK\nNo\nNo\nNo\n\n\n\n\nSee TestNewCircle.java and TestNewCircle.java\nA class with the final qualifier cannot be extended (i.e., used as a superclass)\n\n// This class cannot be extended\npublic final class myClass {\n  // data fieds, constrcutors, and methods omitted.\n}\n\nA method with the final qualifier cannot be overridden in a subclass\n\npublic class myClass {\n  // This method cannot be overridden\n  public final void method1() {\n    // Do something,\n  }\n}\n\nSee FinalCircle.java and FinalGeometricObject.java"
  },
  {
    "objectID": "photo.html",
    "href": "photo.html",
    "title": "Photograph",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays---for-a-given-search-value-key-find-the-index-of-the-first-array-element-that-contains-the-search-value-key.---return--1-when-the-key-is-not-found-in-the-array.",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays: > - For a given search value key, find the index of the first array element that contains the search value key. > - Return -1 when the key is not found in the array.",
    "text": "The Search Problem for Arrays: &gt; - For a given search value key, find the index of the first array element that contains the search value key. &gt; - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "href": "notes/cs171/08-Array-Data-Structure/Array Data Structure.html#the-search-problem-for-arrays",
    "title": "Lecture 7 Array Data Structure",
    "section": "The Search Problem for Arrays:",
    "text": "The Search Problem for Arrays:\nFor a given search value key, find the index of the first array element that contains the search value key. - Return -1 when the key is not found in the array."
  },
  {
    "objectID": "notes/cs377.html",
    "href": "notes/cs377.html",
    "title": "CS 377 Database Systems",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n1 The Relational Model\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nRelational Model\n\n\n\nThis lecture discusses the relational model, which is the foundation of modern database systems.\n\n\n\n\n\nAug 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n2 Relational Algebra\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nRelational Model\n\n\nRelational Algebra\n\n\n\nThis lecture discusses the relational algebra, which is the foundation of modern database systems. Topics include select, project, and join operators.\n\n\n\n\n\nSep 8, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n3 SQL Introduction\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\n\nThis note introduces SQL, the Structured Query Language, which is used to interact with databases. We will cover basic queries, the use of *, AS, conditions, and ORDER BY in SQL.\n\n\n\n\n\nSep 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n4 SQL Aggregation\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nAggregation\n\n\n\nThis lecture discusses SQL Aggregation, including computing on a column, GROUP BY, and HAVING clauses.\n\n\n\n\n\nSep 14, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n5 SQL Set Operations\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nSet Operations\n\n\n\nThis lecture discusses SQL set operations, including UNION, INTERSECT, and EXCEPT. It also covers the difference between bag and set semantics in SQL.\n\n\n\n\n\nSep 18, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n6 SQL Join\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJoin\n\n\n\nThis lecture discusses the different types of joins in SQL, including inner, outer, and cross joins. It also covers the dangers of using NATURAL JOIN and the best practices for using joins in SQL.\n\n\n\n\n\nSep 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n9 SQL DDL\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nDDL\n\n\n\nThis lecture discusses Database Modification Language in SQL, including Insert, Delete, Update, and Create operations. It also covers SQL Schemas, Types, Keys, and Foreign Keys.\n\n\n\n\n\nOct 28, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n10 JDBC\n\n\n\n\n\n\nCoding\n\n\nSQL\n\n\nDatabase\n\n\nJava\n\n\nJDBC\n\n\n\nThis lecture discusses how to embed SQL in Java using JDBC. It covers the JDBC API, SQL Injection, and Prepared Statements.\n\n\n\n\n\nOct 30, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\n\n\n\n\n\n\n11 ER Design\n\n\n\n\n\n\nCoding\n\n\nDatabase\n\n\nDatabase Design\n\n\nER Design\n\n\n\nThis lecture discusses Entity-Relationship (ER) design, which is a technique for designing databases. It covers the ER model, ER diagrams, and the process of converting ER diagrams to relational schemas.\n\n\n\n\n\nNov 10, 2024\n\n\nJiuru Lyu\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html",
    "title": "9 SQL DDL",
    "section": "",
    "text": "Two ways to insert tuples, either into an empty or non-empty table: - INSERT INTO &lt;relation&gt; VALUES &lt;list of tuples&gt;; - INSERT INTO &lt;relation&gt; (&lt;subquery&gt;);\n\nCREATE TABLE Invite(\n    name TEXT,\n    campus TEXT DEFAULT 'StG',\n    email TEXT,\n    age INT\n);\n\nINSERT INTO Invite VALUES ('Mark', 'StG', 'm@m.com', 18);\nINSERT INTO Invite(name, email) VALUES ('Mark', 'm@m.com');\n\n-- the order of columns can be controlled for inserts\nINSERT INTO Invite(email, name) VALUES ('m@m.com', 'Mark');\n\nINSERT INTO Invite(name, email) (\n    SELECT firstname, email\n    FROM Student\n    WHERE cgpa &gt; 3.4\n);\n\nNaming attributes in INSERT\n\nSometimes we want to insert tuples, but we don’t have values for all attributes.\nIf we name the attributes we are providing values for, the system will use NULL or a default for the rest.\nConvenient!\n\n-- Insert multiple values\nINSERT INTO Invite VALUES\n  ('Mark', 'StG','m@m.com',18),\n  ('Sasha', 'UTM','s@s.com',19),\n  ('Al','StG','a@a.com',20),\n  ('Link','StG','li@li.com',18);\n\n\n\n\n\nDeletion\n\nDelete tuples satisfying a condition: DELETE FROM &lt;relation&gt; WHERE &lt;condition&gt;;\nDelete all tuples: DELETE FROM &lt;relation&gt;;\n\n-- Delete tough courses where no student has passed…  \nDELETE FROM Course  \n     WHERE NOT EXISTS (  \n     SELECT *  \n     FROM Took JOIN Offering ON Took.oid = Offering.oid  \n     WHERE  \n         grade &gt; 60 AND  \n         Offering.dept = Course.dept AND  \n         Offering.cnum = Course.cnum\n);\n\n\n\n\n\nTo change the value of certain attributes in certain tuples to given values:\n\nUPDATE &lt;relation&gt;\nSET &lt;list of attribute assignments&gt;\nWHERE &lt;condition on tuples&gt;;\n\n\n\n\n\n\nTip 1: Example of UPDATE\n\n\n\n\n\nUPDATE Student\nSET campus = 'UTM'\nWHERE sid = 999999;\n\nUPDATE Took\nSET grade = 50\nWHERE grade &gt;= 47 and grade &lt; 50;\n\n\n\n\n\n\n\n\n\nWarning 1: Inside the SET Clause, Aliases are Not Allowed\n\n\n\nUPDATE StrugglingLabel S\nSET S.label_country = ( -- Illegal!\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n-- The following is legal: \nUPDATE StrugglingLabel S\nSET label_country = ( -- no alias allowed here\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n\n\n\n\nCREATE TABLE &lt;table name&gt; (\n    &lt;column_name1&gt; &lt;data type&gt;,\n    &lt;column_name2&gt; &lt;data type&gt;,\n    &lt;column_name3&gt; &lt;data type&gt;,\n);"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#database-modifications",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#database-modifications",
    "title": "9 SQL DDL",
    "section": "",
    "text": "Two ways to insert tuples, either into an empty or non-empty table: - INSERT INTO &lt;relation&gt; VALUES &lt;list of tuples&gt;; - INSERT INTO &lt;relation&gt; (&lt;subquery&gt;);\n\nCREATE TABLE Invite(\n    name TEXT,\n    campus TEXT DEFAULT 'StG',\n    email TEXT,\n    age INT\n);\n\nINSERT INTO Invite VALUES ('Mark', 'StG', 'm@m.com', 18);\nINSERT INTO Invite(name, email) VALUES ('Mark', 'm@m.com');\n\n-- the order of columns can be controlled for inserts\nINSERT INTO Invite(email, name) VALUES ('m@m.com', 'Mark');\n\nINSERT INTO Invite(name, email) (\n    SELECT firstname, email\n    FROM Student\n    WHERE cgpa &gt; 3.4\n);\n\nNaming attributes in INSERT\n\nSometimes we want to insert tuples, but we don’t have values for all attributes.\nIf we name the attributes we are providing values for, the system will use NULL or a default for the rest.\nConvenient!\n\n-- Insert multiple values\nINSERT INTO Invite VALUES\n  ('Mark', 'StG','m@m.com',18),\n  ('Sasha', 'UTM','s@s.com',19),\n  ('Al','StG','a@a.com',20),\n  ('Link','StG','li@li.com',18);\n\n\n\n\n\nDeletion\n\nDelete tuples satisfying a condition: DELETE FROM &lt;relation&gt; WHERE &lt;condition&gt;;\nDelete all tuples: DELETE FROM &lt;relation&gt;;\n\n-- Delete tough courses where no student has passed…  \nDELETE FROM Course  \n     WHERE NOT EXISTS (  \n     SELECT *  \n     FROM Took JOIN Offering ON Took.oid = Offering.oid  \n     WHERE  \n         grade &gt; 60 AND  \n         Offering.dept = Course.dept AND  \n         Offering.cnum = Course.cnum\n);\n\n\n\n\n\nTo change the value of certain attributes in certain tuples to given values:\n\nUPDATE &lt;relation&gt;\nSET &lt;list of attribute assignments&gt;\nWHERE &lt;condition on tuples&gt;;\n\n\n\n\n\n\nTip 1: Example of UPDATE\n\n\n\n\n\nUPDATE Student\nSET campus = 'UTM'\nWHERE sid = 999999;\n\nUPDATE Took\nSET grade = 50\nWHERE grade &gt;= 47 and grade &lt; 50;\n\n\n\n\n\n\n\n\n\nWarning 1: Inside the SET Clause, Aliases are Not Allowed\n\n\n\nUPDATE StrugglingLabel S\nSET S.label_country = ( -- Illegal!\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n-- The following is legal: \nUPDATE StrugglingLabel S\nSET label_country = ( -- no alias allowed here\n        SELECT R.country\n        FROM RecordLabel R\n        WHERE R.label_id = S.label_id\n);\n\n\n\n\n\nCREATE TABLE &lt;table name&gt; (\n    &lt;column_name1&gt; &lt;data type&gt;,\n    &lt;column_name2&gt; &lt;data type&gt;,\n    &lt;column_name3&gt; &lt;data type&gt;,\n);"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#sql-schemas",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#sql-schemas",
    "title": "9 SQL DDL",
    "section": "SQL Schemas",
    "text": "SQL Schemas\n\nSchema: a kind of namespace\n\nWhen you connect to your psql cloud instance, by default you’re in the public schema\nEverything defined (tables, types, etc.) goes into one big pot.\nSchemas let you create different namespaces.\nUseful for logical organization, and for avoiding name clashes.\n\nYou already have a schema called “public”.\nYou can also create your own.\n\nExample: CREATE SCHEMA University;\n\nTo refer to things inside a particular schema, you can use dot notation:\n\nCREATE TABLE University.Student (...);\nSELECT * FROM University.Student;\n\nThe search path\n\nTo see the current search path: SHOW SEARCH_PATH;\nYou can set the search path yourself.\n\nExample: SET SEARCH_PATH to University, public;"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#types",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#types",
    "title": "9 SQL DDL",
    "section": "Types",
    "text": "Types\n\nTable attributes have types\n\nWhen creating a table, you must define the type of each attribute.\nAnalogous to declaring a variable’s type in a program.\n\nEg, int num; in Java or C.\nSome programming languages don’t require type declarations. Eg, Python.\n\nWhy are type declarations required in SQL?\n\nUsually worth the cost in the world of DB systems, since validity of data is important\n\n\nBuilt-in types\n\nCHAR(n): fixed-length string of n characters. Padded with blanks if necessary.\nVARCHAR(n): variable-length string of up to n characters.\nTEXT: variable-length, unlimited. Not in the SQL standard, but psql and others support it. E.g. 'Macbeth', 'Shakespeare''s Sonnets'\nINT = INTEGER, e.g. 37\nFLOAT = REAL, e.g. 1.49, 37.96e2\nBOOLEAN = TRUE, FALSE\nDATE e.g. '2011-09-22'\nTIME e.g. '15:00:02', '15:00:02.5'\nTIMESTAMP (date plus time), e.g. 'Jan-12-2011 10:25'\n… Documentation\n\nUser-defined types (…in PostgreSQL)\n\nDefined in terms of a built-in type.\nYou make it more specific by defining constraints (and perhaps a default value).\n\n\n\n\n\n\n\n\nTip 2: Example of User-defined Types\n\n\n\n\n\nCREATE DOMAIN Grade AS int\n    DEFAULT null\n    CHECK (VALUE &gt;= 0 AND VALUE &lt;= 100);\n\nCREATE DOMAIN Campus AS varchar(4)\n    DEFAULT 'StG'\n    CHECK (VALUE IN ('StG','UTM','UTSC'));\n\n\n\n\nSemantics of type constraints\n\nConstraints on a type are checked every time a value is assigned to an attribute of that type.\nYou can use these to create a powerful type system.\n\nSemantics of default values\n\nThe default value for a type is used when no value has been specified.\nUseful! You can run a query and insert the resulting tuples into a relation – even if the query does not give values for all attributes.\nTable attributes can also have default values.\n\n\n-- attribute default: for that one attribute in that one table\nCREATE TABLE Awards (\n    sID Integer,\n    numAwards Integer DEFAULT 0,\n    FOREIGN KEY (sID) REFERENCE Student\n);\n\n-- type default: for for every attribute defined to be of that type\nCREATE DOMAIN CGPA AS NUMERIC(10, 2)\n    DEFAULT 0\n    CHECK (VALUE &gt;= 0 AND VALUE &lt;= 4.0)"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#keys-and-foreign-keys",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#keys-and-foreign-keys",
    "title": "9 SQL DDL",
    "section": "Keys and Foreign Keys",
    "text": "Keys and Foreign Keys\n\nKey constraints\n\nDeclaring that a set of one or more attributes are the PRIMARY KEY for a relation means:\n\nthey form a key (unique, minimal)\ntheir values will never be null (you don’t need to separately declare that)\n\nBig hint to the DBMS: optimize for searches by this set of attributes!\nEvery table must have 0 or 1 primary key.\n\nA table can have no primary key, but in practice, every table should have one.\nYou cannot declare more than one primary key. (Think of the PK as the identity of a row..)\n\n\nDeclaring primary keys\n\nFor a single-attribute key, can be part of the attribute definition.\nOr can be at the end of the table definition. (This is the only way for multi-attribute keys.) The brackets are required.\n\n\nCREATE TABLE Blah (\n    ID INTEGER PRIMARY KEY,\n    name VARCHAR(25)\n);\n\nCREATE TABLE Blah (\n    ID INTEGER,\n    name VARCHAR(25),\n    PRIMARY KEY (ID, name)\n);\n\nUniqueness constraints\n\nDeclaring that a set of one or more attributes is UNIQUE for a relation means:\n\nthey form a key\ntheir values can be null; if they mustn’t, you need to separately declare that\n\nYou can declare more than one set of attributes to be UNIQUE.\nUsed to enforce unique constraints on a column (or group of columns) which is not a primary key.\nExample: Make SID primary key, and SSN unique (it’s okay if it’s NULL but if you do have SSN then it must be unique!)\n\nDeclaring UNIQUE\n\nIf only one attribute is involved, can be part of the attribute definition.\nOr can be at the end of the table definition. (This is the only way if multiple attributes are involved.) The brackets are required.\n\n\nCREATE TABLE Blah (\n    ID integer UNIQUE,\n    name varchar(25)\n);\n\nCREATE TABLE Blah (\n    ID integer,\n    name varchar(25),\n    UNIQUE (ID)\n);\n\nWe saw earlier how nulls affect “unique”\n\nFor uniqueness constraints, no two nulls are considered equal.\n\n\n\n\n\n\n\n\nTip 3: Example of UNIQUE\n\n\n\n\n\n\nConsider:\n\nCREATE TABLE Testunique (\n    first VARCHAR(25),\n    last VARCHAR(25),\n    UNIQUE(first, last))\n\nThis would prevent two insertions of ('Stephen', 'Cook')\nBut it would allow two insertions of (null, 'Rackoff')\nThis can’t occur with a primary key because primary key will consider two nulls as equal.\n\n\n\n\n\nForeign key constraints\n\nExample from table Took: FOREIGN KEY (sID) REFERENCES Student\nMeans that attribute sID in this table is a foreign key that references the primary key of table Student.\nEvery value for sID in this table must actually occur in the Student table.\nRequirements:\n\nMust be declared either primary key or unique in the “home” table (i.e. table “Student” in the above example)\n\n\nDeclaring foreign keys\n\nAgain, declare with the attribute (only possible if just a single attribute is involved) or as a separate table element.\nCan reference attribute(s) that are not the primary key as long as they are unique; just name them.\n\n\nCREATE TABLE People (\n    SIN INTEGER PRIMARY KEY,\n    name TEXT,\n    AETNA TEXT UNIQUE\n);\n\nCREATE TABLE Volunteers (\n    email TEXT PRIMARY KEY,\n    AETNAnum text REFERENCES People(AETNA)\n);\n\n-- What if we run the following?\nCREATE TABLE Volunteers (\n    email TEXT PRIMARY KEY,\n    AETNAnum text REFERENCES People -- referring to the primary key by default\n);\n\nEnforcing foreign-key constraints\n\nSuppose there is a foreign-key constraint from relation \\(R\\) to relation \\(S\\).\nHow/when can the DBMS ensure that:\n\nthe referenced attributes are PRIMARY KEY or UNIQUE?\nthe values actually exist?\n\nWhat could cause a violation?\n\nExample: a row is deleted from Course; Offering is now referring to a course that doesn’t exist.\n\nYou get to define what the DBMS should do.\nThis is called specifying a “reaction policy.”"
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#reaction-policies",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#reaction-policies",
    "title": "9 SQL DDL",
    "section": "Reaction Policies",
    "text": "Reaction Policies\n\nPossible Politicies\n\nCASCADE: propagate the change to the refering table\n\n\n\n\n\n\n\n\nTip 4: Example of CASCADE\n\n\n\n\n\nif a Student leaves university, delete all their referrals in Took!\n\n\n\n\nSET NULL: set the referring attribute(s) to NULL\nIf you say nothing, the default is to forbid the change in the referred-to table. i.e., RESTRICT\n\n\n\n\n\n\n\nWarning 2: Note the Assymetry\n\n\n\n\nSuppose table T refers to table S.\nYou can define “fixes” that propogate changes backwards from S to T.\n(You define them in table T because it is the table that will be affected)\nYou cannot define fixes that propogate forward from T to S.\n\n\n\n\n\n\n\n\n\nCaution 1: Syntax for Reaction Policies\n\n\n\n\nAdd your reaction policy where you specify the foreign key constraint\nExample:\n\nCREATE TABLE Took {\n    ...\n    FOREIGN KEY (sID) REFERENCES Student ON DELETE CASCADE\n}\n\n\n\nWhat you can react to: Your reaction policy can specify what to do either\n\non delete, i.e., when a deletion creates a dangling reference,\non update, i.e., when an update creates a dangling reference,\nor both. Just put them one after the other.\n\n\n\n\n\n\n\n\nTip 5: Example of What We Can React to\n\n\n\n\n\nON DELETE RESTRICT \nON UPDATE CASCADE\n\n\n\n\nWhat your reaction can be: Your policy can specify one of these reactions (there are others):\n\nRESTRICT: Don’t allow the deletion/update.\nCASCADE: Make the same deletion/update in the referring tuple.\nSET NULL: Set the corresponding value in the referring tuple to null."
  },
  {
    "objectID": "notes/cs377/09-sql-ddl/09 SQL DDL.html#removing-schema",
    "href": "notes/cs377/09-sql-ddl/09 SQL DDL.html#removing-schema",
    "title": "9 SQL DDL",
    "section": "Removing Schema",
    "text": "Removing Schema\n\nRemoving a schema\n\nEasy: DROP SCHEMA University CASCADE;\n\nCASCADE means everything inside it is dropped too.\n\nTo avoid getting an error message if the schema does not exist, add IF EXISTS.\n\nUsage pattern\n\nYou can use this at the top of every DDL file:\n\nDROP SCHEMA IF EXISTS University CASCADE;\nCREATE SCHEMA University;\nSET search_path TO University;\n\nHelpful during development, when you may want to change the schema, or test queries under different conditions.\n\nUpdating the schema itself\n\nALTER: alter a domain or table or column\n\n-- You can add a column to a table\nALTER TABLE Course\nADD COLUMN numSections INTEGER;\n-- You can drop a column entirely from a table\nALTER TABLE Course\nDROP COLUMN breadth;\n-- You can change the type of a column in a table\nALTER TABLE Course\nALTER COLUMN dept TYPE VARCHAR(40);\n\nDROP: can also be used to remove a domain, table, view, or whole schema\n\nDROP TABLE course;\nHow is that different from this?\n\nDELETE FROM course;\n\nIf you drop a table that is referenced by another table, you must specify CASCADE\nThis removes all referring rows.\n\nCHECK: we’ve seen a check clause on a user-defined domain:\n\nCREATE DOMAIN Grade AS as smallint\n  DEFAULT NULL\n  CHECK (VALUE &gt;=0 AND VALUE &lt;=100);\n\nYou can also define a check constraint:\n\non an attribute\non the tuples of a relation\nacross relations\n\nAttribute-based CHECK constraints\n\nDefined with a single attribute and constrain its value (in every tuple)\nRefer to attributes by attributes by their names (do not use the keyword value)\nChecked when a tuple is inserted into that relation, or its value for that attribute is updated.\n\n\n\n\n\n\n\n\n\nTip 6: Example of Attribute-based CHECK constraints\n\n\n\n\n\nCREATE TABLE GradStudent (\n    sID INTEGER,\n    program VARCHAR(3) CHECK\n        (program IN ('MS', 'PhD')),\n    firstName VARCHAR(15) NOT NULL, ...);\n\n\n\n- `NOT NULL`constraint: \n  - You can declare that an attribute of a table is `NOT NULL`.\nCREATE TABLE Course (\n    cNum INTEGER,\n    name VARCHAR(40) NOT NULL,\n    dept Department,\n    breadth BOOLEAN,\n    PRIMARY KEY (cNum, dept));\n- In practise, many attributes should be not null.\n- This is a very specific kind of attribute-based constraint.\n\nTuple-based `CHECK constraints\n\nDefined as a separate element of the table schema so can refer to any attributes of the table.\nChecked when a tuple is inserted into that relation, or updated.\n\n\n\n\n\n\n\n\nTip 7: Example of Tuple-based CHECK constraints\n\n\n\n\n\nCREATE TABLE Student (\n    sID INTEGER,\n    age INTEGER,\n    year INTEGER,\n    college VARCHAR(4),\n        CHECK (YEAR = age - 18)\n);\n\n\n\n\nHow nulls affect CHECK constraints\n\nA check constraint only fails if it evaluates to FALSE.\nIt is not picky like a WHERE condition.\n\n\n\n\n\n\n\n\nTip 8: Example of How Nulls Affect CHECK Constraints\n\n\n\n\n\nSuppose CHECK (age &gt; 0) | age | Value of condition | CHECK outcome | WHERE outcome | |:—:|:——————-:|:—————:|:—————:| |19 | TRUE| pass| pass| |-5 | FALSE| fail| fail| |NULL | UNKNOWN| pass| fail|\n\n\n\n\n\n\n\n\n\nTip 9: Example of NOT NULL Constraint\n\n\n\n\n\n\nSuppose you created this table:\n\nCREATE TABLE Tester (\n    num INTEGER,\n    word VARCHAR(10),\n        CHECK (num &gt; 5));\n\nIt would allow you to insert (NULL, ‘hello’)\nIf you need to prevent that, use a NOT NULL constraint.\n\nCREATE TABLE Tester (\n    num INTEGER NOT NULL,\n    word VARCHAR(10),\n        CHECK (num &gt; 5));\n\n\n\n\n\n\n\n\n\nWarning 3: Order of Constraints\n\n\n\nOrder of constraints doesn’t matter, and doesn’t dictate the order in which they’re checked"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html",
    "title": "1 The Relational Model",
    "section": "",
    "text": "DB are designed to solve the problem Physical Data Dependence: so, they are physical data independence\n“The three-schema architecture” separates user programs from the physical DB"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#db-systems-to-rescue",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#db-systems-to-rescue",
    "title": "1 The Relational Model",
    "section": "",
    "text": "DB are designed to solve the problem Physical Data Dependence: so, they are physical data independence\n“The three-schema architecture” separates user programs from the physical DB"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#data-model",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#data-model",
    "title": "1 The Relational Model",
    "section": "Data Model",
    "text": "Data Model\n\n\n\n\n\n\nData Model\n\n\n\nEvery DBMS is based on some data model, a notation for describing data, including\n\nThe structure of the data\nConstraints on the content of the data\nOperations on the data\n\n\n\n\n\n\n\n\n\nTip 1: Examples of Data Model\n\n\n\n\n\n\nNetwork & hierarchical data model – of historical interest\nRelational data model\nSemistructured data model"
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#relations-schema-instance-and-keys",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#relations-schema-instance-and-keys",
    "title": "1 The Relational Model",
    "section": "Relations: Schema, Instance, and Keys",
    "text": "Relations: Schema, Instance, and Keys\n\n\n\n\n\n\nDomain, Cartesian Product, and Relation (Tables)\n\n\n\nA domain is a set of values.\n\nSuppose \\(D_1,D_2,\\dots,D_n\\) are domains.\n\nThe Cartesian (cross) product \\(D_1\\times D_2\\times\\cdots\\times D_n\\) is the set of all tuples \\(\\langle d_1,d_2,\\dots,d_n\\rangle\\) such that \\(d_1\\in D_1, d_2\\in D_2,\\dots,d_n\\in D_n\\).\nMathematical relation on \\(D_1,\\dots,D_n\\) is a subset of the Cartesian product.\n\nOur database tables are relations, too.\n\n\n\n\n\n\n\n\n\nSchema\n\n\n\nSchema: definition of the structure of the relation.\n\nNotation: \\[\\text{Teams}(\\text{Name},\\text{HomeField},\\text{Coach})\\]\n\n\n\n\n\n\n\n\n\nInstance\n\n\n\nInstance: particular data in the relation.\n\nInstance change constantly; schemas rarely.\nExample: Adding a column (attribute) changes the schema as well as the instance\nWhen designing the DB, we should avoid changing schema very frequently because changing schema is expensive.\n\n\n\n\n\n\n\n\n\nMore Definitions\n\n\n\nIn a DB table:\n\nrelation = table itself\nattribute = column (optionally, we can specify that attributes have domains)\ntuple = row\narity = number of attributes (columns)\ncardinality = umber of tuples (rows)\n\n\n\n\nA relation is a set of tuples, which means:\n\nthere can be no duplicate tuples\norder of the tuples does not matter\n\n\n\n\n\n\n\n\nDatabase\n\n\n\nDatabase schema: a set of relation schemas –&gt; no actual data\nDatabase instance: a set of relation instances\n\n\n\n\n\n\n\n\nSuperkeys\n\n\n\nSuperkeys: a set of one or more attributes whose combined values are unique. That is, no two tuples can have the same values on all of these attributes.\n\nBy default, tuples cannot be duplicated. So, the entire tuple is viewed as a superkey. But, we can declare other superkeys. So, every relation have a superkey.\nThere can be multiple superkeys for a relation.\n\n\n\n\n\n\n\n\n\nKeys\n\n\n\nKey: a minimal superkey.\n\nThat is, you may not remove an attribute from a key, and still have a set of attributes whose combined values are unique.\n\n\n\n\n\n\n\n\n\nTip 2: Example\n\n\n\n\n\nA relation called Course, which attributes: department codes, course number, and course name. One tuple might be \\[\\text{Course}\\langle\\text{``cs''},\\text{``377''},\\text{``Introduction to Databases''}\\rangle\\] The superkey for this relation would be the combinations of cs and 377. The entire tuple can also be viewed as a superkey. However, \\(\\langle\\text{``cs''},\\text{``377''}\\rangle\\) is the key.\n\n\n\n\n\n\n\n\n\nTip 3: Example\n\n\n\n\n\nConsider the following relation: \\[\\text{Studnet}\\langle\\text{student\\#},\\text{netID},\\text{surname},\\text{firstname},\\text{gpa}\\rangle.\\] This relation has multiple key: student# or netID can either serve as a key.\n\n\n\n\nWe underline attributes in the schema to indicate that they form a key.\n\nFor example, \\[\\text{Team}\\langle\\underline{\\text{Name},\\text{HomeField}},\\text{Coach}\\rangle\\]\n\nAside: Called “superkey” because it is a superset of some key. (Not necessarily a proper superset.)\nIf a set of attributes is a key for a relation\n\nIt does not mean merely that “there are no duplicates” in particular instance of the relation\nIt means that in principle there cannot be any\n\nOften we have to invent an artificial new attribute to ensure all tuples will be unique.\nA key is a kind of integrity constraint."
  },
  {
    "objectID": "notes/cs377/01-relational-model/01 The Relational Model.html#reference-and-keys",
    "href": "notes/cs377/01-relational-model/01 The Relational Model.html#reference-and-keys",
    "title": "1 The Relational Model",
    "section": "Reference and Keys",
    "text": "Reference and Keys\n\nRelations often refer to each other.\n\n\n\n\n\n\n\nForeign Key\n\n\n\nIf the referring attribute refers to a key attribute in another table, it is called a foreign key.\n\nFor example, in table Roles, the attribute aID refers to the key aID in the Artists table, we write \\(\\text{Roles}[\\text{aID}]\\subseteq\\text{Artists}[\\text{aID}]\\).\nMore generally, we use the following notation: \\(R_1[X]\\subseteq R_2[Y]\\).\n\n\n\n\nThis gives us a way to refer to a single tuple in that relation.\nA foreign key may need to have several attributes.\nThe \\(R[A]\\) notation:\n\n\\(R\\) is the relation, and \\(A\\) is a list of attributes in \\(R\\).\n\\(R[A]\\) is the set of all tuples from \\(R\\), but with only the attributes in list \\(A\\).\n\n\n\n\n\n\n\n\nReferential Integrity Constraints\n\n\n\nThese \\(R_1[X]\\subseteq R_2[Y]\\) relationships are called referential integrity constraints or inclusion dependencies.\n\nNot all referential integrity constraints are foreign key constraints.\n\\(R_1[X]\\subseteq R_2[Y]\\) is a foreign key constraint \\(\\iff\\) \\(Y\\) is a key for relation \\(R_2\\).\n\n\n\n\nIntegrity constraints is part of the process: designing a schema\n\nMapping from the real world to a relational schema is surprisingly challenging and interesting.\nTwo important goals:\n\nRepresent the data well.\nAvoid redundancy."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html",
    "title": "2 Relational Algebra",
    "section": "",
    "text": "Operands: Table\nOperators:\n\nchoose only the rows (tuples) you want\n\nchoose only the columns (attributes) you want\ncombine tables\n\nand a few other things.."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#introduction",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#introduction",
    "title": "2 Relational Algebra",
    "section": "",
    "text": "Operands: Table\nOperators:\n\nchoose only the rows (tuples) you want\n\nchoose only the columns (attributes) you want\ncombine tables\n\nand a few other things.."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#select-choose-rows",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#select-choose-rows",
    "title": "2 Relational Algebra",
    "section": "Select: choose rows",
    "text": "Select: choose rows\n\n\n\n\n\n\nNotation: Select\n\n\n\n\\({\\Large\\sigma}_C(R)\\), where\n\n\\(R\\) is the relation/table,\nCondition \\(c\\) is a boolean expression.\n\n\n\n\nIt can use comparison operators and boolean operators\nThe operands are either constants or attributes of R.\nThe result is a relation:\n\nwith the same schema as the operand\n\nbut with only the tuples that satisfy the condition.\n\n\n\n\n\n\n\n\nTip 1: Example: Select\n\n\n\n\n\nTo select all British actors, we can use \\({\\Large\\sigma}_{\\text{nationality}=\\text{``British''}}(\\texttt{Artists})\\). To select all movies from the 1970s, we can use \\({\\Large\\sigma}_{\\text{year}&gt;1969\\text{ and }\\text{year}&lt;1980}(\\texttt{Movies})\\). Instead of using the word “\\(\\text{and}\\),” we can also use the and operator in logic: \\(\\land\\)"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#project-choose-columns",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#project-choose-columns",
    "title": "2 Relational Algebra",
    "section": "Project: choose columns",
    "text": "Project: choose columns\n\n\n\n\n\n\nNotation: Project\n\n\n\n\\({\\Large\\pi}_L(R)\\), where\n\n\\(R\\) is a relation/table,\n\\(L\\) is a subset of the attributes of \\(R\\).\n\n\n\n\nThe result is a relation\n\nwith all the tuples from \\(R\\)\n\nbut with only the attributes in \\(L\\), and in that order.\n\nThe project operator removes duplicates:\n\nThis is due to that we are using the set notation, and so we cannot have duplicate tuples in a table.\n\n\n\n\n\n\n\n\nTip 2: Example: Project\n\n\n\n\n\n\\({\\Large\\pi}_{\\text{director}}(\\texttt{Movies})\\) will result \\(\\{\\text{Kubrick}, \\text{Altman}, \\text{Polanski}, \\text{Lucas}\\}\\) although the original table has \\(7\\) director names.\n\n\n\n\n\n\n\n\n\nTip 3: Example: Combine select and project\n\n\n\n\n\nQ: Write an RA expression to find the names of all directors of movies from the 1970s. A: \\({\\Large\\pi}_{\\text{director}}{\\Large\\sigma}_{\\text{year}&gt;1969\\land\\text{year}&lt;1980}(\\texttt{Movies})\\)\n\nNote that, as we want to find the names of directors, so we will to the project operator as the last step.\nHence, we will do select first, and then project."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#combining-tables",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#combining-tables",
    "title": "2 Relational Algebra",
    "section": "Combining Tables",
    "text": "Combining Tables\n\nCartesian Product: Combine Tables\n\n\n\n\n\n\nNotation: Cartesian Production\n\n\n\n\\(R_1\\times R_2\\), where\n\n\\(R_1\\) and \\(R_2\\) are tables.\n\n\n\n\nThe result is a relation with\n\nevery combination of a tuple from \\(R1\\) concatenated to a tuple from \\(R_2\\)\nIts schema is every attribute from \\(R_1\\) followed by every attribute of \\(R_2\\), in order.\n\nThe number of tuples in \\(R_1\\times R_2\\) is given by \\(|R_1|\\times|R_2|\\), where \\(|R|\\) is the cardinality of \\(R\\).\nIf an attribute occurs in both relations, it occurs twice in the result, prefixed by relation name.\n\n\n\n\n\n\n\nTip 4\n\n\n\n\n\nIn the result of \\(\\texttt{Movie}\\times\\texttt{Roles}\\), we will see \\(\\text{Movies.mID}\\) and \\(\\text{Roles.mID}\\).\n\n\n\n\nHowever, Cartesian product can be inconvenient\n\nIt can introduce nonsense tuples.\nHowever, we can get rid of them with select operators.\n\nDue to this inconvenience, we need join operators.\n\n\n\nNatural Join\n\n\n\n\n\n\nNotation: Natural Join\n\n\n\n\\(R\\bowtie S\\), where\n\n\\(R\\) and \\(S\\) are tables\n\\(\\bowtie\\) is the natural join operator.\n\n\n\n\nThe result is formed by\n\ntaking the Cartesian product,\nselect to ensure equality on attributes that are in both relations (determine by name),\nprojecting to remove duplicate attributes.\n\n\n\n\n\n\n\n\nWarning 1: Properties of Natural Join\n\n\n\n\nCommutativity (although attribute orders may vary): \\[R\\bowtie S=S\\bowtie R\\]\nAssociativity: \\[R\\bowtie(S\\bowtie T)=(R\\bowtie S)\\bowtie T\\]\nWhen writing \\(n\\)-ary joins, brackets are irrelevant. We can just write: \\[R_1\\bowtie R_2\\bowtie\\cdots\\bowtie R_n.\\]\n\n\n\n\nSpecial cases of Natural Join\n\nIf there is not tuple match, natural join will result in the empty set \\(\\emptyset\\).\nNatural join is looking for exact match.\nIf there is no attributes in common, the result will be the Cartesian product of the two relations.\n\nNatural join can over-match\n\nNatural join bases the matching on attribute names.\nWhat if two attributes have the same name, but we don’t want them to have to match?\n\nNatural join can under-match\n\n\nWhat if two attributes don’t have the same name and we do want them to match?\n\n\n\n\n\nTheta Join\n\n\n\n\n\n\nDefinition: Theta Join \\({\\Large\\bowtie}_{\\text{condition}}\\)\n\n\n\n\nRationale: it is easier to check conditions after making the Cartesian production: \\({\\Large\\sigma}_{\\text{condition}}(R\\times S)\\)\nSyntax: \\(R\\ {\\Large\\bowtie}_{\\text{condition}}\\ S\\)\nThe result is the same as Cartesian product (not natural join!) followed by select: \\[R\\ {\\Large\\bowtie}_{\\text{condition}}\\ S={\\Large\\sigma}_{\\text{condition}}(R\\times S)\\]\n\n\n\n\n\nOuter Join\n\nOuter Join keeps all the tuples and adds null values whenever no value exists\nThree variants:\n\nLeft Outer Join: only do this “null padding” for left operand: ⟕\nRight Outer Join: only do this “null padding” for right operand: ⟖\nFull Outer Join: pad other operands: ⟗\n\n\n\n\nCardinality of Some Operators\n\nGiven \\(R_1(X_1)\\) and \\(R_2(X_2)\\), the cardinality (number of tuples) of\n\nCartesian product: \\(|R_1\\times R_2|=|R_1|\\times|R_2|\\)\nNatural join: \\(0\\leq|R_1\\Join R_2|\\leq|R_1|\\times|R_2|\\)\n\nNotice that if the attributes used in a natural join (i.e., the attributes in \\(X_1\\cap X_2\\)) contain a key of \\(R_2\\), then \\[0\\leq|R_1\\Join R_2|\\leq|R_1|\\]\n\nSame applies for left/right outer joins, if and only if the “outer” part is pointint to the table with the non-key attribute."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#composing-larger-expressions",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#composing-larger-expressions",
    "title": "2 Relational Algebra",
    "section": "Composing Larger Expressions",
    "text": "Composing Larger Expressions\n\nAssignment and Rename Operator\n\n\n\n\n\n\nNotation: Assignment\n\n\n\n\\(R\\coloneqq\\text{Expression}\\) or \\(R(A_1,\\dots,A_n)\\coloneqq\\text{Expression}\\)\n\nThe later notation lets us name all the attributes of the new relation\nSometimes, we don’t want the name they would get from Expression\n\\(R\\) must be a temporary variable, not one of the relations in the schema. That is, we are not updating the content of a relation.\n\n\n\n\n\n\n\n\n\nTip 5: Example: Using Assignment\n\n\n\n\n\n\\[\\begin{aligned}\\text{Temp }1&\\coloneqq Q\\times R\\\\\\text{Temp }2&\\coloneqq{\\Large\\sigma}_{a=99}(\\text{Temp }1)\\times S\\\\\\text{Answer}(\\text{part},\\text{price})&\\coloneqq{\\Large\\pi}_{b,c}(\\text{Temp }2)\\end{aligned}\\]\n\nThis is all for readability.\nAssignment helps us break a problem down.\nIt also allows us to change the names of relations (and attributes).\n\n\n\n\n\n\n\n\n\n\nNotation: Rename\n\n\n\n\\({\\Large\\rho}_{R_1}R_2\\) or \\({\\Large\\rho}_{R_1(A_1,\\dots,A_n)}(R_2)\\)\n\nThe later notation lets us rename all the attributes as well as the relation.\n\n\n\n\nEquivalent Notations: \\[R_1(A_1,\\dots,A_n)\\coloneqq R_2\\equiv R_1\\coloneqq{\\Large\\rho}_{R_1(A_1,\\dots,A_n)}(R_2)\\]\n\\(\\rho\\) is useful if we want to rename within an expression.\n\n\n\nSet Operations\n\nBecause relations are sets, we can use set intersection (\\(\\cap\\)), union (\\(\\cup\\)), and difference (\\(-\\)). But only if the operands are relations over the same attributes (in number, name, and order). Schema needs to be identical."
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#precedence-of-operators",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#precedence-of-operators",
    "title": "2 Relational Algebra",
    "section": "Precedence of Operators",
    "text": "Precedence of Operators\n\nExpressions can be composed recursively\nParentheses \\(()\\) and precedence rules define the order of evaluation\nPrecedence, from highest to lowest, is:\n\n\\(\\Large{\\sigma,\\ \\pi, \\rho}\\)\n\\(\\Large{\\times,\\ \\Join}\\)\n\\(\\Large{\\cap}\\)\n\\(\\Large{\\cup,\\ -}\\)"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#specific-types-of-query",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#specific-types-of-query",
    "title": "2 Relational Algebra",
    "section": "Specific Types of Query",
    "text": "Specific Types of Query\n\nMax\n\nThe function Max is not directly supported in relational algebra.\nIdea:\n\nPair tuples and find those that are not the max\nThen, subtract from all to find the maxes.\n\nProcedure: \\(S\\) to be the table and we want to find \\(\\max(\\text{GPA})\\)\n\nCreate the pair of tuples: \\({\\Large\\rho}_{S_1}(S)\\times{\\Large\\rho}_{S_2}(S)\\)\nFilter those GPA that is smaller than the other one in each pair: we will left will everything “smaller;” that is, \\(\\max{\\text{GPA}}\\) will not be present. \\[S_3(\\text{GPA})\\coloneqq{\\Large\\pi}_{S_1.\\text{GPA}}{\\Large\\sigma}_{(S_1.\\text{GPA}&lt;S_2.\\text{GPA})}({\\Large\\rho}_{S_1}(S)\\times{\\Large\\rho}_{S_2}(S))\\]\nThen, doing the subtraction, we will get the maximum: \\[\\max(\\text{GPA})={\\Large\\pi}_\\text{GPA}(S)-{\\Large\\pi}_\\text{GPA}(S_3)\\]\n\n\n\n\n\\(k\\) or more\n\nTo write a query about something like “students with two or more classes with grade &gt; 80” we:\n\nMake all combos of \\(k\\) different tuples that satisfy the condition.\n\n\n\n\n\n\n\n\nTip 6: Example: \\(k\\) or more\n\n\n\n\n\n\\[S\\coloneqq{\\Large\\rho_{R_1}}(R)\\times{\\Large\\rho_{R_2}}(R)\\] \\[R_3={\\Large\\sigma}_{(R_1.\\text{sID}=R_2.\\text{sID}\\land R_1.\\text{Class}\\neq R_2.\\text{Class})}(S)\\] \\[{\\Large\\pi}_{\\text{sID}}{\\Large\\sigma}_{(R_1.\\text{Grade}&gt;80\\land R_2.\\text{Grade}&gt;80)}(R_3)\\]\n\n\n\n\n\nExactly \\(k\\)\n\n“\\(k\\) or more” – “\\((k+1)\\) or more”"
  },
  {
    "objectID": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#integrity-constraints-via-ra",
    "href": "notes/cs377/02-relational-algebra/02 Relational Algebra.html#integrity-constraints-via-ra",
    "title": "2 Relational Algebra",
    "section": "Integrity Constraints via RA",
    "text": "Integrity Constraints via RA\n\nIn a schema description, we can express integrity constraints using a relational algebra expression\nWe use the notation\n\n\\(R=\\emptyset\\), or\n\\(R\\subseteq S\\)\n\n\n\n\n\n\n\n\nTip 7: Example: Integrity Constraints\n\n\n\n\n\n\nCourses at the 400-level cannot count for breadth. \\[{\\Large\\sigma}_(400\\leq\\text{cNum}\\leq500)\\land\\text{breadth}(\\text{Course})=\\emptyset\\]\nIn terms when CS 490 is offered, CS 454 must be offered. \\[\\text{CS490Terms}(\\text{term})\\coloneqq{\\Large\\pi}_\\text{term}({\\Large\\sigma}_{(\\text{dept}=\\text{'CS'}\\land\\text{cNum}=490)}(\\text{Offering}))\\]\\[\\text{CS454Terms}(\\text{term})\\coloneqq{\\Large\\pi}_\\text{term}({\\Large\\sigma}_{(\\text{dept}=\\text{'CS'}\\land\\text{cNum}=454)}(\\text{Offering}))\\] \\[\\text{CS490Terms}-\\text{CS454Terms}=\\emptyset\\]"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html",
    "title": "3 SQL Introduction",
    "section": "",
    "text": "RA is procedural\n\nAn RA query itself suggests a procedure for constructing the result (i.e., how one could implement the query).\nWe say that it is procedural\n\nHow good is a RA query?\n\nAny problem has multiple RA solution, and some may be more efficient.\nHowever, we don’t care much about efficiency.\n\nIn a DBMS, queries actually are executed, & efficiency matters!\n\nWhich query execution plan is most efficient depends on the data in the database and what indices you have.\nFortunately, the DBMS optimizes our queries.\nWe can focus on what we want, not how to get it"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#ra-review",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#ra-review",
    "title": "3 SQL Introduction",
    "section": "",
    "text": "RA is procedural\n\nAn RA query itself suggests a procedure for constructing the result (i.e., how one could implement the query).\nWe say that it is procedural\n\nHow good is a RA query?\n\nAny problem has multiple RA solution, and some may be more efficient.\nHowever, we don’t care much about efficiency.\n\nIn a DBMS, queries actually are executed, & efficiency matters!\n\nWhich query execution plan is most efficient depends on the data in the database and what indices you have.\nFortunately, the DBMS optimizes our queries.\nWe can focus on what we want, not how to get it"
  },
  {
    "objectID": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#sql-structured-query-language",
    "href": "notes/cs377/03-sql-introduction/03 SQL Introduction.html#sql-structured-query-language",
    "title": "3 SQL Introduction",
    "section": "SQL: Structured Query Language",
    "text": "SQL: Structured Query Language\n\nTwo sub-parts:\n\nDDL (Data Definition Language): defining schemas.\nDML (Data Manipulation Language): writing queries and modifying the database.\n\n\n\nBasic Queries\nSELECT attributes\nFROM Table\nWHERE &lt;condition&gt;;\n\n\n\n\n\n\nTip 1: Example: Link SQL and RA\n\n\n\n\n\nSELECT name\nFROM Course\nWHERE dept = 'CSC';\nEquiv. to \\({\\Large\\pi}_{\\text{name}}\\left({\\Large\\sigma}_{\\text{dept}=\\text{``csc''}}(\\text{Course})\\right)\\)\n\n\n\n\n\n\n\n\n\nTip 2: Example: , is the Cartesian Product\n\n\n\n\n\nSELECT name\nFROM Course, Offering, Took\nWHERE dept = 'CSC';\nEquiv. to \\({\\Large\\pi}_{\\text{name}}\\left({\\Large\\sigma}_{\\text{dept}=\\text{``csc''}}(\\text{Course}\\times\\text{Offering}\\times\\text{Took})\\right)\\)\n\n\n\n\n\n\n\n\n\nTip 3: Example: Renaming\n\n\n\n\n\nSELECT e.name, d.name\nFROM employee e, department d\nWHERE d.name = 'marketing' AND\n      e.name = 'Horton';\nThis is link \\(\\rho\\) in relational algebra.\nWhy do we need to rename? Can be convenient vs. the longer full names\nSELECT employee.name, department.name\nFROM employee, department\nWHERE department.name = 'marketing' AND\n      employee.name = 'Horton';\n\n\n\n\n\n\n\n\n\nTip 4: Example: Self-Joins\n\n\n\n\n\nNote: Renaming is required fro self joins\nSELECT e1.name, e2.name\nFROM employee e1, employee e2\nWHERE e1.salary &lt; e2.salary\n\n\n\n\n\nUse of *, AS, Conditions, and ORDER BY\n\nUsing * in SELECT clauses\n\nA * in the SELECT clause means “all attributes of this relation”\n\n\n\n\n\n\n\n\nTip 5: Example: Using *\n\n\n\n\n\nSELECT *\nFROM Course\nWHERE dept = 'CSC';\n\n\n\n\nRenaming attributes\n\nUse As &lt;new name&gt; to rename an attribute in the result\n\n\n\n\n\n\n\n\nTip 6: Example: Renaming Attributes\n\n\n\n\n\nSELECT name AS title, dept\nFROM Course\nWHERE breadth;\n\n\n\n\nComplex Conditions in a WHERE\n\nOperators:\n\nComparison operators: =, &lt;&gt; (aka !=), &gt;, &lt;, &gt;=, &lt;=\n\nCombine boolean expressions: AND, OR, NOT\n\n\n\n\n\n\n\n\nTip 7: Example: Conditions\n\n\n\n\n\nSELECT *\nFROM Offering\nWHERE dept = ‘CSC’ AND cnum &gt;= 300;\n\n\n\n\nOrder by\n\nTo put the tuples in order, ORDER BY &lt;attritbue list&gt; [DESC]\nThe default is ascending order; DESC overrides it to force descending order\nYou can order some attributes in ASC order, others in DESC:\nThe attribute list can include expressions, such as ORDER BY sales+rentals\n\n\n\n\n\n\n\n\nTip 8: Example: Multiple ordering\n\n\n\n\n\nSELECT * FROM Course\nORDER BY cnum ASC, dept DESC;\n\n\n\n\nCase-sensitivity and whitespace\n\nselect surName\nfrom Student\nwhere campus = 'StG';\n\nKeywords, like select, are not case-sensitive.\n\nOne convention is to use UPPERCASE for keywords\n\nIdentifiers, like Student are not case-sensitive.\n\none convention is to use lowercase for attributes, and a leading capital letter followed by lowercase for relations\n\nLiteral strings, like 'StG', are case sensitive, and require single quotes.\nWhitespaces (other than inside quotes) is ignored.\n\n\n\nMore on SELECT Clauses\n\nExpression in SELECT clauses\n\nInstead of a simple attribute name, you can use an expression in a SELECT clause.\nOperands: attributes, constants\nOperators: arithmetic ops, string ops\n\n\n\n\n\n\n\n\nTip 9: Example: Expressions in SELECT Clauses\n\n\n\n\n\nNote: || means string concatenation\nSELECT sid, grade-10 as adjusted\nFROM Took;\nSELECT dept| |cnum as fullCourseName\nFROM course;\n\n\n\n\nExpressions that are a constant\n\nSometimes it makes sense for the whole expression to be a constant (something that doesn’t involve any attributes!).\n\n\n\n\n\n\n\n\nTip 10: Example: Constant Expressions\n\n\n\n\n\nSELECT name, \n       ‘satisfies’ AS breadthRequirement\nFROM Course\nWHERE breadth;\n\n\n\n\n\nPattern Operations\n\nTwo ways to compare a string to a pattern by\n\n&lt;attribute&gt; LIKE &lt;pattern&gt;\n&lt;attribute&gt; NOT LIKE &lt;pattern&gt;\n\nPattern is a quoted string\n\n% means: any string (0 or more)\n_ means: any single character\n\n\nSELECT *\nFROM Course\nWHERE name LIKE = '%Comp%';\n\nMore examples:\n\n... WHERE phone LIKE '268_ _ _ _ _ _'\n\nphone numbers with area code 268\n\n... WHERE Dictionary.entry NOT LIKE '%est'\n\nIgnore ‘biggest’, ‘tallest’, ‘fastest’, ‘rest’, … (i.e., ignore any strings ends with ‘est’)\nNote: ‘est’ itself is also ignored.\n\n... WHERE sales LIKE '%30!%%' ESCAPE '!'\n\nSales of 30%\nNote: PostgreSQL allows you to define your own ESCAPE\nThe thing after the ESCAPE character should be treated as a normal string (not a special character)."
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html",
    "title": "4 SQL Aggregation",
    "section": "",
    "text": "Computing on a column\n\nWe often want to compute something across the values in a column\nSUM, AVG, MIN, and MAX\nWe can also count the number of tuples (rows) by using COUNT(*)\n\n\nSELECT *\nFROM Took;\n\nSELECT grade\nFROM Took;\n\nSELECT AVG(grade)\nFROM Took;\n\nSELECT AVG(grade) AS myAVG /* It is recommend to always rename */\nFROM Took;\n\n/* One can combine multiple aggregations */\nSELECT MAX(grade), AVG(grade), COUNT(*), MIN(sID)\nFROM Took;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#aggregation",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#aggregation",
    "title": "4 SQL Aggregation",
    "section": "",
    "text": "Computing on a column\n\nWe often want to compute something across the values in a column\nSUM, AVG, MIN, and MAX\nWe can also count the number of tuples (rows) by using COUNT(*)\n\n\nSELECT *\nFROM Took;\n\nSELECT grade\nFROM Took;\n\nSELECT AVG(grade)\nFROM Took;\n\nSELECT AVG(grade) AS myAVG /* It is recommend to always rename */\nFROM Took;\n\n/* One can combine multiple aggregations */\nSELECT MAX(grade), AVG(grade), COUNT(*), MIN(sID)\nFROM Took;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#group-by",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#group-by",
    "title": "4 SQL Aggregation",
    "section": "GROUP BY",
    "text": "GROUP BY\n\nIf we follow a SELECT-FROM-WHERE expression with GROUP BY &lt;attributes&gt;\n\nThe rows are grouped together according to the values of those attributes, and\nany aggregations is applied only within each group\n\n\nSELECT oID, AVG(grade) AS offAvg\nFROM Took\nGROUP BY oID;\n\nNote: SELECT cannot include un-aggregated columns\n\n/* The following will produce an error */\nSELECT oID, AVG(grade) AS offAvg, sID\nFROM Took\nGROUP BY oID;\n\nRestrictions on Aggregation:\n\nIf any aggregation is used, then each element of the SELECT list must be either\n\naggregated, or\nan attribute on the GROUP BY list."
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#having",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#having",
    "title": "4 SQL Aggregation",
    "section": "HAVING",
    "text": "HAVING\n\nSometimes, we want to keep some groups and eliminate others from our result set.\nWHERE let us decide which tuples to keep - performed before the grouping\nHAVING decides which groups to keep - performed after the grouping\n\n...\nGROUP BY &lt;attributes&gt;\nHAVING &lt;condition&gt;\n\nOnly groups satisfying the condition are kept.\nRequirements on HAVING clauses:\n\nOutside subqueries, HAVING may refer to attributes only if they are either:\n\naggregated, or\nan attribute on the GROUP BY list\n\nThis requirement is the same as SELECT clause.\n\n\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nGROUP BY oID\nHAVING AVG(grade) &gt; 80; \n/* Cannot use offAvg here. HAVING is executed before SELECT*/\n\n/* The following two queries are WRONG / produce undesired results */\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nGROUP BY oID\nWHERE AVG(grade) &gt; 80; /* Incorrect! */\n\nSELECT oID, AVG(grade) as offAvg\nFROM Took\nWHERE AVG(grade) &gt; 80 /* Incorrect! */\nGROUP BY oID;\n\n/* Another HAVING example */\nSELECT oID, avg(grade) as offAvg\nGROUP BY oID\nHAVING oID &lt;= 5\nORDER BY oID;"
  },
  {
    "objectID": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#order-of-execution-of-a-sql-query",
    "href": "notes/cs377/04-sql-aggregation/04 SQL Aggregation.html#order-of-execution-of-a-sql-query",
    "title": "4 SQL Aggregation",
    "section": "Order of Execution of a SQL Query",
    "text": "Order of Execution of a SQL Query\n\n\n\nQuery Order\nExecution Order\n\n\n\n\nSELECT\nFROM\n\n\nFROM\nWHERE\n\n\nWHERE\nGROUP BY\n\n\nGROUP BY\nHAVING\n\n\nHAVING\nSELECT\n\n\nORDER BY\nORDER BY\n\n\n\n\nHowever, note that we can order by a column even if it is not selected.\n\n/* The following query is legal. */\nSELECT sID\nFROM Took\nGROUP BY sID\nHAVING AVG(grade) &gt; 80\nORDER BY AVG(grade)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#duplicates-in-sql",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#duplicates-in-sql",
    "title": "5 SQL Set Operations",
    "section": "",
    "text": "A table can have duplicate tuples, unless this would violate an integrity constraint.\nAnd SELECT-FROM-WHERE (SFW) statements leave duplicates in, unless you say not to!\nWhy?\n\nGetting rid of duplicates is expensive!\nWe may want the duplicates because they tell us how many times something occurred.\n\n\n\n\n\nSQL treats tables as “bags” (or “multisets”) rather than sets.\nBags are just like sets, but duplicates are allowed.\n\n\n\n\n\n\n\nTip 1: Example: Bag Semantics\n\n\n\n\n\n\n\\(\\{6, 2, 7, 1, 9\\}\\) is a set and a bag\n\\(\\{6, 2, 7, 1, 9, 1\\}\\) is not a set but a bag\n\n\n\n\n\nLet sets, order doesn’t matter: \\(\\{6, 2, 7, 1, 9, 1\\}=\\{1, 1, 2, 6, 7, 9\\}\\)\nOperations \\(\\cap\\), \\(\\cup\\), and \\(-\\) with bags:\n\nFor \\(\\cap\\), \\(\\cup\\), and \\(-\\) the number of occurrences of a tuple in the result requires some thought.\nSuppose tuple \\(t\\) occurs:\n\n\\(m\\) times in relation \\(R\\), and\n\\(n\\) times in relation \\(S\\)\n\n\n\n\n\n\nOperation\nNumber of Occurrences of \\(t\\) in tuples\n\n\n\n\n\\(R\\cap S\\)\n\\(\\min(m,n)\\)\n\n\n\\(R\\cup S\\)\n\\(m+n\\)\n\n\n\\(R-S\\)\n\\(\\max(m-n,0)\\)\n\n\n\n\n\\(\\cap\\), \\(\\cup\\), and \\(-\\) in SQL:\n\n(&lt;subquery&gt;) UNION (&lt;subquery&gt;)\n(&lt;subquery&gt;) INTERSECT (&lt;subquery&gt;)\n(&lt;subquery&gt;) EXCEPT (&lt;subquery&gt;)\n\nThe parentheses () are mandatory\nThe operands must be queries; you can’t simply use a relation name.\n\n\n\n\n\n\n\nTip 2: Example: Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\nBag vs. Set Semantics: which is used and when\n\nA SELECT-FROM-WHERE statement uses bag semantics by default.\n\nDuplicates are kept in the result\n\nThe set (INTERSECT/UNION/EXCEPT) operations use set semantics by default\n\nDuplicates are eliminated from the result\n\n\nMotivation: Efficiency\n\nWhen doing projection, it is easier not to eliminate duplicate\n\nJust work one tuple at a time\n\nFor intersection or difference, it is most efficient to sort the relations first.\n\nAt that point you may was well eliminate the duplicates anyway\n\n\nHowever, we can control which semantic is used.\n\nWe can force the result of a SFW query to be a set by using SELECT DISTINCT\nWe can force the result of a set operation to be a bag by using ALL.\n\n\n\n\n\n\n\n\nTip 3: Example: Force to Use Set Operations in SQL\n\n\n\n\n\n(SELECT sid\n FROM Took\n WHERE grade &gt; 95)\n    UNION ALL\n(SELECT sid\n FROM Took\n WHERE grade &lt; 50);\n\n\n\n\n\n\n\n\n\nTip 4: Example: Comparison of Set and Bag Semantics\n\n\n\n\n\n\nA single occurrence of a value for x in B wipes out all occurrences of it from A:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)\n\nWith EXCEPT ALL, we match up the value one by one:\n\n(SELECT x FROM A) EXCEPT (SELECT x FROM B)"
  },
  {
    "objectID": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#views",
    "href": "notes/cs377/05-sql-set-operations/05 SQL Set Operations.html#views",
    "title": "5 SQL Set Operations",
    "section": "Views",
    "text": "Views\n\nThe idea\n\nA view is a relation defined in terms of stored tables (called base tables) and possibly also other views.\nAccess a view like any base table.\nTwo kinds of view:\n\nVirtual: no tuples are stored; view is just a query for constructing the relation when needed.\nMaterialized: actually constructed and stored. Expensive to maintain.\n\nViews are particularly important when you want to give different access rights (i.e. permissions) to different users viewing data in your tables!\n\n\n\n\n\n\n\nTip 5: Example: Application of Views\n\n\n\n\n\nCanvas student page vs. instructor page\n\n\n\n\n\n\n\n\n\nTip 6: Example: Creating a View\n\n\n\n\n\n\nA view for students who earned an 80 or higher in a CSC course:\n\nCREATE VIEW topresults AS\n    SELECT firstname, surname, cnum\n    FROM Student, Took, Offering\n    WHERE\n        Student.sid = Took.sid AND\n        Took.oid = Offering.oid AND\n        grade &gt;= 80 AND dept = 'CSC';\n\n\n\n\n\nUses of Views\n\nBreak down a large query\nProvide another way of looking at the same data, e.g. for one category of user\nWrap commonly used complex queries"
  },
  {
    "objectID": "notes/cs377/06-sql-join/06 SQL Join.html",
    "href": "notes/cs377/06-sql-join/06 SQL Join.html",
    "title": "6 SQL Join",
    "section": "",
    "text": "Expression within SQL\nMeaning in RA\n\n\n\n\nR, S\n\\[R\\times S\\]\n\n\nR CROSS JOIN S\n\\[R\\times S\\]\n\n\nR NATURAL JOIN S\n\\[R\\bowtie S\\]\n\n\nR JOIN S ON &lt;condition&gt;\n\\[R\\bowtie_\\texttt{condition} S\\]\n\n\nR NATURAL LEFT [OUTER] JOIN S\n\\[R⟕S\\]\n\n\nR NATURAL RIGHT [OUTER] JOIN S\n\\[R⟖S\\]\n\n\nR NATURAL FULL [OUTER] JOIN S\n\\[R⟗S\\]\n\n\nR LEFT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟕_\\texttt{condition}S\\]\n\n\nR RIGHT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟖_\\texttt{condition}S\\]\n\n\nR FULL [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟗_\\texttt{condition}S\\]\n\n\n\n\nIf your query includes left/right/full, adding OUTER is optional\nIf your outer join is not natural, then adding on &lt;condition&gt;becomes necessary\n\n\n\n\nAttributes with matching names don’t necessarily mean matching meanings!\nHaving implicit comparisons impairs readability.\nAlso: if the schema changed, a query that looks fine may actually be broken, without being able to tell.\nBest practice: Don’t over-use NUATURAL JOIN.\n\n\n\n\n\nWe get an OUTER join iff you use the keywords LEFT, RIGHT, or FULL.\nIf you don’t use the keywords LEFT, RIGHT, or FULL you get an INNER join."
  },
  {
    "objectID": "notes/cs377/06-sql-join/06 SQL Join.html#the-joins-we-know-from-ra",
    "href": "notes/cs377/06-sql-join/06 SQL Join.html#the-joins-we-know-from-ra",
    "title": "6 SQL Join",
    "section": "",
    "text": "Expression within SQL\nMeaning in RA\n\n\n\n\nR, S\n\\[R\\times S\\]\n\n\nR CROSS JOIN S\n\\[R\\times S\\]\n\n\nR NATURAL JOIN S\n\\[R\\bowtie S\\]\n\n\nR JOIN S ON &lt;condition&gt;\n\\[R\\bowtie_\\texttt{condition} S\\]\n\n\nR NATURAL LEFT [OUTER] JOIN S\n\\[R⟕S\\]\n\n\nR NATURAL RIGHT [OUTER] JOIN S\n\\[R⟖S\\]\n\n\nR NATURAL FULL [OUTER] JOIN S\n\\[R⟗S\\]\n\n\nR LEFT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟕_\\texttt{condition}S\\]\n\n\nR RIGHT [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟖_\\texttt{condition}S\\]\n\n\nR FULL [OUTER] JOIN S ON &lt;condition&gt;\n\\[R⟗_\\texttt{condition}S\\]\n\n\n\n\nIf your query includes left/right/full, adding OUTER is optional\nIf your outer join is not natural, then adding on &lt;condition&gt;becomes necessary\n\n\n\n\nAttributes with matching names don’t necessarily mean matching meanings!\nHaving implicit comparisons impairs readability.\nAlso: if the schema changed, a query that looks fine may actually be broken, without being able to tell.\nBest practice: Don’t over-use NUATURAL JOIN.\n\n\n\n\n\nWe get an OUTER join iff you use the keywords LEFT, RIGHT, or FULL.\nIf you don’t use the keywords LEFT, RIGHT, or FULL you get an INNER join."
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#intro-to-algorithm-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "",
    "text": "We want to know how can we measure the “goodness” of a program/algorithm?\nWe have some ways to measure:\n\nRunning time (the shorter, the better)\nMemory utilization (the less the better)\nAmount of code (?)\nEtc.\n\nThe most commonly used performance measure is the running time.\nTo measure running time, we can use a stop watch (i.e., use real time as measure). However, there are some problems associated:\n\nThe same program can have different running time on different computers\nDifferent inputs can result in different running time - hard to find their relationship\n\nSo, we need to rely on an more objective measure: count the number of instructions executed by a program for a given input size.\nHowever, this measure is not practical. In practice, we will count the number of “primitive operations” executed by a program for a given input size.\nAlgorithms make repeated steps towards the solution. The primitive operation is a step in the algorithm.\n\nfor (int i = 0; i &lt; N; i++) {\n    S1;\n    S2;\n    ...\n    SN\n}\nThe primitive operation of this algorithm consists of the statementS1; S2; ...; SN.\n\nPrinciples of Algorithm Analysis\n\nAlgorithm analysis consists of\n\nDetermine frequency (=count) of primitive operations\nCharacterize the frequency as a function of the input size\n\nThe algorithm analysis must\n\nTake into account all possible inputs (good ones and bad ones)\nBe independent of hardware/software environment\nBe independent from the programming language\nGive a good estimate that is proportional to the actual running time of the algorihtm\n\n\nGood inputs, Bad inputs, and Average cases\n\nInput data can affect the running time of algorithms\nThe best case are not studied because we cannot count on luck.\nThe worst case gives us an upper bound\n\nThe worst case analysis provides an upper bound on the running time of an algorithm.\nThe analysis is easier to do compare to average case analysis.\n\nThe average case is what we would expect.\n\nTake the average running time over all possible inputs of the same size\nThe analysis depends on input distribution\nThe analysis is harder to do because it uses probability techniques.\n\n\nTechniques used in Algorithm Analysis\n\nThere are two main techniques used in Algorithm Analysis:\n\nLoop analysis\nRecurrence relations\n\nA program spends the most amount of time in loops. One of the technique used in algorithm analysis is loop analysis.\nSome algorithms are recursive. The running time complexity of recursive algorithms are often expressions as recurrence relations. Another technique is solving recurrence relations\n\n\n\n\n\n\n\n\nTip 1: Recurrence Relation\n\n\n\n\n\n\\[ C(n)=2\\times C(n/2)+1 \\]\n\n\n\n\n\n\nConsider the following program fragment, how many times is the loop body executed?\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 2: Solution 1\n\n\n\n\n\n\\[n\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i = i + 2) {\n    sum += array[i];\n}\n\n\n\n\n\n\nTip 3: Solution 2\n\n\n\n\n\n\\[\\dfrac{n}{2}\\]\n\n\n\ndouble sum = 0\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; ++) { \n        sum += array[i] * array[j]; \n    }\n}\n\n\n\n\n\n\nTip 4: Solution 3\n\n\n\n\n\n\\[n\\times n=n^2\\]\n\n\n\n\nThe running time in terms of the input size (\\(n\\)) can be a general mathematical function. However, we are interested in the order of the growth function (but not the exact function).\n\n\n\n\n\n\n\nNote 1: Approximate Definition of Order, Similar/\\(\\sim\\)\n\n\n\nGiven 2 functions \\(f(x)\\) and \\(g(x)\\), we say \\(f(x)\\sim g(x)\\) if \\(\\dfrac{f(x)}{g(x)}=1\\) when \\(n\\to\\infty\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn running time analysis, we can ignore the less significant terms.\n\n\n\n\n\n\n\n\nNote 2: Precise Definition of Order, \\(\\mathcal{O}\\) notation\n\n\n\nGiven two functions \\(f(n)\\) and \\(g(n)\\). The function \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\) (order of \\(g(n)\\)) if \\(\\exists\\ c,n_0\\textit{ s.t. }f(n)\\leq cg(n)\\forall n\\geq n_0\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA function \\(f(n)\\) is Big-Oh of \\(g(n)\\) if \\(f(n)\\leq cg(n)\\) for large values of \\(n\\). That is, \\(f(n)\\) is dominant by some multiple of \\(g(n)\\) when \\(n\\) is large.\n\n\n\n\n\n\n\n\nTip 5: Examples of Big-Oh Notation\n\n\n\n\n\n\\(f(n)=2n+10\\) is \\(\\mathcal{O}(n)\\).\nProof. For \\(n&gt;10\\), we have \\(2n+10&lt;3n\\). Therefore, we found \\(c=3\\) and \\(n_0=10\\) for which \\(f(n)\\leq cg(n)\\) when \\(n\\geq n_0\\).\n\n\\(\\quad\\text{Q.E.D.}\\ \\blacksquare\\)\n\n\nHowever, we know that \\(f(n)=n^2\\) is not \\(\\mathcal{O}(n)\\). Picking \\(n=c+1\\), the condition \\(n\\leq c\\) will never be satisfied.\n\n\n\n\n\nBig-Oh and Growth rate\n\nThe Big-Oh notation gives an upper bound on the growth rate of a function \\(f(n)\\) that represents the run time complexity of some algorithm\nIf \\(f(n)\\) is \\(\\mathcal{O}(g(n))\\), then the growth rate of \\(f(n)\\) is no more than the growth rate of \\(g(n)\\).\nIn algorithm analysis, we use \\(\\mathcal{O}(g(n))\\) to rank (=categorize) functions by their growth rate.\n\n\n\n\n\n\n\n\nTip 6: Examples of Growth Rate\n\n\n\n\n\n\\(2n+4\\), \\(7n+9\\), \\(10000n+999\\) are all \\(\\mathcal{O}(n)\\), so in algorithm analysis we consider all these functions grow at the same rate.\n\n\n\n\nCommon Running Times:\n\n\n\nRunning Time\nName\n\n\n\n\n\\(\\mathcal{O}(1)\\)\nConstant Time\n\n\n\\(\\mathcal{O}(\\log(n))\\)\nLogarithmic\n\n\n\\(\\mathcal{O}(n)\\)\nLinear\n\n\n\\(\\mathcal{O}(n\\log(n))\\)\nLog Linear\n\n\n\\(\\mathcal{O}(n^2)\\)\nQuadratic\n\n\n\n\n\n\n\n\nTriangular Sums: \\[1+2+3+4+\\cdots+N=\\dfrac{N(N+1)}{2}\\approx\\dfrac{N^2}{2}.\\]\nGeometric Sums: \\[1+2+4+8+\\cdots+N(=2^n)=2N-1\\approx 2N\\] \\[1+\\dfrac{1}{2}+\\dfrac{1}{4}+\\cdots+\\dfrac{1}{N}(=\\dfrac{1}{2^n})=2-\\dfrac{1}{N}\\approx2\\]\nHarmonic Sum: \\[1+\\dfrac{1}{2}+\\dfrac{1}{3}+\\cdots+\\dfrac{1}{N}\\approx\\ln(N)\\]\nSterling’s Approximation: \\[\\log(1)+\\log(2)+\\log(3)+\\cdots+\\log(N)=\\log(N!)\\approx N\\log(N)\\]"
  },
  {
    "objectID": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "href": "notes/cs171/12-Complexity-Analysis/Complexity Analysis.html#loop-analysis",
    "title": "Lecture 11 Complexity Analysis",
    "section": "Loop Analysis",
    "text": "Loop Analysis\n\n\n\n\n\n\nTip 7: Example: Loop Analysis 1\n\n\n\n\n\nfor (int i = 0; i &lt; 10; i++) {\n    doPrimitive();\n}\n\nThe loop is executed \\(10\\) times for any input size.\nRunning time \\(=10\\) operations.\nRun time complexity \\(=\\mathcal{O}(1)\\implies\\) constant time.\n\n\n\n\n\n\n\n\n\n\nTip 8: Example: Loop Analysis 2\n\n\n\n\n\nn = input size;  // (e.g.: # elements in an array)\nfor (int i = 0; i &lt; n; i++) {\n    doPrimitive();\n}\n\nThe loop is executed \\(n\\) times for an input size of \\(n\\).\nRunning time \\(=n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nNotation Remark\n\n\n\n\\(n\\) or \\(N\\) will always denote the input size in algorithm analysis.\n\n\n\n\n\n\n\n\nTip 9: Example: Loop Analysis 3\n\n\n\n\n\nint sum = 0;\nfor (int i = 0; i &lt; 5*n; i = i + 4) {\n    sum = sum + 1;\n}\n\nThe loop is executed \\(\\frac{5}{4}n\\) times for an input size of \\(n\\).\nRunning time \\(=\\frac{5}{4}n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nTip 10: Example: Loop Analysis 4\n\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt; 0; i = i - 4) {\n    sum = sum + 1;\n}\n\nThe loop is executed \\(\\frac{1}{4}n\\) times for an input size of \\(n\\).\nRunning time \\(=\\frac{1}{4}n\\) operations.\nRun time complexity \\(=\\mathcal{O}(n)\\implies\\) linear\n\n\n\n\n\n\n\n\n\n\nTip 11: Example: Loop Analysis 5\n\n\n\n\n\nint sum = 0;\nfor (int i = 1; i &lt;= n; i = 2*i) {\n    sum++;\n}\n\n\\(i\\) will take the following numbers in the loop \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\]\nLoop will exists when \\(i&gt;n\\): \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\quad n\\]\nSuppose \\(2^{k-1}\\leq n\\leq 2^k\\) \\[1\\quad2\\quad4\\quad8\\quad16\\quad32\\quad\\cdots\\quad2^{k-1}\\quad n\\quad2^{k}\\]\nIterations: \\(k\\approx\\log{n}\\). So, \\(\\mathcal{O}(\\log{n})\\). (\\(n\\approx2^{k}\\Longleftrightarrow k\\approx\\log(n)\\))\n\n\n\n\n\n\n\n\n\n\nTip 12: Example: Loop Analysis 6\n\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt;= 1; i = i/2) {\n    sum++;\n}\n\n\\(i\\) will take the following numbers in the loop \\[n\\quad n/2\\quad n/4\\quad\\cdots\\quad1\\]\nLoop will exists when \\(i&lt;1\\).\nSuppose \\(n/2^{k}&lt;1&lt;n/2^{k-1}\\). \\[n\\quad n/2\\quad n/4\\quad\\cdots\\quad n/2^{k-1}\\quad1\\quad n/2^{k}\\]\nIterations \\(k\\approx\\log{n}\\). So, \\(\\mathcal{O}(\\log{n})\\) (\\(n/2^k\\approx1\\implies n\\approx2^k\\implies k\\approx\\log{n}\\))\n\n\n\n\n\n\n\n\n\n\nTip 13: Example: Loop Analysis 7\n\n\n\n\n\nint sum = 0;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt;= i; j++) {\n        sum++;\n    }\n}\n\n\n\n\\(i\\)\n0\n2\n3\n4\n\\(\\cdots\\)\n\\(n-1\\)\n\n\n\n\n\\(j\\)\n*\n*\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n*\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n*\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n\n*\n\\(\\cdots\\)\n*\n\n\n\n\n\n\n\n\\(\\vdots\\)\n*\n\n\n\n\n\n\n\n\n*\n\n\n\n\nWe sum up those starts. That is adding from \\(1\\) to \\(n\\).\nIterations \\(=\\dfrac{n(n+1)}{2}\\). So, \\(\\mathcal{O}(n^2)\\).\n\n\n\n\nint sum = 0;\nfor (int i = n; i &gt; 0; i = i/2) {\n    for (int j = 0; j &lt; i; j++) {\n        sum++;\n    }\n}\n\\end{document}"
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html",
    "href": "notes/cs377/10-JDBC/10 JDBC.html",
    "title": "10 JDBC",
    "section": "",
    "text": "Load the driver and register it with the driver manager (download the driver .jar file)\nConnect toe database\nCreate a statement object\nExecute a query and retrieve the results, or make changes to the database\nDisconnect from the database\n\nimport java.sql.*; // API for accessing and processing DB datqa\n\npublic class JDBCTest {\n  public static void main(String args[]) {\n    try {\n      // Load the driver\n      Class.forName(\"org.postgresql.Driver\");\n      // Connect to the database\n      Connection conn = DriverManager.getConnection(\"jdbc:postgresql://localhost:5433/\", \"postgres\", \"postgres\")\n      \n      // Create a statement object\n      Statement stmt = conn.createStatement();\n\n      // Execute a query and retrieve the results\n      ResultSet rs = stmt.executeQuery(\"SELECT * FROM mytable\");\n\n      // Process the results\n      while ( rs.next() ) {\n        System.out.println(rs.getString(\"name\"));\n      }\n      rs.close();\n\n      // Disconnect from the database\n      stmt.close();\n      conn.close();\n    }\n    // Handle exceptions\n    catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n\nArguments to getConnection:\n\njdbc:postgresql: indicates the driver to use PostgreSQL\nlocalhost:5433/:\n\nHost address: port number\nUse localhost to indicate that we are running the Java application on same server as the database\n\nusername\npassword\nWe can also specify the schema we want to connect:\n\nurl = jdbc:postgresql://localhost:5433/postgres?currentSchema=mySchema\nAlternatively, we can use conn.setSchema(\"mySchema\").\n\n\nResultSet:\n\nrs.next(): moves the cursor to the next row\nrs.getString(\"name\"): retrieves the value of the column name in the current row\n\nIf the tuple also contains other data types, we can use rs.getInt(\"age\"), rs.getDouble(\"salary\"), etc.\n\nrs.close(): closes the result set\n\nExceptions can occur when:\n\nThe driver is not found\nThe connection fails\nThe query fails\nThe result set is not closed"
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#jdbc-steps",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#jdbc-steps",
    "title": "10 JDBC",
    "section": "",
    "text": "Load the driver and register it with the driver manager (download the driver .jar file)\nConnect toe database\nCreate a statement object\nExecute a query and retrieve the results, or make changes to the database\nDisconnect from the database\n\nimport java.sql.*; // API for accessing and processing DB datqa\n\npublic class JDBCTest {\n  public static void main(String args[]) {\n    try {\n      // Load the driver\n      Class.forName(\"org.postgresql.Driver\");\n      // Connect to the database\n      Connection conn = DriverManager.getConnection(\"jdbc:postgresql://localhost:5433/\", \"postgres\", \"postgres\")\n      \n      // Create a statement object\n      Statement stmt = conn.createStatement();\n\n      // Execute a query and retrieve the results\n      ResultSet rs = stmt.executeQuery(\"SELECT * FROM mytable\");\n\n      // Process the results\n      while ( rs.next() ) {\n        System.out.println(rs.getString(\"name\"));\n      }\n      rs.close();\n\n      // Disconnect from the database\n      stmt.close();\n      conn.close();\n    }\n    // Handle exceptions\n    catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n\nArguments to getConnection:\n\njdbc:postgresql: indicates the driver to use PostgreSQL\nlocalhost:5433/:\n\nHost address: port number\nUse localhost to indicate that we are running the Java application on same server as the database\n\nusername\npassword\nWe can also specify the schema we want to connect:\n\nurl = jdbc:postgresql://localhost:5433/postgres?currentSchema=mySchema\nAlternatively, we can use conn.setSchema(\"mySchema\").\n\n\nResultSet:\n\nrs.next(): moves the cursor to the next row\nrs.getString(\"name\"): retrieves the value of the column name in the current row\n\nIf the tuple also contains other data types, we can use rs.getInt(\"age\"), rs.getDouble(\"salary\"), etc.\n\nrs.close(): closes the result set\n\nExceptions can occur when:\n\nThe driver is not found\nThe connection fails\nThe query fails\nThe result set is not closed"
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#prepared-statements",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#prepared-statements",
    "title": "10 JDBC",
    "section": "Prepared Statements",
    "text": "Prepared Statements\n\nPreparing a statement includes parsing the SQL, compiling and optimizing it.\nThe resulting PreparedStatement object can be executed any number of times wihtout having to repeat these steps.\n\nJava Documentation\n\nIf the query isn’t know until run time:\n\nYou may need input and computation to determine the query.\nYou can hard-code the parts you know, and use ? as a placeholder for the values you don’t know.\nThis is enough to allow a PreparedStatement to be constructed.\nOnece you know values fro the placeholders, methods setInt, setString, etc. can be used to set the values.\n\n\n\n\n\n\n\n\nTip 1: Example of Using Placeholders\n\n\n\n\n\n  PreparedStatement studioStat = \n    conn.preparedStatement(\n      \"INSERT INTO STUDIO(name, address)\n      VALUES(?, ?)\"\n    );\n  \n  /* OMITTED: Get values for studioName and StudioAddr*/\n  studioStat.setString(1, studioName);\n  studioStat.setString(2, studioAddr);\n  studioStat.executeUpdate();\n\n\n\n\n\n\n\n\n\nWarning 1: Why not just build the query in a string?\n\n\n\n\nWe constructed an incomplete preparedStatement and filled in the missing values using method calls.\nInstead, we could just build up the query in an ordinary string at run time, and ask to execute that.\nThere are classes and methods that will do this in JDBC.\nBut never use that approach because it is vulnerable to injections: insertion of strings into a query with malicious intent.\nAlways use a preparedStatement instead!\n\n\n\n\nAdvantages of a prepared statement\n\nPreformance: it is pre-complied. DB server prepares an execution plane once and caches it (before execution).\nSecurity: it is a good way to protect against SQL injection.\n\n\n\n\n\n\n\n\nTip 2: Example with createStatement\n\n\n\n\n\n  Statement stat = conn.createStatement();\n  String query = \n    \"SELECT networth\n    FROM MovieExec\n    WHERE execName LIKE '%Spielberg%'\n    \";\n  ResultSet worth = stat.executeQuery(query);\n\n\n\n\n\n\n\n\n\nTip 3: Example of SQL Injection\n\n\n\n\n\n\nSuppose we want the user to provide the string to compare to.\nWe did this by allowing user input to be concatenated into the query string.\n\n  Statement stat = conn.createStatement();\n  String who = /* User input */\n  String query = \n    \"SELECT networth\n    FROM MovieExec\n    WHERE execName LIKE '%\" + who + \"%'\n    \";\n\n  ResultSet worths = stat.executeQuery(query);\n\nA gentle user does not harm might enter Cameron, making the query:\n\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Cameron%'\n\nNothing bad happens.\nHowever, an injection can exploit the vulnerability: if the user enters Milch%'; DROP TABLE Contracts; --, the query becomes:\n\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Milch%'; DROP TABLE Contracts; --%'\n\n-- Equivalent to:\nSELECT networth\nFROM MovieExec\nWHERE execName LIKE '%Milch%';\n\nDROP TABLE Contracts; --%';\n\nAll the contracts table will be dropped.\nThis is a SQL Injection.\n\n\n\n\n\nQueries vs. updates in JDBC\nexecuteQuery is used for queries that return a result set.The previous examples used executeQuery.\nThis method is only for pure queries.\nFor SQL statements that change the database (insert, delete, or modify tuples, or change the schema), use the analogous executeUpdate method."
  },
  {
    "objectID": "notes/cs377/10-JDBC/10 JDBC.html#example-of-using-placeholders",
    "href": "notes/cs377/10-JDBC/10 JDBC.html#example-of-using-placeholders",
    "title": "10 JDBC",
    "section": "Example of Using Placeholders",
    "text": "Example of Using Placeholders\n  PreparedStatement studioStat = \n    conn.preparedStatement(\n      \"INSERT INTO STUDIO(name, address)\n      VALUES(?, ?)\"\n    );\n  \n  /* OMITTED: Get values for studioName and StudioAddr*/\n  studioStat.setString(1, studioName);\n  studioStat.setString(2, studioAddr);\n  studioStat.executeUpdate();"
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html",
    "href": "notes/cs377/11-er-design/11 ER Design.html",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-er-design",
    "href": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-er-design",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-database-design",
    "href": "notes/cs377/11-er-design/11 ER Design.html#introduction-to-database-design",
    "title": "11 ER Design",
    "section": "",
    "text": "Conceptualizing the real-world\n\nDB design begins with a boss or client who wants a database :)\nWe must map the entities and relationships in the real world to the concepts of a database. This is called modeling.\nSketching the key components is an efficient way to develop a design.\n\nSketch out (and debug) schema designs;\nExpress as many constraints as possible;\nConvert to relational DB once the client is happy."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#the-entityrelationship-er-model",
    "href": "notes/cs377/11-er-design/11 ER Design.html#the-entityrelationship-er-model",
    "title": "11 ER Design",
    "section": "The Entity/Relationship (E/R) Model",
    "text": "The Entity/Relationship (E/R) Model\n\nOverview:\n\nUsing the E/R model to model the real world.\nFrom there, designing a database schema:\n\nReconstructuring of an E/R model\nTranslating an E/R model into a logical model (DB schema)\n\nE/R model is a Visual data model (diagram-based):\n\nQuickly “chart out” a databse design\nEasier to “see” big picture\nComparable to class diagrams in UML\n\nBasic concept: entities and their relationships along with attributes describing them.\n\n\n\n\n\n\n\n\nNote 1: Entity Set: (Represented by a rectangle \\(\\Huge{\\boxed{\\ \\ }}\\))\n\n\n\n\nAn entity set represents a category of objects that have properties in common and an autonomous existence.\n\nE.g., City, Department, Employee, Sale\n\nAn entity is an instance of an entity set.\n\nE.g., “San Francisco” is an entity in the City entity set.\n\n\n\n\n\n\n\n\n\n\nNote 2: Relationship Sets: (Represented by a diamond \\(\\Huge{\\diamond}\\))\n\n\n\n\nA relationship set is an association between two or more entity sets.\n\nE.g., Residence is an relationship set between entity sets City and Employee.\n\nA relationship is an instance of a n-ary relationship set.\n\nE.g., the pairt (“San Francisco”, “John”) is an instance of relationship Residence.\n\n\n\n\n\nRecursive Relationships\n\nRecursive relationsihps relate an entity to itself.\nNote, sometimes, relationship is not symmetric.\n\nIn this case, we need to indicate the two roles that the entity plas in the relationship.\nE.g., “Sovereign” is a recurvie relationship of “Succession.” However, the two rols are “Predecessor” and “Successor”.\n\n\nTernary Relationships\n\nTernary relationships relate three entity sets.\nE.g., “Supply” is a ternary relationship between “Supplier”, “Product”, and “Department.”\n\n\n\n\n\n\n\n\nNote 3: Attributes: (Represented by an oval \\(\\Huge{\\circ}\\))\n\n\n\n\nAn attribute describes elementary properties of entities or relationships.\n\nE.g., “Name” is an attribute of the entity set “City.”\n\nAttributes may be single-valued or multi-valued.\nComposite attributes are grouped attributes of the same entity or relationship that have closed connected meaning or uses.\n\nE.g., “Address” is a composite attribute of the entity set “City.” “Address” can be further decomposed into “Street,” “City,” “State,” and “Zip.”\n\n\n\n\n\n\n\n\n\n\nNote 4: Cardinalities\n\n\n\n\nEach entity set participates in a relationship set with a minimum (min) and a maximum (max) cardinality.\nCardinalities constrain how entity instances participate in relationship instances.\nGraphically, cardinalities are represented by lines connecting entities to relationships.\n\n\n\n\n\n\nflowchart LR\n    A[Employee]---|\"(1,5)\"|B{Assignment}---|\"(0, 50)\"|C[Task]\n\n\n\n\n\n\n\nNote: an entity might not participate in any relationship.\nIn principle, cardinalities are pairs of non-negative integers \\((n,N)\\) such that \\(n\\leq N\\), where \\(N\\) means any number.\nMinimum cardinality \\(n\\):\n\nIf \\(0\\), entity participation in a relationship is optional.\nIf \\(1\\), entity participation in a relationship is rmandatory.\n\nMaximum cardinality \\(N\\):\n\nIf \\(1\\), each instance of the entity is associated with at most one instance of the relationship.\nIf \\(N\\), each instance of the entity is associated with many instances of the relationship.\n\n\n\n\n\nExamples of Cardinalities\n\n\n\n\n\n\nflowchart LR\n    A[Tourist]---|\"(1,N)\"|B{Reservation}---|\"(0, N)\"|C[Voyage]\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[Order]---|\"(0,1)\"|B{Sale}---|\"(1, 1)\"|V[Invoice]\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[Person]---|\"(1,1)\"|B{Residence}---|\"(0, N)\"|C[City]\n\n\n\n\n\n\n\nMultiplicity of Relationships\n\nIf entities \\(E_1\\) and \\(E_2\\) participate in relationship \\(R\\) with cardinalities \\((n_1,N_1)\\) and \\((n_2,N_2)\\), then the multiplicity of \\(R\\) is \\(N_1\\)-to-\\(N_2\\) (which is the same as \\(N_2\\)-to-\\(N_1\\)).\nExamples:\n\n\\(1\\)-to-\\(1\\)\n\\(1\\)-to-\\(N\\) or \\(N\\)-to-\\(1\\)\n\\(N\\)-to-\\(N\\)\n\n\nCardinalities of Attributes\n\nDescribe min/max number of values an attribute can have.\nWhen the cardinality of an attribute is \\((1,1)\\), it can be omitted (single-valued attributes).\nThe value of an attribute, nmay also be null or have several values (multi-valued attributes).\n\n\n\n\n\n\n\nflowchart LR\n    A((Surname)) --- B[Person]\n    C((License Number)) --- |\"(0,1)\"| B\n    B --- |\"(0, N)\"| D((CarRegistration#))\n\n\n\n\n\n\n\nMulti-valued attributes foten represent situations that can be modeled with additional entities.\n\nE.g., the above model can be transformed into the following model:\n\n\n\n\n\n\n\nflowchart LR\n    A((Surname)) --- B[Person]\n    C((License Number)) --- |\"(0,1)\"| B\n    B --- |\"(0,N)\"| E{Owns}\n    E --- |\"(1,1)\"| D((CarRegistration#))\n\n\n\n\n\n\n\n\n\n\n\n\nNote 5: Keys: (Represented by an underline \\(\\Huge{\\underline{\\ \\ }}\\) or \\(\\Huge{\\bullet}\\))\n\n\n\n\nKeys consist of minimal sets of attributes which uniquely identify instances of an entity set.\n\nSSN may be a key of Person\nfirstName, middleName, lastName, address may be a key of Person\n\nIn most cases, a key is formed by one or more attributes of the entity itself (internal key).\nSometimes, an entity doesn’t have a key among its attributes. This is called a weak entity.\n\nSolution: the keys of related entities brought into help with identification (becoming foreign keys).\n\nA key for a relationship consists of the keys of the entities it relates.\n\n\n\n\nExample of Keys\n\nInternal, single-attribute\ninternal, multi-attribute\nweak entity with foreign key \n\nExample of Schema with Keys"
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#challenges-in-er-design-modeling-the-real-world",
    "href": "notes/cs377/11-er-design/11 ER Design.html#challenges-in-er-design-modeling-the-real-world",
    "title": "11 ER Design",
    "section": "Challenges in E/R Design: Modeling the “Real World”",
    "text": "Challenges in E/R Design: Modeling the “Real World”\n\nLife is arbitrarily complex\nDesign choices: should a concept be modeled as an entity, an attribute, or a relationship?\nLimitations of the E/R Model: A lot of data semantics can be captured but some cannot.\nKey to successfull model: parsimony:\n\nAs complex as necessary, but no more.\nChoose to present only relevant things."
  },
  {
    "objectID": "notes/cs377/11-er-design/11 ER Design.html#from-er-model-to-relationship-database-schema",
    "href": "notes/cs377/11-er-design/11 ER Design.html#from-er-model-to-relationship-database-schema",
    "title": "11 ER Design",
    "section": "From E/R Model to Relationship Database Schema",
    "text": "From E/R Model to Relationship Database Schema\n\nRelational Database Design\n\nGiven a conceptual schema (ER, but could also be other models), generate a logical (relational) schema.\nIt is helpful to divide the design into two steps:\n\nRestructuring (refining) of the E/R schema, based on criteria for the optimization of the schema\n\nTranlation into the logical model, based on the features of the logical model (relational model)\n\n\n\nRestructuring An E/R Model\n\nRestructuring Overview\n\nInput: E/R Schema\nOUtput: Resturctured (Refined) E/R Schema\n\nRestructuring includes:\n\nAnalysis of redundancies\nChossing entity set vs. attribute\nLimiting the use of weak entity sets\nSelection of keys\nCreating entity sets to replace attributes with cardinality greater than one.\n\nExample: Redundancies\n\nIn the followign E/R schema, the attribute Manf. Address is redundant.\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    E((Manf. Address)) --- A\n\n\n\n\n\n\n\nThe schema can be restructured as follows:\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, 1)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nHowever, here’s still a redundancy in the schema: we don’t need the Manf. Name attribute.\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, 1)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nEntity Sets vs. Attributes\n\nAn entity set should satisfy at least one of the following conditions:\n\nIt is mor than the name of something; it has at least one non-key attribute, or\nIt is the many in a many-one or many-many relationship.\n\nRules of thumb:\n\nA thing in tis own right: entity set\nA detail about some other thing: attribute\nA detial correlated among many things: entity set\n\nIt is to avoid redundancy.\n\nExample: domain fact change: A Part can have more than one Manufacturer.\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nHowever, if we add another domain fact change: No manufacturer address:\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F\n\n\n\n\n\n\n\nManufacturer does not have a nonkey attribute anymore…\n\nHowever, it is an “many” in a many-to-many relaionship.\nSo, we cannot convert it to an attribute.\n\nExample: What if we start from the following schema?\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) --- A\n    E((Manf. Address)) --- A\n\n\n\n\n\n\n\nWe still apply the same domain fact changes:\n\nA Part can have more than one Manufacturer, and\nNo manufacturer address.\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) ---|\"(1,N)\"| A\n\n\n\n\n\n\n\nIt looks good, but we want to avoid multi-value attributes as it is not compatible with relational DBs.\nSo, we convert the multi-value attribute Manf. Name to an entity set.\nAnother example: if we apply the domain fact change: A Manufactuere can have 0 Part. Then,\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(0, N)\"| F\n    F --- G((Address))\n\n\n\n\n\n\n\nIf no parts are associated with a manufacturer, then we lose all information on the manufacturer in this system.\nWhen to use weak entity sets?\n\nThe usual reason is that there is no global authority capble of creating unique IDs.\n\nDon’t oversue weak entity sets:\n\nBeginner database designers often doubt that anything could be a key by itself:\n\nThe make all entity sets weak, supported by all other entity sets to which they are linked.\n\nIt is usually better to create unique IDs\n\nSelecting a Primary Key\n\nEvery entity must have a primary key.\nThe crteria for this decision are as follows:\n\nAttributes with null values cannot form primary keys.\nOne/few attributes is preferable to many attributes.\nInternal keys preferable to external ones (week entities depend for their existence on other entities).\n\n\nKeep Keys Simple: Multi-attribute and/or string keys\n\nWaste space (are redundant)\nBreak encapsulation\nAre brittle (nasty interaction of above two points)\nAlso: computers are good at numbers, not strings.\n\nAttributes with Cardinality Greater than One\n\nThe relational model doesn’t allow multi-valued attributes. We must convert these to entity sets.\n\nExample: Multi-valued Attributes\n\nConsider the following schema:\n\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    D((Manf. Name)) ---|\"(1,N)\"| A\n\n\n\n\n\n\n\nWe have to convert it to the following schema (making Manf. Name an entity set):\n\n\n\n\n\n\nflowchart LR\n    B((\"&lt;u&gt;Part Number&lt;/u&gt;\")) --- A[Part]\n    C((Name)) --- A\n    F[Manufacturer] --- H((\"&lt;u&gt;Name&lt;/u&gt;\"))\n    A --- |\"(1, N)\"| E{\"Made By\"}\n    E --- |\"(1, N)\"| F"
  }
]